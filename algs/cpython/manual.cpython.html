<html>
<head>
<style type="text/css">
h1              { background-color: #808080; padding: 0.2em; }
h2              { background-color: #B0B0B0; padding: 0.2em; }
h3              { background-color: #E0E0E0; padding: 0.2em; }
sheader         { }
.inlineheader   { background-color: #E8E8E8; padding: 0.1em; font-weight:bold; }
.pagecontent    { font-family: Arial; font-size: 10pt; width: 770px; text-align: justify; }
.pageheader     { width: 770px; }
.source         { font-family: "Courier New"; font-size: 10pt; }

.p_example      { margin-left: 4em; }
.p_note         { margin-left: 50px; width: 720px; font-size: 80%; }
.s_code         { font-family: "Courier New"; background-color: #F0F0F0; }
.s_str          { font-family: "Courier New"; color: blue; font-weight: bold; }
.s_comment      { color: navy; font-style: italic; }
.s_preprocessor { color: green; }

a               { color:#000077; text-decoration: underline; }
a:visited       { color:#000077; text-decoration: underline;}
a:hover         { color:#000077; text-decoration: underline; }

a.toc           { color:#000077; text-decoration: none; }
a.toc:visited   { color:#000077; text-decoration: none;}
a.toc:hover     { color:#000077; text-decoration: underline; }

a.nav           { color:#000077; font-weight:bold; text-decoration: none; }
a.nav:visited   { color:#000077; font-weight:bold; text-decoration: none;}
a.nav:hover     { color:#000077; font-weight:bold; text-decoration: underline; }

.cond           { color:blue; }
.const          { color:#222222; }
.func           { color:#111111; }
</style>
</head>
<body>
<pre>
<a href='#int_main'>1 Introduction</a>
    <a href='#int_license'>1.1 ALGLIB license</a>
    <a href='#int_doc_license'>1.2 Documentation license</a>
    <a href='#gs_guide'>1.3 Reference Manual and User Guide</a>
    <a href='#int_ack'>1.4 Acknowledgements</a>
<a href='#gs_main'>2 Getting started with ALGLIB</a>
    <a href='#gs_about'>2.1 About ALGLIB for Python</a>
    <a href='#gs_c_compatibility'>2.2 Compatibility</a>
        <a href='#gs_c_compatibility_cpu'>2.2.1 CPU</a>
        <a href='#gs_compatibility_os'>2.2.2 OS</a>
        <a href='#gs_compatibility_interpreter'>2.2.3 Python interpreter</a>
        <a href='#gs_compatibility_compiler'>2.2.4 C compiler</a>
        <a href='#gs_compatibility_opt'>2.2.5 C compiler: optimization settings</a>
    <a href='#gs_win_installing'>2.3 Installing ALGLIB under Windows</a>
    <a href='#gs_unix_installing'>2.4 Installing ALGLIB under *nix</a>
        <a href='#gs_unix_installing_intro'>2.4.1 OS support</a>
        <a href='#gs_unix_installing_compile'>2.4.2 Basic compilation</a>
        <a href='#gs_unix_installing_tuning'>2.4.3 Additional compiler options</a>
        <a href='#gs_unix_installing_final'>2.4.4 Installation</a>
    <a href='#gs_using_noinst'>2.5 Using ALGLIB without installation</a>
    <a href='#gs_working_with'>2.6 Working with ALGLIB</a>
        <a href='#gs_datatypes'>2.6.1 Datatypes</a>
        <a href='#gs_functions'>2.6.2 Calling ALGLIB functions</a>
        <a href='#gs_errors'>2.6.3 Handling errors</a>
<a href='#alglib_main'>3 ALGLIB reference manual</a>

</pre>
<div class=pagecontent>
<a name='int_main' class='sheader'></a><h1>1 Introduction</h1>

<a name='int_license' class='sheader'></a><h2>1.1 ALGLIB license</h2>

<p align=justify>
ALGLIB is a free software which uses dual licensing. You can either use it under GPL license (version 2 or at your option any later version)
or buy commercial license without copyleft requirement.
A copy of the GNU General Public License is available at <a href='http://www.fsf.org/licensing/licenses'>http://www.fsf.org/licensing/licenses</a>
A copy of the commercial license can be found at <a href='http://www.alglib.net/commercial.php'>http://www.alglib.net/commercial.php</a>
</p>

<a name='int_doc_license' class='sheader'></a><h2>1.2 Documentation license</h2>

<div style='width: 640px;'>
<p>
<U>This reference manual is licensed under BSD-like documentation license</U>:
</p>

<p>
Copyright 1994-2009 Sergey Bochkanov, ALGLIB Project. All rights reserved.
</p>

<p>
Redistribution and use of this document (ALGLIB Reference Manual) with or without modification,
are permitted provided that such redistributions will retain the above copyright notice,
this condition and the following disclaimer as the first (or last) lines of this file.
</p>

<p>
THIS DOCUMENTATION IS PROVIDED BY THE ALGLIB PROJECT "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE ALGLIB PROJECT BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS DOCUMENTATION, EVEN IF ADVISED
OF THE POSSIBILITY OF SUCH DAMAGE.
</p>
</div>

<a name='gs_guide' class='sheader'></a><h2>1.3 Reference Manual and User Guide</h2>

<p>
ALGLIB Project provides two sources of information: ALGLIB Reference Manual (this document) and <a href="http://www.alglib.net/#book">ALGLIB User Guide</a>.
</p>

<p>
ALGLIB Reference Manual contains full description of all publicly accessible ALGLIB units accompanied with examples.
Reference Manual is focused on the source code: it documents units, functions, structures and so on.
If you want to know what unit <code>YYY</code> can do or what subroutines unit <code>ZZZ</code> contains Reference Manual is a place to go.
Free software needs free documentation - that's why ALGLIB Reference Manual is licensed under BSD-like documentation license.
</p>

<p>
Additionally to the Reference Manual we provide you <a href="http://www.alglib.net/#book">User Guide</a>.
User Guide is focused on more general questions: how fast ALGLIB is? how reliable it is? what are the strong and weak sides of the algorithms used?
We aim to make ALGLIB User Guide an important source of information both about ALGLIB and numerical analysis algorithms in general.
We want it to be a book about algorithms, not just software documentation.
And we want it to be unique - that's why ALGLIB User Guide is distributed under less-permissive <a href="http://alglib.net.localhost/#guide_license">personal-use-only license</a>.
</p>

<a name='int_ack' class='sheader'></a><h2>1.4 Acknowledgements</h2>

<p>
ALGLIB was not possible without contribution of the next open source projects:
</p>

<ul>
<li><a href="http://www.netlib.org/lapack/">LAPACK</a></li>
<li><a href="http://www.moshier.net/">Cephes</a></li>
<li><a href="http://gmplib.org/">GNU MP</a></li>
<li><a href="http://www.mpfr.org/">MPFR</a></li>
</ul>




<a name='gs_main' class='sheader'></a><h1>2 Getting started with ALGLIB</h1>



<a name='gs_about' class='sheader'></a><h2>2.1 About ALGLIB for Python</h2>

<p>
ALGLIB for CPython is an interface to the computational core written in C.
It includes wrapper module <code>xalglib.py</code> which connects to the ALGLIB shared library
through the <code>ctypes</code> foreign functions interface (part of standard Python distribution since 2.5).
</p>

<p>
Unlike many other Python-C libraries, ALGLIB <b>is not a C extension module</b> (i.e. it is not C library which uses C API provided by Python and is compiled using Python build facilities).
ALGLIB shared library is compiled 100% separately from Python and is accesses through general purpose foreign functions interface (<code>ctypes</code>).
It makes ALGLIB quite insensitive to the Python version - it can work both with 2.x and 3.x branches without any tweaks/changes.
</p>

<p>
As non-pure Python library, ALGLIB requires compilation by C compiler.
On Windows platform, however, you can use precompiled computational core, so you won't need anything beyond Python interpreter.
On Unix platforms you have to compile ALGLIB youself.
</p>

<a name='gs_c_compatibility' class='sheader'></a><h2>2.2 Compatibility</h2>

<a name='gs_c_compatibility_cpu' class='sheader'></a><h3>2.2.1 CPU</h3>

<p>
ALGLIB for CPython is compatible with any CPU which:
</p>

<ul>
<li>supports double precision arithmetics</li>
<li>complies with IEEE 754 floating point standard (especially in its handling of IEEE special values)</li>
<li>either big-endian or little-endian (but not mixed-endian)</li>
</ul>

<p>
Most mainstream CPU's satisfy these requirements.
However, it was tested only with x86, x86_64 and SPARC.
</p>

<p class='p_note'>
As for Intel architecture, ALGLIB works with both FPU-based and SSE-based implementations of floating point math.
80-bit internal representation used by Intel FPU is not a problem for ALGLIB.
</p>

<a name='gs_compatibility_os' class='sheader'></a><h3>2.2.2 OS</h3>

<p>
Computational core is compatible with any OS.
However, script which builds core was tested only under Windows, Linux and Solaris.
</p>

<a name='gs_compatibility_interpreter' class='sheader'></a><h3>2.2.3 Python interpreter</h3>

<p>
ALGLIB for CPython is compatible with any Python version since 2.6 (both Python 2.x and 3.x are supported).
It is partially compatible with Python 2.5 because <code>ctypes</code> implementation on some platforms wasn't stable enough
(you may get error messages during installation).
</p>

<a name='gs_compatibility_compiler' class='sheader'></a><h3>2.2.4 C compiler</h3>

<p>
Being non-pure Python library, ALGLIB needs C compiler for compilation of its computational core.
ALGLIB is compatible with any C compiler which:
</p>

<ul>
<li>supports 32-bit and 64-bit signed integer datatypes</li>
<li>emits code which handles <i>comparisons</i> with IEEE special values without raising exception.
We don't require that <code>x/0</code> will return <code>INF</code>.
But at least we must be able to <i>compare</i> double precision value with infinity or NAN without raising exception.</li>
</ul>

<p>
All modern compilers (in particular, reasonably new versions of MSVC, GCC and Sun Studio) satisfy these requirements.
</p>

<p>
However, some <i>very</i> old compilers (ten years old version of Borland C++ Builder, for example) may emit code which does not correctly works with IEEE special values.
If you use one of these old compilers, we recommend you to run ALGLIB test suite to ensure that library works.
</p>

<a name='gs_compatibility_opt' class='sheader'></a><h3>2.2.5 C compiler: optimization settings</h3>

<p>
ALGLIB is compatible with any kind of optimization settings as long as:
</p>

<ul>
<li><b>volatile</b> modifier is correctly handled (i.e. compiler does <b>not</b> optimize volatile reads/writes)</li>
<li>optimized code correctly handles IEEE special values</li>
</ul>

<p>
Generally, all kinds of optimization that were marked by compiler vendor as "safe" are possible. For example, ALGLIB can be compiled:
</p>

<ul>
<li>under MSVC: with /O1, /O2, /Og, /Os, /Ox, /Ot, /Oy, /fp:precise, /fp:except, /fp:strict</li>
<li>under GCC: with -O1, -O2, -O3, -Os</li>
</ul>

<p>
From the other side, following "unsafe" optimizations will break ALGLIB:
</p>

<ul>
<li>under MSVC:  /fp:fast</li>
<li>under GCC: -Ofast, -ffast-math</li>
</ul>

<a name='gs_win_installing' class='sheader'></a><h2>2.3 Installing ALGLIB under Windows</h2>

<p>
Windows version of ALGLIB for Python is distributed with precompiled computational core.
So the only thing you have to do is to exec
</p>

<pre class='p_example'>
python setup.py install
</pre>

<p>
from ALGLIB root directory.
Setup script will select appropriate version of the ALGLIB core (either 32-bit or 64-bit)
and will install it along with wrapper into corresponding dirs of your local Python installation.
</p>

<p>
Windows version ALGLIB core was compiled under MSVC with SSE2 support (activated if CPU supports SSE2) and "/O2" optimization settings, which should work in all situations possible.
If, for some reason, you want to recompile core, you can do so by <code>cd</code>'ing into <code>core</code> directory and executing <code>build-windows-msvc.bat</code> script
(you should have MSVC in your PATH environment variable).
It will produce <code>alglib.dll</code> library, which will have precedence over <code>alglib32.dll</code> (precompiled 32-bit core) and <code>alglib64.dll</code> (precompiled 64-bit core).
</p>

<a name='gs_unix_installing' class='sheader'></a><h2>2.4 Installing ALGLIB under *nix</h2>

<a name='gs_unix_installing_intro' class='sheader'></a><h3>2.4.1 OS support</h3>

<p>
ALGLIB for Python can be used under following *nix systems:
</p>

<ul>
<li>Linux</li>
<li>Solaris/OpenSolaris</li>
</ul>

<p>
Absense of other systems doesn't mean that it won't work under, say, BSD - it just means that ALGLIB was not <i>tested</i> under BSD yet.
</p>

<a name='gs_unix_installing_compile' class='sheader'></a><h3>2.4.2 Basic compilation</h3>

<p>
It is impossible to generate binaries which are portable across different *nix platforms so before installing ALGLIB you have to compile computational core.
Current version of ALGLIB core needs either GCC or Sun Studio for compilation.
To compile it you should:
</p>

<ul>
<li>
set <code>$CC</code> envorinment variable to a working compiler (it may be simply <code>gcc</code>)
</li>
<li>
load additional compiler flags to the <code>$CFLAGS</code> envoronment variable. We recommend you to explicitly set <code>-m32</code>
when you compile for 32-bit Python and explicitly tell compiler to generate 64-bit binaries with <code>-m64</code> when you use 64-bit Python.
</li>
<li>
<code>cd</code> into <code>core</code> subdirectory of ALGLIB distribution and execute <code>./build-unix</code>
</li>
</ul>

<a name='gs_unix_installing_tuning' class='sheader'></a><h3>2.4.3 Additional compiler options</h3>

<p>
The only thing that is <b>required</b> for successful compilation/installation is correct choise of binary type - 32-bit or 64-bit.
However, you may want to improve ALGLIB performance by specifying additional options in the <code>$CFLAGS</code> environment variable:
</p>

<ul>
<li>
<span class='s_code'>-O2</span> for better performance
</li>
<li>
<span class='s_code'>-DAE_CPU=AE_INTEL -msse2</span> to turn on SSE2 support (you need Intel/AMD CPU to do so)
</li>
</ul>

<a name='gs_unix_installing_final' class='sheader'></a><h3>2.4.4 Installation</h3>

<p>
After compilation is over, you can <code>cd</code> into main directory of ALGLIB distribution and type
</p>

<pre class='p_example'>
python setup.py install
</pre>

<p>
as it is usually done with Python packages.
</p>

<a name='gs_using_noinst' class='sheader'></a><h2>2.5 Using ALGLIB without installation</h2>

<p>
Sometimes you may need to use ALGLIB without installation. For example, you may want to create self-contained Python library or simply don't have root access to your system.
</p>

<p>
Under Windows system you should:
</p>

<ul>
<li>
copy <code>xalglib.py</code> to the directory of your choice
</li>
<li>
select appropriate precompiled library (<code>alglib32.dll</code> or <code>alglib64.dll</code>) from <code>core</code> directory,
rename it to <code>alglib.dll</code>,
and copy it to the directory where you've copied <code>xalglib.py</code>
</li>
<li>
import <code>xalglib.py</code> from your Python program - it will detect presense of <code>alglib.dll</code> in the same directory and load it.
</li>
</ul>

<p>
Under *nix everything looks similar:
</p>

<ul>
<li>
copy <code>xalglib.py</code> to the directory of your choice
</li>
<li>
compile ALGLIB core (as was described above) and copy <code>alglib.so</code> to the directory where you've copied <code>xalglib.py</code>
</li>
<li>
import <code>xalglib.py</code> from your Python program - it will detect presense of <code>alglib.so</code> in the same directory and load it.
</li>
</ul>



<a name='gs_working_with' class='sheader'></a><h2>2.6 Working with ALGLIB</h2>

<a name='gs_datatypes' class='sheader'></a><h3>2.6.1 Datatypes</h3>

<p>
Following datatypes can be used with ALGLIB functions:
</p>

<ul>
<li>scalar types - boolean, integer, real, complex</li>
<li>lists (interpreted as vectors)</li>
<li>lists of lists (interpreted as matrices)</li>
<li>classes</li>
</ul>

<p>
ALGLIB uses Python lists to <i>accept</i> and <i>return</i> vectors (although deep in the internals ALGLIB uses more efficient data structures).
Vector can be boolean, integer, real or complex.
If ALGLIB function expects integer vector, you can't pass list with real elements (exception will be thrown in such cases).
Contrary, function which expects real vector can process list whose elements are integers (i.e. <span class='s_code'>[1.0, 2.0]</span> and <span class='s_code'>[1,2]</span> are considered same).
</p>

<p>
Lists of lists are used to accept and return matrices.
Just like vectors, matrices can be boolean, integer, real or complex.
List of lists is a valid matrix if it has rectangular form.
</p>

<pre class='p_example'>
<span style='color: darkcyan;'># valid matrices</span>
v0 = [[]]
v1 = [[1],[2]]
v2 = [[1,2]]
v3 = [[1,2],[3,4]]

<span style='color: darkcyan;'># invalid matrices</span>
i0 = [[1],[1,2]]
i1 = ["string"]
</pre>

<p>
ALGLIB package contains many classes that can be divided into two distinct groups: "transparent" classes, i.e. classes whose fields are publicly accessible,
and "handle" classes, which do not have publicly accessible fields at all.
</p>

<p>
"Transparent" classes are mostly used to report algorithm results.
One common idiom is for algorithm to return both solution and structure which contains additional information (iterations count, stopping criterion met, etc.).
"Transparent" classes are 100% transparent - there is no private fields and no pointers to "external" objects (i.e. objects which are not part of Python data model).
</p>

<p>
"Handle" classes represent another programming idiom - opaque pointer.
Contrary to "transparent" classes, they have no public fields and you should use ALGLIB functions to work with them.
"Handle" classes are used to work with complex structures managed by ALGLIB environment - optimizers, solvers, neural networks.
Instance of "handle" class stores only a pointer to the external object (in CPython it is native object accesed through <code>ctypes</code>, and IronPython it is C# object).
Instances of "handle" class are created by calling corresponding ALGLIB functions and are automatically freed when there are no references to them.
They are "pointer-like", i.e. multiple copies of Python wrapper object actually point to the same ALGLIB object.
</p>

<a name='gs_functions' class='sheader'></a><h3>2.6.2 Calling ALGLIB functions</h3>

<p>
All ALGLIB functionality can be accessed through one module - <code>xalglib.py</code>, which should be imported before you start to use ALGLIB.
</p>

<p>
ALGLIB functions can be divided into three categories: a) functions which do not return anything, b) functions which return only one value, and c) functions which return multiple values.
Functions from the first category are used to changed state of ALGLIB object (which is usually represented by instance of "handle" class).
Second category should be well-known to any programmer.
Third category differs from previous one in only one aspect - how multiple values are returned.
In such cases ALGLIB returns tuple containing all output values.
</p>

<pre class='p_example'>
import xalglib

def function1_grad(x, grad, param):
    func = 100*(x[0]+3)**4 + (x[1]-3)**4
    grad[0] = 400*(x[0]+3)**3
    grad[1] = 4*(x[1]-3)**3
    return func

<span style='color: darkcyan;'># L-BFGS optimizer with m=2 is created, one result is returned</span>
s = xalglib.minlbfgscreate(2,[0,0,0])

<span style='color: darkcyan;'># function with no output values is called</span>
xalglib.minlbfgssetcond(state, 0, 0, 0, 10)

<span style='color: darkcyan;'># some optimization code here </span>
xalglib.minlbfgsoptimize_g(state, function1_grad)

<span style='color: darkcyan;'># and, finally, call to function with multiple outputs </span>
x, rep = xalglib.minlbfgsresults(state)
</pre>

<p>
Most ALGLIB functions provide two interfaces: 'expert' and 'friendly'.
What is the difference between two?
When you use 'friendly' interface, ALGLIB:
</p>

<ul>
<li>tries to automatically determine size of input arguments</li>
<li>throws an exception when arguments have inconsistent size (for example, square matrix is expected, but non-square is passed;
another example - two parameters must have same size, but have different size)</li>
<li>if semantics of input parameter assumes that it is symmetric/Hermitian matrix,
checks that lower triangle is equal to upper triangle (conjugate of upper triangle) and throws an exception otherwise</li>
<li>if semantics of output parameter assumes that it is symmetric/Hermitian matrix,
returns full matrix (both upper and lower triangles)</li>
</ul>

<p>
When you use 'expert' interface, ALGLIB:
</p>

<ul>
<li>requires caller to explicitly specify size of input arguments.
If vector/matrix is larger than size being specified (say, N), only N leading elements are used</li>
<li>if semantics of input parameter assumes that it is symmetric/Hermitian matrix,
uses <i>only upper or lower triangle</i> of input matrix and requires caller <i>to specify what triangle to use</i></li>
<li>if semantics of output parameter assumes that it is symmetric/Hermitian matrix, returns only upper or lower triangle
(when you look at specific function, it is clear what triangle is returned)</li>
</ul>

<p>
Here are several examples of 'friendly' and 'expert' interfaces:
</p>

<pre class='p_example'>
import xalglib

x  = [0,1,2,3]
y  = [1,5,3,9]
y2 = [1,5,3,9,0]


s = xalglib.spline1dbuildlinear(x, y, 4) <span style='color: darkcyan;'># 'expert' interface is used, we passed the number of points</span>
s = alglib::spline1dbuildlinear(x, y)    <span style='color: darkcyan;'># 'friendly' interface - input size is</span>
                                         <span style='color: darkcyan;'># automatically determined</span>

s = alglib::spline1dbuildlinear(x, y2, 4) <span style='color: darkcyan;'># y2.length() is 5 (larger then len(x)), but it will work</span>

s = alglib::spline1dbuildlinear(x, y2)    <span style='color: darkcyan;'># it won't work because sizes of x and y2</span>
                                          <span style='color: darkcyan;'># are inconsistent</span>
</pre>

<p>
'Friendly' interface - matrix semantics:
</p>

<pre class='p_example'>
import xalglib

<span style='color: darkcyan;'># </span>
<span style='color: darkcyan;'># 'Friendly' interface: spdmatrixinverse() accepts and returns symmetric matrix</span>
<span style='color: darkcyan;'># </span>

<span style='color: darkcyan;'># symmetric positive definite matrix</span>
a = [[2,1],[1,2]]

<span style='color: darkcyan;'># after this line A will contain [[0.66,-0.33],[-0.33,0.66]]</span>
<span style='color: darkcyan;'># which is symmetric too</span>
a, info, rep = xalglib.spdmatrixinverse(a)

<span style='color: darkcyan;'># you may try to pass nonsymmetric matrix</span>
a = [[2,1],[0,2]]

<span style='color: darkcyan;'># but exception will be thrown in such case</span>
a, info, rep = xalglib.spdmatrixinverse(a)
</pre>

<p>
Same function but with 'expert' interface:
</p>

<pre class='p_example'>
import xalglib

<span style='color: darkcyan;'># </span>
<span style='color: darkcyan;'># 'Expert' interface, spdmatrixinverse()</span>
<span style='color: darkcyan;'># </span>

<span style='color: darkcyan;'># only upper triangle is used; a[1][0] is initialized by NAN,</span>
<span style='color: darkcyan;'># but it can be arbitrary number</span>
a = [[2,1],[float("nan"),2]]

<span style='color: darkcyan;'># after this line A will contain [[0.66,-0.33],[NAN,0.66]]</span>
<span style='color: darkcyan;'># only upper triangle is modified</span>
<span style='color: darkcyan;'># </span>
<span style='color: darkcyan;'># we use 'expert' form of spdmatrixinverse, which is spdmatrixinverse(a, n, isupper)</span>
a, info, rep = xalglib.spdmatrixinverse(a, 2, true)
</pre> 

<a name='gs_errors' class='sheader'></a><h3>2.6.3 Handling errors</h3>

<p>
ALGLIB uses two error handling strategies:
</p>

<ul>
<li>returning error code</li>
<li>throwing exception</li>
</ul>

<p>
What is actually done depends on function being used and error being reported:
</p>

<ol>
<li>if function returns some error code <b>and</b> has corresponding value for this kind of error, ALLGIB returns error code</li>
<li>if function does not return error code (or returns error code, but there is no code for error being reported), ALGLIB throws <code>RuntimeError</code> exception.</li>
<li>if it is some very basis error in the inputs, like expecting to get matrix and getting scalar instead, <code>ValueError</code> will be thrown.</li>
</ol>

<p>
To make things clear we consider several examples of error handling.
</p>

<p>
<u>Example 1</u>. <a href="#sub_mincgcreate">mincgreate</a> function creates nonlinear CG optimizer. It accepts problem size <code>N</code> and initial point <code>X</code>.
Several things can go wrong - you may pass array which is too short, filled by NAN's, or otherwise pass incorrect data.
However, this function returns no error code - so it throws an exception in case something goes wrong.
There is no other way to tell caller that something went wrong.
</p>

<p>
<u>Example 2</u>. <a href="#sub_rmatrixinverse">rmatrixinverse</a> function calculates inverse matrix.
It returns error code, which is set to <code>+1</code> when problem is solved and is set to <code>-3</code> if singular matrix was passed to the function.
However, there is no error code for matrix which is non-square or contains infinities.
Well, we could have created corresponding error codes - but we didn't.
So if you pass singular matrix to <code>rmatrixinverse</code>, you will get completion code <code>-3</code>.
But if you pass matrix which contains INF in one of its elements, <code>alglib::ap_error</code> will be thrown.
</p>

<p>
First error handling strategy (error codes) is used to report "frequent" errors, which can occur during normal execution of user program.
Second error handling strategy (exceptions) is used to report "rare" errors which are result of serious flaws in your program (or ALGLIB) - 
infinities/NAN's in the inputs, inconsistent inputs, etc.
</p>


</div>
<a name='alglib_main' class='sheader'></a><h1>3 ALGLIB reference manual</h1>
<a name='alglib_packages'></a><h2>Packages and modules</h2>
<table border=0 cellspacing=0>
<tr align=left valign=top><td colspan=3 bgcolor=#E8E8E8><b><code>AlglibMisc</code> package</b></td></tr>
<tr align=left valign=top><td><a href='#unit_hqrnd' class=toc>hqrnd</a></td><td width=15>&nbsp;</td><td>High quality random numbers generator</td></tr>
<tr align=left valign=top><td><a href='#unit_nearestneighbor' class=toc>nearestneighbor</a></td><td width=15>&nbsp;</td><td>Nearest neighbor search: approximate and exact</td></tr>
<tr align=left valign=top><td colspan=2>&nbsp;</td></tr>
<tr align=left valign=top><td colspan=3 bgcolor=#E8E8E8><b><code>DataAnalysis</code> package</b></td></tr>
<tr align=left valign=top><td><a href='#unit_bdss' class=toc>bdss</a></td><td width=15>&nbsp;</td><td>Basic dataset functions</td></tr>
<tr align=left valign=top><td><a href='#unit_dforest' class=toc>dforest</a></td><td width=15>&nbsp;</td><td>Decision forest classifier (regression model)</td></tr>
<tr align=left valign=top><td><a href='#unit_kmeans' class=toc>kmeans</a></td><td width=15>&nbsp;</td><td>K-means++ clustering</td></tr>
<tr align=left valign=top><td><a href='#unit_lda' class=toc>lda</a></td><td width=15>&nbsp;</td><td>Linear discriminant analysis</td></tr>
<tr align=left valign=top><td><a href='#unit_linreg' class=toc>linreg</a></td><td width=15>&nbsp;</td><td>Linear models</td></tr>
<tr align=left valign=top><td><a href='#unit_logit' class=toc>logit</a></td><td width=15>&nbsp;</td><td>Logit models</td></tr>
<tr align=left valign=top><td><a href='#unit_mlpbase' class=toc>mlpbase</a></td><td width=15>&nbsp;</td><td>Basic neural network operations</td></tr>
<tr align=left valign=top><td><a href='#unit_mlpe' class=toc>mlpe</a></td><td width=15>&nbsp;</td><td>Neural network ensemble models</td></tr>
<tr align=left valign=top><td><a href='#unit_mlptrain' class=toc>mlptrain</a></td><td width=15>&nbsp;</td><td>Neural network training</td></tr>
<tr align=left valign=top><td><a href='#unit_pca' class=toc>pca</a></td><td width=15>&nbsp;</td><td>Principal component analysis</td></tr>
<tr align=left valign=top><td colspan=2>&nbsp;</td></tr>
<tr align=left valign=top><td colspan=3 bgcolor=#E8E8E8><b><code>DiffEquations</code> package</b></td></tr>
<tr align=left valign=top><td><a href='#unit_odesolver' class=toc>odesolver</a></td><td width=15>&nbsp;</td><td>Ordinary differential equation solver</td></tr>
<tr align=left valign=top><td colspan=2>&nbsp;</td></tr>
<tr align=left valign=top><td colspan=3 bgcolor=#E8E8E8><b><code>FastTransforms</code> package</b></td></tr>
<tr align=left valign=top><td><a href='#unit_conv' class=toc>conv</a></td><td width=15>&nbsp;</td><td>Fast real/complex convolution</td></tr>
<tr align=left valign=top><td><a href='#unit_corr' class=toc>corr</a></td><td width=15>&nbsp;</td><td>Fast real/complex cross-correlation</td></tr>
<tr align=left valign=top><td><a href='#unit_fft' class=toc>fft</a></td><td width=15>&nbsp;</td><td>Real/complex FFT</td></tr>
<tr align=left valign=top><td><a href='#unit_fht' class=toc>fht</a></td><td width=15>&nbsp;</td><td>Real Fast Hartley Transform</td></tr>
<tr align=left valign=top><td colspan=2>&nbsp;</td></tr>
<tr align=left valign=top><td colspan=3 bgcolor=#E8E8E8><b><code>Integration</code> package</b></td></tr>
<tr align=left valign=top><td><a href='#unit_autogk' class=toc>autogk</a></td><td width=15>&nbsp;</td><td>Adaptive 1-dimensional integration</td></tr>
<tr align=left valign=top><td><a href='#unit_gkq' class=toc>gkq</a></td><td width=15>&nbsp;</td><td>Gauss-Kronrod quadrature generator</td></tr>
<tr align=left valign=top><td><a href='#unit_gq' class=toc>gq</a></td><td width=15>&nbsp;</td><td>Gaussian quadrature generator</td></tr>
<tr align=left valign=top><td colspan=2>&nbsp;</td></tr>
<tr align=left valign=top><td colspan=3 bgcolor=#E8E8E8><b><code>Interpolation</code> package</b></td></tr>
<tr align=left valign=top><td><a href='#unit_idwint' class=toc>idwint</a></td><td width=15>&nbsp;</td><td>Inverse distance weighting: interpolation/fitting</td></tr>
<tr align=left valign=top><td><a href='#unit_lsfit' class=toc>lsfit</a></td><td width=15>&nbsp;</td><td>Linear and nonlinear least-squares solvers</td></tr>
<tr align=left valign=top><td><a href='#unit_polint' class=toc>polint</a></td><td width=15>&nbsp;</td><td>Polynomial interpolation/fitting</td></tr>
<tr align=left valign=top><td><a href='#unit_pspline' class=toc>pspline</a></td><td width=15>&nbsp;</td><td>Parametric spline interpolation</td></tr>
<tr align=left valign=top><td><a href='#unit_ratint' class=toc>ratint</a></td><td width=15>&nbsp;</td><td>Rational interpolation/fitting</td></tr>
<tr align=left valign=top><td><a href='#unit_spline1d' class=toc>spline1d</a></td><td width=15>&nbsp;</td><td>1D spline interpolation/fitting</td></tr>
<tr align=left valign=top><td><a href='#unit_spline2d' class=toc>spline2d</a></td><td width=15>&nbsp;</td><td>2D spline interpolation</td></tr>
<tr align=left valign=top><td colspan=2>&nbsp;</td></tr>
<tr align=left valign=top><td colspan=3 bgcolor=#E8E8E8><b><code>LinAlg</code> package</b></td></tr>
<tr align=left valign=top><td><a href='#unit_ablas' class=toc>ablas</a></td><td width=15>&nbsp;</td><td>Level 2 and Level 3 BLAS operations</td></tr>
<tr align=left valign=top><td><a href='#unit_bdsvd' class=toc>bdsvd</a></td><td width=15>&nbsp;</td><td>Bidiagonal SVD</td></tr>
<tr align=left valign=top><td><a href='#unit_evd' class=toc>evd</a></td><td width=15>&nbsp;</td><td>Eigensolvers</td></tr>
<tr align=left valign=top><td><a href='#unit_inverseupdate' class=toc>inverseupdate</a></td><td width=15>&nbsp;</td><td>Sherman-Morrison update of the inverse matrix</td></tr>
<tr align=left valign=top><td><a href='#unit_matdet' class=toc>matdet</a></td><td width=15>&nbsp;</td><td>Determinant calculation</td></tr>
<tr align=left valign=top><td><a href='#unit_matgen' class=toc>matgen</a></td><td width=15>&nbsp;</td><td>Random matrix generation</td></tr>
<tr align=left valign=top><td><a href='#unit_matinv' class=toc>matinv</a></td><td width=15>&nbsp;</td><td>Matrix inverse</td></tr>
<tr align=left valign=top><td><a href='#unit_ortfac' class=toc>ortfac</a></td><td width=15>&nbsp;</td><td>Real/complex QR/LQ, bi(tri)diagonal, Hessenberg decompositions</td></tr>
<tr align=left valign=top><td><a href='#unit_rcond' class=toc>rcond</a></td><td width=15>&nbsp;</td><td>Condition number estimate</td></tr>
<tr align=left valign=top><td><a href='#unit_schur' class=toc>schur</a></td><td width=15>&nbsp;</td><td>Schur decomposition</td></tr>
<tr align=left valign=top><td><a href='#unit_spdgevd' class=toc>spdgevd</a></td><td width=15>&nbsp;</td><td>Generalized symmetric eigensolver</td></tr>
<tr align=left valign=top><td><a href='#unit_svd' class=toc>svd</a></td><td width=15>&nbsp;</td><td>Singular value decomposition</td></tr>
<tr align=left valign=top><td><a href='#unit_trfac' class=toc>trfac</a></td><td width=15>&nbsp;</td><td>LU and Cholesky decompositions</td></tr>
<tr align=left valign=top><td colspan=2>&nbsp;</td></tr>
<tr align=left valign=top><td colspan=3 bgcolor=#E8E8E8><b><code>Optimization</code> package</b></td></tr>
<tr align=left valign=top><td><a href='#unit_minasa' class=toc>minasa</a></td><td width=15>&nbsp;</td><td>ASA bound constrained optimizer</td></tr>
<tr align=left valign=top><td><a href='#unit_minbleic' class=toc>minbleic</a></td><td width=15>&nbsp;</td><td>Bound constrained optimizer with additional linear equality/inequality constraints </td></tr>
<tr align=left valign=top><td><a href='#unit_mincg' class=toc>mincg</a></td><td width=15>&nbsp;</td><td>Conjugate gradient optimizer</td></tr>
<tr align=left valign=top><td><a href='#unit_minlbfgs' class=toc>minlbfgs</a></td><td width=15>&nbsp;</td><td>Limited memory BFGS optimizer</td></tr>
<tr align=left valign=top><td><a href='#unit_minlm' class=toc>minlm</a></td><td width=15>&nbsp;</td><td>Improved Levenberg-Marquardt optimizer</td></tr>
<tr align=left valign=top><td colspan=2>&nbsp;</td></tr>
<tr align=left valign=top><td colspan=3 bgcolor=#E8E8E8><b><code>Solvers</code> package</b></td></tr>
<tr align=left valign=top><td><a href='#unit_densesolver' class=toc>densesolver</a></td><td width=15>&nbsp;</td><td>Dense linear system solver</td></tr>
<tr align=left valign=top><td><a href='#unit_nleq' class=toc>nleq</a></td><td width=15>&nbsp;</td><td>Solvers for nonlinear equations</td></tr>
<tr align=left valign=top><td colspan=2>&nbsp;</td></tr>
<tr align=left valign=top><td colspan=3 bgcolor=#E8E8E8><b><code>SpecialFunctions</code> package</b></td></tr>
<tr align=left valign=top><td><a href='#unit_airyf' class=toc>airyf</a></td><td width=15>&nbsp;</td><td>Airy functions</td></tr>
<tr align=left valign=top><td><a href='#unit_bessel' class=toc>bessel</a></td><td width=15>&nbsp;</td><td>Bessel functions</td></tr>
<tr align=left valign=top><td><a href='#unit_betaf' class=toc>betaf</a></td><td width=15>&nbsp;</td><td>Beta function</td></tr>
<tr align=left valign=top><td><a href='#unit_binomialdistr' class=toc>binomialdistr</a></td><td width=15>&nbsp;</td><td>Binomial distribution</td></tr>
<tr align=left valign=top><td><a href='#unit_chebyshev' class=toc>chebyshev</a></td><td width=15>&nbsp;</td><td>Chebyshev polynomials</td></tr>
<tr align=left valign=top><td><a href='#unit_chisquaredistr' class=toc>chisquaredistr</a></td><td width=15>&nbsp;</td><td>Chi-Square distribution</td></tr>
<tr align=left valign=top><td><a href='#unit_dawson' class=toc>dawson</a></td><td width=15>&nbsp;</td><td>Dawson integral</td></tr>
<tr align=left valign=top><td><a href='#unit_elliptic' class=toc>elliptic</a></td><td width=15>&nbsp;</td><td>Elliptic integrals</td></tr>
<tr align=left valign=top><td><a href='#unit_expintegrals' class=toc>expintegrals</a></td><td width=15>&nbsp;</td><td>Exponential integrals</td></tr>
<tr align=left valign=top><td><a href='#unit_fdistr' class=toc>fdistr</a></td><td width=15>&nbsp;</td><td>F-distribution</td></tr>
<tr align=left valign=top><td><a href='#unit_fresnel' class=toc>fresnel</a></td><td width=15>&nbsp;</td><td>Fresnel integrals</td></tr>
<tr align=left valign=top><td><a href='#unit_gammafunc' class=toc>gammafunc</a></td><td width=15>&nbsp;</td><td>Gamma function</td></tr>
<tr align=left valign=top><td><a href='#unit_hermite' class=toc>hermite</a></td><td width=15>&nbsp;</td><td>Hermite polynomials</td></tr>
<tr align=left valign=top><td><a href='#unit_ibetaf' class=toc>ibetaf</a></td><td width=15>&nbsp;</td><td>Incomplete beta function</td></tr>
<tr align=left valign=top><td><a href='#unit_igammaf' class=toc>igammaf</a></td><td width=15>&nbsp;</td><td>Incomplete gamma function</td></tr>
<tr align=left valign=top><td><a href='#unit_jacobianelliptic' class=toc>jacobianelliptic</a></td><td width=15>&nbsp;</td><td>Jacobian elliptic functions</td></tr>
<tr align=left valign=top><td><a href='#unit_laguerre' class=toc>laguerre</a></td><td width=15>&nbsp;</td><td>Laguerre polynomials</td></tr>
<tr align=left valign=top><td><a href='#unit_legendre' class=toc>legendre</a></td><td width=15>&nbsp;</td><td>Legendre polynomials</td></tr>
<tr align=left valign=top><td><a href='#unit_normaldistr' class=toc>normaldistr</a></td><td width=15>&nbsp;</td><td>Normal distribution</td></tr>
<tr align=left valign=top><td><a href='#unit_poissondistr' class=toc>poissondistr</a></td><td width=15>&nbsp;</td><td>Poisson distribution</td></tr>
<tr align=left valign=top><td><a href='#unit_psif' class=toc>psif</a></td><td width=15>&nbsp;</td><td>Psi function</td></tr>
<tr align=left valign=top><td><a href='#unit_studenttdistr' class=toc>studenttdistr</a></td><td width=15>&nbsp;</td><td>Student's t-distribution</td></tr>
<tr align=left valign=top><td><a href='#unit_trigintegrals' class=toc>trigintegrals</a></td><td width=15>&nbsp;</td><td>Trigonometric integrals</td></tr>
<tr align=left valign=top><td colspan=2>&nbsp;</td></tr>
<tr align=left valign=top><td colspan=3 bgcolor=#E8E8E8><b><code>Statistics</code> package</b></td></tr>
<tr align=left valign=top><td><a href='#unit_basestat' class=toc>basestat</a></td><td width=15>&nbsp;</td><td>Mean, variance, covariance, correlation, etc.</td></tr>
<tr align=left valign=top><td><a href='#unit_correlationtests' class=toc>correlationtests</a></td><td width=15>&nbsp;</td><td>Hypothesis testing: correlation tests</td></tr>
<tr align=left valign=top><td><a href='#unit_jarquebera' class=toc>jarquebera</a></td><td width=15>&nbsp;</td><td>Hypothesis testing: Jarque-Bera test</td></tr>
<tr align=left valign=top><td><a href='#unit_mannwhitneyu' class=toc>mannwhitneyu</a></td><td width=15>&nbsp;</td><td>Hypothesis testing: Mann-Whitney-U test</td></tr>
<tr align=left valign=top><td><a href='#unit_stest' class=toc>stest</a></td><td width=15>&nbsp;</td><td>Hypothesis testing: sign test</td></tr>
<tr align=left valign=top><td><a href='#unit_studentttests' class=toc>studentttests</a></td><td width=15>&nbsp;</td><td>Hypothesis testing: Student's t-test</td></tr>
<tr align=left valign=top><td><a href='#unit_variancetests' class=toc>variancetests</a></td><td width=15>&nbsp;</td><td>Hypothesis testing: F-test and one-sample variance test</td></tr>
<tr align=left valign=top><td><a href='#unit_wsr' class=toc>wsr</a></td><td width=15>&nbsp;</td><td>Hypothesis testing: Wilcoxon signed rank test</td></tr>
<tr align=left valign=top><td colspan=2>&nbsp;</td></tr>
</table>
<a name=unit_ablas></a><h2 class=pageheader><code>ablas</code> module</h2>
<div class=pagecontent>
<h3 class=pageheader>Functions</h3>
<a href='#sub_cmatrixcopy' class=toc>cmatrixcopy</a><br>
<a href='#sub_cmatrixgemm' class=toc>cmatrixgemm</a><br>
<a href='#sub_cmatrixlefttrsm' class=toc>cmatrixlefttrsm</a><br>
<a href='#sub_cmatrixmv' class=toc>cmatrixmv</a><br>
<a href='#sub_cmatrixrank1' class=toc>cmatrixrank1</a><br>
<a href='#sub_cmatrixrighttrsm' class=toc>cmatrixrighttrsm</a><br>
<a href='#sub_cmatrixsyrk' class=toc>cmatrixsyrk</a><br>
<a href='#sub_cmatrixtranspose' class=toc>cmatrixtranspose</a><br>
<a href='#sub_rmatrixcopy' class=toc>rmatrixcopy</a><br>
<a href='#sub_rmatrixgemm' class=toc>rmatrixgemm</a><br>
<a href='#sub_rmatrixlefttrsm' class=toc>rmatrixlefttrsm</a><br>
<a href='#sub_rmatrixmv' class=toc>rmatrixmv</a><br>
<a href='#sub_rmatrixrank1' class=toc>rmatrixrank1</a><br>
<a href='#sub_rmatrixrighttrsm' class=toc>rmatrixrighttrsm</a><br>
<a href='#sub_rmatrixsyrk' class=toc>rmatrixsyrk</a><br>
<a href='#sub_rmatrixtranspose' class=toc>rmatrixtranspose</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='sub_cmatrixcopy'></a><h3 class=pageheader><code>cmatrixcopy</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Copy
# 
# Input parameters:
#     M   -   number of rows
#     N   -   number of columns
#     A   -   source matrix, MxN submatrix is copied and transposed
#     IA  -   submatrix offset (row index)
#     JA  -   submatrix offset (column index)
#     B   -   destination matrix
#     IB  -   submatrix offset (row index)
#     JB  -   submatrix offset (column index)
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: b = xalglib.cmatrixcopy(m, n, a, ia, ja, b, ib, jb)

</div></pre>
<a name='sub_cmatrixgemm'></a><h3 class=pageheader><code>cmatrixgemm</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# This subroutine calculates C = alpha*op1(A)*op2(B) +beta*C where:
# * C is MxN general matrix
# * op1(A) is MxK matrix
# * op2(B) is KxN matrix
# * &quot;op&quot; may be identity transformation, transposition, conjugate transposition
# 
# Additional info:
# * cache-oblivious algorithm is used.
# * multiplication result replaces C. If Beta=0, C elements are not used in
#   calculations (not multiplied by zero - just not referenced)
# * if Alpha=0, A is not used (not multiplied by zero - just not referenced)
# * if both Beta and Alpha are zero, C is filled by zeros.
# 
# INPUT PARAMETERS
#     N       -   matrix size, N&gt;0
#     M       -   matrix size, N&gt;0
#     K       -   matrix size, K&gt;0
#     Alpha   -   coefficient
#     A       -   matrix
#     IA      -   submatrix offset
#     JA      -   submatrix offset
#     OpTypeA -   transformation type:
#                 * 0 - no transformation
#                 * 1 - transposition
#                 * 2 - conjugate transposition
#     B       -   matrix
#     IB      -   submatrix offset
#     JB      -   submatrix offset
#     OpTypeB -   transformation type:
#                 * 0 - no transformation
#                 * 1 - transposition
#                 * 2 - conjugate transposition
#     Beta    -   coefficient
#     C       -   matrix
#     IC      -   submatrix offset
#     JC      -   submatrix offset
# 
#   -- ALGLIB routine --
#      16.12.2009
#      Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: c = xalglib.cmatrixgemm(m, n, k, alpha, a, ia, ja, optypea, b, ib, jb, optypeb, beta, c, ic, jc)

</div></pre>
<a name='sub_cmatrixlefttrsm'></a><h3 class=pageheader><code>cmatrixlefttrsm</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# This subroutine calculates op(A^-1)*X where:
# * X is MxN general matrix
# * A is MxM upper/lower triangular/unitriangular matrix
# * &quot;op&quot; may be identity transformation, transposition, conjugate transposition
# 
# Multiplication result replaces X.
# Cache-oblivious algorithm is used.
# 
# INPUT PARAMETERS
#     N   -   matrix size, N&gt;=0
#     M   -   matrix size, N&gt;=0
#     A       -   matrix, actial matrix is stored in A[I1:I1+M-1,J1:J1+M-1]
#     I1      -   submatrix offset
#     J1      -   submatrix offset
#     IsUpper -   whether matrix is upper triangular
#     IsUnit  -   whether matrix is unitriangular
#     OpType  -   transformation type:
#                 * 0 - no transformation
#                 * 1 - transposition
#                 * 2 - conjugate transposition
#     C   -   matrix, actial matrix is stored in C[I2:I2+M-1,J2:J2+N-1]
#     I2  -   submatrix offset
#     J2  -   submatrix offset
# 
#   -- ALGLIB routine --
#      15.12.2009
#      Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: x = xalglib.cmatrixlefttrsm(m, n, a, i1, j1, isupper, isunit, optype, x, i2, j2)

</div></pre>
<a name='sub_cmatrixmv'></a><h3 class=pageheader><code>cmatrixmv</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Matrix-vector product: y := op(A)*x
# 
# INPUT PARAMETERS:
#     M   -   number of rows of op(A)
#             M&gt;=0
#     N   -   number of columns of op(A)
#             N&gt;=0
#     A   -   target matrix
#     IA  -   submatrix offset (row index)
#     JA  -   submatrix offset (column index)
#     OpA -   operation type:
#             * OpA=0     =&gt;  op(A) = A
#             * OpA=1     =&gt;  op(A) = A^T
#             * OpA=2     =&gt;  op(A) = A^H
#     X   -   input vector
#     IX  -   subvector offset
#     IY  -   subvector offset
# 
# OUTPUT PARAMETERS:
#     Y   -   vector which stores result
# 
# if M=0, then subroutine does nothing.
# if N=0, Y is filled by zeros.
# 
# 
#   -- ALGLIB routine --
# 
#      28.01.2010
#      Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: y = xalglib.cmatrixmv(m, n, a, ia, ja, opa, x, ix, y, iy)

</div></pre>
<a name='sub_cmatrixrank1'></a><h3 class=pageheader><code>cmatrixrank1</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Rank-1 correction: A := A + u*v'
# 
# INPUT PARAMETERS:
#     M   -   number of rows
#     N   -   number of columns
#     A   -   target matrix, MxN submatrix is updated
#     IA  -   submatrix offset (row index)
#     JA  -   submatrix offset (column index)
#     U   -   vector #1
#     IU  -   subvector offset
#     V   -   vector #2
#     IV  -   subvector offset
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: a, u, v = xalglib.cmatrixrank1(m, n, a, ia, ja, u, iu, v, iv)

</div></pre>
<a name='sub_cmatrixrighttrsm'></a><h3 class=pageheader><code>cmatrixrighttrsm</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# This subroutine calculates X*op(A^-1) where:
# * X is MxN general matrix
# * A is NxN upper/lower triangular/unitriangular matrix
# * &quot;op&quot; may be identity transformation, transposition, conjugate transposition
# 
# Multiplication result replaces X.
# Cache-oblivious algorithm is used.
# 
# INPUT PARAMETERS
#     N   -   matrix size, N&gt;=0
#     M   -   matrix size, N&gt;=0
#     A       -   matrix, actial matrix is stored in A[I1:I1+N-1,J1:J1+N-1]
#     I1      -   submatrix offset
#     J1      -   submatrix offset
#     IsUpper -   whether matrix is upper triangular
#     IsUnit  -   whether matrix is unitriangular
#     OpType  -   transformation type:
#                 * 0 - no transformation
#                 * 1 - transposition
#                 * 2 - conjugate transposition
#     C   -   matrix, actial matrix is stored in C[I2:I2+M-1,J2:J2+N-1]
#     I2  -   submatrix offset
#     J2  -   submatrix offset
# 
#   -- ALGLIB routine --
#      15.12.2009
#      Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: x = xalglib.cmatrixrighttrsm(m, n, a, i1, j1, isupper, isunit, optype, x, i2, j2)

</div></pre>
<a name='sub_cmatrixsyrk'></a><h3 class=pageheader><code>cmatrixsyrk</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# This subroutine calculates  C=alpha*A*A^H+beta*C  or  C=alpha*A^H*A+beta*C
# where:
# * C is NxN Hermitian matrix given by its upper/lower triangle
# * A is NxK matrix when A*A^H is calculated, KxN matrix otherwise
# 
# Additional info:
# * cache-oblivious algorithm is used.
# * multiplication result replaces C. If Beta=0, C elements are not used in
#   calculations (not multiplied by zero - just not referenced)
# * if Alpha=0, A is not used (not multiplied by zero - just not referenced)
# * if both Beta and Alpha are zero, C is filled by zeros.
# 
# INPUT PARAMETERS
#     N       -   matrix size, N&gt;=0
#     K       -   matrix size, K&gt;=0
#     Alpha   -   coefficient
#     A       -   matrix
#     IA      -   submatrix offset
#     JA      -   submatrix offset
#     OpTypeA -   multiplication type:
#                 * 0 - A*A^H is calculated
#                 * 2 - A^H*A is calculated
#     Beta    -   coefficient
#     C       -   matrix
#     IC      -   submatrix offset
#     JC      -   submatrix offset
#     IsUpper -   whether C is upper triangular or lower triangular
# 
#   -- ALGLIB routine --
#      16.12.2009
#      Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: c = xalglib.cmatrixsyrk(n, k, alpha, a, ia, ja, optypea, beta, c, ic, jc, isupper)

</div></pre>
<a name='sub_cmatrixtranspose'></a><h3 class=pageheader><code>cmatrixtranspose</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Cache-oblivous complex &quot;copy-and-transpose&quot;
# 
# Input parameters:
#     M   -   number of rows
#     N   -   number of columns
#     A   -   source matrix, MxN submatrix is copied and transposed
#     IA  -   submatrix offset (row index)
#     JA  -   submatrix offset (column index)
#     A   -   destination matrix
#     IB  -   submatrix offset (row index)
#     JB  -   submatrix offset (column index)
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: b = xalglib.cmatrixtranspose(m, n, a, ia, ja, b, ib, jb)

</div></pre>
<a name='sub_rmatrixcopy'></a><h3 class=pageheader><code>rmatrixcopy</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Copy
# 
# Input parameters:
#     M   -   number of rows
#     N   -   number of columns
#     A   -   source matrix, MxN submatrix is copied and transposed
#     IA  -   submatrix offset (row index)
#     JA  -   submatrix offset (column index)
#     B   -   destination matrix
#     IB  -   submatrix offset (row index)
#     JB  -   submatrix offset (column index)
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: b = xalglib.rmatrixcopy(m, n, a, ia, ja, b, ib, jb)

</div></pre>
<a name='sub_rmatrixgemm'></a><h3 class=pageheader><code>rmatrixgemm</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Same as CMatrixGEMM, but for real numbers.
# OpType may be only 0 or 1.
# 
#   -- ALGLIB routine --
#      16.12.2009
#      Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: c = xalglib.rmatrixgemm(m, n, k, alpha, a, ia, ja, optypea, b, ib, jb, optypeb, beta, c, ic, jc)

</div></pre>
<a name='sub_rmatrixlefttrsm'></a><h3 class=pageheader><code>rmatrixlefttrsm</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Same as CMatrixLeftTRSM, but for real matrices
# 
# OpType may be only 0 or 1.
# 
#   -- ALGLIB routine --
#      15.12.2009
#      Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: x = xalglib.rmatrixlefttrsm(m, n, a, i1, j1, isupper, isunit, optype, x, i2, j2)

</div></pre>
<a name='sub_rmatrixmv'></a><h3 class=pageheader><code>rmatrixmv</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Matrix-vector product: y := op(A)*x
# 
# INPUT PARAMETERS:
#     M   -   number of rows of op(A)
#     N   -   number of columns of op(A)
#     A   -   target matrix
#     IA  -   submatrix offset (row index)
#     JA  -   submatrix offset (column index)
#     OpA -   operation type:
#             * OpA=0     =&gt;  op(A) = A
#             * OpA=1     =&gt;  op(A) = A^T
#     X   -   input vector
#     IX  -   subvector offset
#     IY  -   subvector offset
# 
# OUTPUT PARAMETERS:
#     Y   -   vector which stores result
# 
# if M=0, then subroutine does nothing.
# if N=0, Y is filled by zeros.
# 
# 
#   -- ALGLIB routine --
# 
#      28.01.2010
#      Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: y = xalglib.rmatrixmv(m, n, a, ia, ja, opa, x, ix, y, iy)

</div></pre>
<a name='sub_rmatrixrank1'></a><h3 class=pageheader><code>rmatrixrank1</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Rank-1 correction: A := A + u*v'
# 
# INPUT PARAMETERS:
#     M   -   number of rows
#     N   -   number of columns
#     A   -   target matrix, MxN submatrix is updated
#     IA  -   submatrix offset (row index)
#     JA  -   submatrix offset (column index)
#     U   -   vector #1
#     IU  -   subvector offset
#     V   -   vector #2
#     IV  -   subvector offset
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: a, u, v = xalglib.rmatrixrank1(m, n, a, ia, ja, u, iu, v, iv)

</div></pre>
<a name='sub_rmatrixrighttrsm'></a><h3 class=pageheader><code>rmatrixrighttrsm</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Same as CMatrixRightTRSM, but for real matrices
# 
# OpType may be only 0 or 1.
# 
#   -- ALGLIB routine --
#      15.12.2009
#      Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: x = xalglib.rmatrixrighttrsm(m, n, a, i1, j1, isupper, isunit, optype, x, i2, j2)

</div></pre>
<a name='sub_rmatrixsyrk'></a><h3 class=pageheader><code>rmatrixsyrk</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Same as CMatrixSYRK, but for real matrices
# 
# OpType may be only 0 or 1.
# 
#   -- ALGLIB routine --
#      16.12.2009
#      Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: c = xalglib.rmatrixsyrk(n, k, alpha, a, ia, ja, optypea, beta, c, ic, jc, isupper)

</div></pre>
<a name='sub_rmatrixtranspose'></a><h3 class=pageheader><code>rmatrixtranspose</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Cache-oblivous real &quot;copy-and-transpose&quot;
# 
# Input parameters:
#     M   -   number of rows
#     N   -   number of columns
#     A   -   source matrix, MxN submatrix is copied and transposed
#     IA  -   submatrix offset (row index)
#     JA  -   submatrix offset (column index)
#     A   -   destination matrix
#     IB  -   submatrix offset (row index)
#     JB  -   submatrix offset (column index)
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: b = xalglib.rmatrixtranspose(m, n, a, ia, ja, b, ib, jb)

</div></pre>
<a name=unit_airyf></a><h2 class=pageheader><code>airyf</code> module</h2>
<div class=pagecontent>
<h3 class=pageheader>Functions</h3>
<a href='#sub_airy' class=toc>airy</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='sub_airy'></a><h3 class=pageheader><code>airy</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Airy function
# 
# Solution of the differential equation
# 
# y&quot;(x) = xy.
# 
# The function returns the two independent solutions Ai, Bi
# and their first derivatives Ai'(x), Bi'(x).
# 
# Evaluation is by power series summation for small x,
# by rational minimax approximations for large x.
# 
# 
# 
# ACCURACY:
# Error criterion is absolute when function &lt;= 1, relative
# when function &gt; 1, except * denotes relative error criterion.
# For large negative x, the absolute error increases as x^1.5.
# For large positive x, the relative error increases as x^1.5.
# 
# Arithmetic  domain   function  # trials      peak         rms
# IEEE        -10, 0     Ai        10000       1.6e-15     2.7e-16
# IEEE          0, 10    Ai        10000       2.3e-14*    1.8e-15*
# IEEE        -10, 0     Ai'       10000       4.6e-15     7.6e-16
# IEEE          0, 10    Ai'       10000       1.8e-14*    1.5e-15*
# IEEE        -10, 10    Bi        30000       4.2e-15     5.3e-16
# IEEE        -10, 10    Bi'       30000       4.9e-15     7.3e-16
# 
# Cephes Math Library Release 2.8:  June, 2000
# Copyright 1984, 1987, 1989, 2000 by Stephen L. Moshier
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: ai, aip, bi, bip = xalglib.airy(x)

</div></pre>
<a name=unit_autogk></a><h2 class=pageheader><code>autogk</code> module</h2>
<div class=pagecontent>
<h3 class=pageheader>Classes</h3>
<a href='#struct_autogkreport' class=toc>autogkreport</a><br>
<a href='#struct_autogkstate' class=toc>autogkstate</a><br>
<h3 class=pageheader>Functions</h3>
<a href='#sub_autogkintegrate' class=toc>autogkintegrate</a><br>
<a href='#sub_autogkresults' class=toc>autogkresults</a><br>
<a href='#sub_autogksingular' class=toc>autogksingular</a><br>
<a href='#sub_autogksmooth' class=toc>autogksmooth</a><br>
<a href='#sub_autogksmoothw' class=toc>autogksmoothw</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
<tr align=left valign=top><td><a href='#example_autogk_d1' class=toc>autogk_d1</a></td><td width=15>&nbsp;</td><td>Integrating f=exp(x) by adaptive integrator</td></tr>
</table></div>
<a name='struct_autogkreport'></a><h3 class=pageheader><code>autogkreport</code> class</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Integration report:
# * TerminationType = completetion code:
#     * -5    non-convergence of Gauss-Kronrod nodes
#             calculation subroutine.
#     * -1    incorrect parameters were specified
#     *  1    OK
# * Rep.NFEV countains number of function calculations
# * Rep.NIntervals contains number of intervals [a,b]
#   was partitioned into.
#

</div><div style='margin-top: 0; margin-bottom: 0;'><span style='font-weight: bold; color: green;'>class</span> autogkreport(object):
    ...

</div></pre>
<a name='struct_autogkstate'></a><h3 class=pageheader><code>autogkstate</code> class</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# This structure stores state of the integration algorithm.
# 
# Although this class has public fields,  they are not intended for external
# use. You should use ALGLIB functions to work with this class:
# * autogksmooth()/AutoGKSmoothW()/... to create objects
# * autogkintegrate() to begin integration
# * autogkresults() to get results
#

</div><div style='margin-top: 0; margin-bottom: 0;'><span style='font-weight: bold; color: green;'>class</span> autogkstate(object):
    ...

</div></pre>
<a name='sub_autogkintegrate'></a><h3 class=pageheader><code>autogkintegrate</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# This function is used to launcn iterations of ODE solver
# 
# It accepts following parameters:
#     diff    -   callback which calculates dy/dx for given y and x
#     obj     -   optional object which is passed to diff; can be NULL
# 
# 
#   -- ALGLIB --
#      Copyright 07.05.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: xalglib.autogkintegrate(state, func, param = None)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_autogk_d1' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_autogkresults'></a><h3 class=pageheader><code>autogkresults</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Adaptive integration results
# 
# Called after AutoGKIteration returned False.
# 
# Input parameters:
#     State   -   algorithm state (used by AutoGKIteration).
# 
# Output parameters:
#     V       -   integral(f(x)dx,a,b)
#     Rep     -   optimization report (see AutoGKReport description)
# 
#   -- ALGLIB --
#      Copyright 14.11.2007 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: v, rep = xalglib.autogkresults(state)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_autogk_d1' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_autogksingular'></a><h3 class=pageheader><code>autogksingular</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Integration on a finite interval [A,B].
# Integrand have integrable singularities at A/B.
# 
# F(X) must diverge as &quot;(x-A)^alpha&quot; at A, as &quot;(B-x)^beta&quot; at B,  with known
# alpha/beta (alpha&gt;-1, beta&gt;-1).  If alpha/beta  are  not known,  estimates
# from below can be used (but these estimates should be greater than -1 too).
# 
# One  of  alpha/beta variables (or even both alpha/beta) may be equal to 0,
# which means than function F(x) is non-singular at A/B. Anyway (singular at
# bounds or not), function F(x) is supposed to be continuous on (A,B).
# 
# Fast-convergent algorithm based on a Gauss-Kronrod formula is used. Result
# is calculated with accuracy close to the machine precision.
# 
# INPUT PARAMETERS:
#     A, B    -   interval boundaries (A&lt;B, A=B or A&gt;B)
#     Alpha   -   power-law coefficient of the F(x) at A,
#                 Alpha&gt;-1
#     Beta    -   power-law coefficient of the F(x) at B,
#                 Beta&gt;-1
# 
# OUTPUT PARAMETERS
#     State   -   structure which stores algorithm state
# 
# SEE ALSO
#     AutoGKSmooth, AutoGKSmoothW, AutoGKResults.
# 
# 
#   -- ALGLIB --
#      Copyright 06.05.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: state = xalglib.autogksingular(a, b, alpha, beta)

</div></pre>
<a name='sub_autogksmooth'></a><h3 class=pageheader><code>autogksmooth</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Integration of a smooth function F(x) on a finite interval [a,b].
# 
# Fast-convergent algorithm based on a Gauss-Kronrod formula is used. Result
# is calculated with accuracy close to the machine precision.
# 
# Algorithm works well only with smooth integrands.  It  may  be  used  with
# continuous non-smooth integrands, but with  less  performance.
# 
# It should never be used with integrands which have integrable singularities
# at lower or upper limits - algorithm may crash. Use AutoGKSingular in such
# cases.
# 
# INPUT PARAMETERS:
#     A, B    -   interval boundaries (A&lt;B, A=B or A&gt;B)
# 
# OUTPUT PARAMETERS
#     State   -   structure which stores algorithm state
# 
# SEE ALSO
#     AutoGKSmoothW, AutoGKSingular, AutoGKResults.
# 
# 
#   -- ALGLIB --
#      Copyright 06.05.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: state = xalglib.autogksmooth(a, b)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_autogk_d1' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_autogksmoothw'></a><h3 class=pageheader><code>autogksmoothw</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Integration of a smooth function F(x) on a finite interval [a,b].
# 
# This subroutine is same as AutoGKSmooth(), but it guarantees that interval
# [a,b] is partitioned into subintervals which have width at most XWidth.
# 
# Subroutine  can  be  used  when  integrating nearly-constant function with
# narrow &quot;bumps&quot; (about XWidth wide). If &quot;bumps&quot; are too narrow, AutoGKSmooth
# subroutine can overlook them.
# 
# INPUT PARAMETERS:
#     A, B    -   interval boundaries (A&lt;B, A=B or A&gt;B)
# 
# OUTPUT PARAMETERS
#     State   -   structure which stores algorithm state
# 
# SEE ALSO
#     AutoGKSmooth, AutoGKSingular, AutoGKResults.
# 
# 
#   -- ALGLIB --
#      Copyright 06.05.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: state = xalglib.autogksmoothw(a, b, xwidth)

</div></pre>
<a name='example_autogk_d1'></a><h3 class=pageheader>autogk_d1 example</h3>
<pre class=source>
import xalglib

<b>def</b> int_function_1_func(x, xminusa, bminusx, param):
    <font color=darkcyan>#</font>
    <font color=darkcyan># this callback calculates f(x)=exp(x)</font>
    <font color=darkcyan>#</font>
    <b>return</b> math.exp(x)

<font color=darkcyan>#</font>
<font color=darkcyan># This example demonstrates integration of f=exp(x) on [0,1]:</font>
<font color=darkcyan># * first, autogkstate is initialized</font>
<font color=darkcyan># * then we call integration function</font>
<font color=darkcyan># * and finally we obtain results with autogkresults() call</font>
<font color=darkcyan>#</font>
a = 0
b = 1

s = xalglib.autogksmooth(a, b)
xalglib.autogkintegrate(s, int_function_1_func);
v, rep = xalglib.autogkresults(s)

print(v) <font color=darkcyan># expected 1.7182</font>


</pre><a name=unit_basestat></a><h2 class=pageheader><code>basestat</code> module</h2>
<div class=pagecontent>
<h3 class=pageheader>Functions</h3>
<a href='#sub_cov2' class=toc>cov2</a><br>
<a href='#sub_covm' class=toc>covm</a><br>
<a href='#sub_covm2' class=toc>covm2</a><br>
<a href='#sub_pearsoncorr2' class=toc>pearsoncorr2</a><br>
<a href='#sub_pearsoncorrelation' class=toc>pearsoncorrelation</a><br>
<a href='#sub_pearsoncorrm' class=toc>pearsoncorrm</a><br>
<a href='#sub_pearsoncorrm2' class=toc>pearsoncorrm2</a><br>
<a href='#sub_sampleadev' class=toc>sampleadev</a><br>
<a href='#sub_samplemedian' class=toc>samplemedian</a><br>
<a href='#sub_samplemoments' class=toc>samplemoments</a><br>
<a href='#sub_samplepercentile' class=toc>samplepercentile</a><br>
<a href='#sub_spearmancorr2' class=toc>spearmancorr2</a><br>
<a href='#sub_spearmancorrm' class=toc>spearmancorrm</a><br>
<a href='#sub_spearmancorrm2' class=toc>spearmancorrm2</a><br>
<a href='#sub_spearmanrankcorrelation' class=toc>spearmanrankcorrelation</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
<tr align=left valign=top><td><a href='#example_basestat_d_base' class=toc>basestat_d_base</a></td><td width=15>&nbsp;</td><td>Basic functionality (moments, adev, median, percentile)</td></tr>
<tr align=left valign=top><td><a href='#example_basestat_d_c2' class=toc>basestat_d_c2</a></td><td width=15>&nbsp;</td><td>Correlation (covariance) between two random variables</td></tr>
<tr align=left valign=top><td><a href='#example_basestat_d_cm' class=toc>basestat_d_cm</a></td><td width=15>&nbsp;</td><td>Correlation (covariance) between components of random vector</td></tr>
<tr align=left valign=top><td><a href='#example_basestat_d_cm2' class=toc>basestat_d_cm2</a></td><td width=15>&nbsp;</td><td>Correlation (covariance) between two random vectors</td></tr>
</table></div>
<a name='sub_cov2'></a><h3 class=pageheader><code>cov2</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# 2-sample covariance
# 
# Input parameters:
#     X       -   sample 1 (array indexes: [0..N-1])
#     Y       -   sample 2 (array indexes: [0..N-1])
#     N       -   N&gt;=0, sample size:
#                 * if given, only N leading elements of X/Y are processed
#                 * if not given, automatically determined from input sizes
# 
# Result:
#     covariance (zero for N=0 or N=1)
# 
#   -- ALGLIB --
#      Copyright 28.10.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.cov2(x, y, n)
SYNTAX: result = xalglib.cov2(x, y)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_basestat_d_c2' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_covm'></a><h3 class=pageheader><code>covm</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Covariance matrix
# 
# INPUT PARAMETERS:
#     X   -   array[N,M], sample matrix:
#             * J-th column corresponds to J-th variable
#             * I-th row corresponds to I-th observation
#     N   -   N&gt;=0, number of observations:
#             * if given, only leading N rows of X are used
#             * if not given, automatically determined from input size
#     M   -   M&gt;0, number of variables:
#             * if given, only leading M columns of X are used
#             * if not given, automatically determined from input size
# 
# OUTPUT PARAMETERS:
#     C   -   array[M,M], covariance matrix (zero if N=0 or N=1)
# 
#   -- ALGLIB --
#      Copyright 28.10.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: c = xalglib.covm(x, n, m)
SYNTAX: c = xalglib.covm(x)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_basestat_d_cm' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_covm2'></a><h3 class=pageheader><code>covm2</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Cross-covariance matrix
# 
# INPUT PARAMETERS:
#     X   -   array[N,M1], sample matrix:
#             * J-th column corresponds to J-th variable
#             * I-th row corresponds to I-th observation
#     Y   -   array[N,M2], sample matrix:
#             * J-th column corresponds to J-th variable
#             * I-th row corresponds to I-th observation
#     N   -   N&gt;=0, number of observations:
#             * if given, only leading N rows of X/Y are used
#             * if not given, automatically determined from input sizes
#     M1  -   M1&gt;0, number of variables in X:
#             * if given, only leading M1 columns of X are used
#             * if not given, automatically determined from input size
#     M2  -   M2&gt;0, number of variables in Y:
#             * if given, only leading M1 columns of X are used
#             * if not given, automatically determined from input size
# 
# OUTPUT PARAMETERS:
#     C   -   array[M1,M2], cross-covariance matrix (zero if N=0 or N=1)
# 
#   -- ALGLIB --
#      Copyright 28.10.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: c = xalglib.covm2(x, y, n, m1, m2)
SYNTAX: c = xalglib.covm2(x, y)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_basestat_d_cm2' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_pearsoncorr2'></a><h3 class=pageheader><code>pearsoncorr2</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Pearson product-moment correlation coefficient
# 
# Input parameters:
#     X       -   sample 1 (array indexes: [0..N-1])
#     Y       -   sample 2 (array indexes: [0..N-1])
#     N       -   N&gt;=0, sample size:
#                 * if given, only N leading elements of X/Y are processed
#                 * if not given, automatically determined from input sizes
# 
# Result:
#     Pearson product-moment correlation coefficient
#     (zero for N=0 or N=1)
# 
#   -- ALGLIB --
#      Copyright 28.10.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.pearsoncorr2(x, y, n)
SYNTAX: result = xalglib.pearsoncorr2(x, y)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_basestat_d_c2' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_pearsoncorrelation'></a><h3 class=pageheader><code>pearsoncorrelation</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Obsolete function, we recommend to use PearsonCorr2().
# 
#   -- ALGLIB --
#      Copyright 09.04.2007 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.pearsoncorrelation(x, y, n)

</div></pre>
<a name='sub_pearsoncorrm'></a><h3 class=pageheader><code>pearsoncorrm</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Pearson product-moment correlation matrix
# 
# INPUT PARAMETERS:
#     X   -   array[N,M], sample matrix:
#             * J-th column corresponds to J-th variable
#             * I-th row corresponds to I-th observation
#     N   -   N&gt;=0, number of observations:
#             * if given, only leading N rows of X are used
#             * if not given, automatically determined from input size
#     M   -   M&gt;0, number of variables:
#             * if given, only leading M columns of X are used
#             * if not given, automatically determined from input size
# 
# OUTPUT PARAMETERS:
#     C   -   array[M,M], correlation matrix (zero if N=0 or N=1)
# 
#   -- ALGLIB --
#      Copyright 28.10.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: c = xalglib.pearsoncorrm(x, n, m)
SYNTAX: c = xalglib.pearsoncorrm(x)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_basestat_d_cm' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_pearsoncorrm2'></a><h3 class=pageheader><code>pearsoncorrm2</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Pearson product-moment cross-correlation matrix
# 
# INPUT PARAMETERS:
#     X   -   array[N,M1], sample matrix:
#             * J-th column corresponds to J-th variable
#             * I-th row corresponds to I-th observation
#     Y   -   array[N,M2], sample matrix:
#             * J-th column corresponds to J-th variable
#             * I-th row corresponds to I-th observation
#     N   -   N&gt;=0, number of observations:
#             * if given, only leading N rows of X/Y are used
#             * if not given, automatically determined from input sizes
#     M1  -   M1&gt;0, number of variables in X:
#             * if given, only leading M1 columns of X are used
#             * if not given, automatically determined from input size
#     M2  -   M2&gt;0, number of variables in Y:
#             * if given, only leading M1 columns of X are used
#             * if not given, automatically determined from input size
# 
# OUTPUT PARAMETERS:
#     C   -   array[M1,M2], cross-correlation matrix (zero if N=0 or N=1)
# 
#   -- ALGLIB --
#      Copyright 28.10.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: c = xalglib.pearsoncorrm2(x, y, n, m1, m2)
SYNTAX: c = xalglib.pearsoncorrm2(x, y)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_basestat_d_cm2' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_sampleadev'></a><h3 class=pageheader><code>sampleadev</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# ADev
# 
# Input parameters:
#     X   -   sample
#     N   -   N&gt;=0, sample size:
#             * if given, only leading N elements of X are processed
#             * if not given, automatically determined from size of X
# 
# Output parameters:
#     ADev-   ADev
# 
#   -- ALGLIB --
#      Copyright 06.09.2006 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: adev = xalglib.sampleadev(x, n)
SYNTAX: adev = xalglib.sampleadev(x)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_basestat_d_base' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_samplemedian'></a><h3 class=pageheader><code>samplemedian</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Median calculation.
# 
# Input parameters:
#     X   -   sample (array indexes: [0..N-1])
#     N   -   N&gt;=0, sample size:
#             * if given, only leading N elements of X are processed
#             * if not given, automatically determined from size of X
# 
# Output parameters:
#     Median
# 
#   -- ALGLIB --
#      Copyright 06.09.2006 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: median = xalglib.samplemedian(x, n)
SYNTAX: median = xalglib.samplemedian(x)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_basestat_d_base' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_samplemoments'></a><h3 class=pageheader><code>samplemoments</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Calculation of the distribution moments: mean, variance, skewness, kurtosis.
# 
# INPUT PARAMETERS:
#     X       -   sample
#     N       -   N&gt;=0, sample size:
#                 * if given, only leading N elements of X are processed
#                 * if not given, automatically determined from size of X
# 
# OUTPUT PARAMETERS
#     Mean    -   mean.
#     Variance-   variance.
#     Skewness-   skewness (if variance&lt;&gt;0; zero otherwise).
#     Kurtosis-   kurtosis (if variance&lt;&gt;0; zero otherwise).
# 
# 
#   -- ALGLIB --
#      Copyright 06.09.2006 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: mean, variance, skewness, kurtosis = xalglib.samplemoments(x, n)
SYNTAX: mean, variance, skewness, kurtosis = xalglib.samplemoments(x)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_basestat_d_base' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_samplepercentile'></a><h3 class=pageheader><code>samplepercentile</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Percentile calculation.
# 
# Input parameters:
#     X   -   sample (array indexes: [0..N-1])
#     N   -   N&gt;=0, sample size:
#             * if given, only leading N elements of X are processed
#             * if not given, automatically determined from size of X
#     P   -   percentile (0&lt;=P&lt;=1)
# 
# Output parameters:
#     V   -   percentile
# 
#   -- ALGLIB --
#      Copyright 01.03.2008 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: v = xalglib.samplepercentile(x, n, p)
SYNTAX: v = xalglib.samplepercentile(x, p)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_basestat_d_base' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_spearmancorr2'></a><h3 class=pageheader><code>spearmancorr2</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Spearman's rank correlation coefficient
# 
# Input parameters:
#     X       -   sample 1 (array indexes: [0..N-1])
#     Y       -   sample 2 (array indexes: [0..N-1])
#     N       -   N&gt;=0, sample size:
#                 * if given, only N leading elements of X/Y are processed
#                 * if not given, automatically determined from input sizes
# 
# Result:
#     Spearman's rank correlation coefficient
#     (zero for N=0 or N=1)
# 
#   -- ALGLIB --
#      Copyright 09.04.2007 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.spearmancorr2(x, y, n)
SYNTAX: result = xalglib.spearmancorr2(x, y)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_basestat_d_c2' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_spearmancorrm'></a><h3 class=pageheader><code>spearmancorrm</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Spearman's rank correlation matrix
# 
# INPUT PARAMETERS:
#     X   -   array[N,M], sample matrix:
#             * J-th column corresponds to J-th variable
#             * I-th row corresponds to I-th observation
#     N   -   N&gt;=0, number of observations:
#             * if given, only leading N rows of X are used
#             * if not given, automatically determined from input size
#     M   -   M&gt;0, number of variables:
#             * if given, only leading M columns of X are used
#             * if not given, automatically determined from input size
# 
# OUTPUT PARAMETERS:
#     C   -   array[M,M], correlation matrix (zero if N=0 or N=1)
# 
#   -- ALGLIB --
#      Copyright 28.10.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: c = xalglib.spearmancorrm(x, n, m)
SYNTAX: c = xalglib.spearmancorrm(x)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_basestat_d_cm' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_spearmancorrm2'></a><h3 class=pageheader><code>spearmancorrm2</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Spearman's rank cross-correlation matrix
# 
# INPUT PARAMETERS:
#     X   -   array[N,M1], sample matrix:
#             * J-th column corresponds to J-th variable
#             * I-th row corresponds to I-th observation
#     Y   -   array[N,M2], sample matrix:
#             * J-th column corresponds to J-th variable
#             * I-th row corresponds to I-th observation
#     N   -   N&gt;=0, number of observations:
#             * if given, only leading N rows of X/Y are used
#             * if not given, automatically determined from input sizes
#     M1  -   M1&gt;0, number of variables in X:
#             * if given, only leading M1 columns of X are used
#             * if not given, automatically determined from input size
#     M2  -   M2&gt;0, number of variables in Y:
#             * if given, only leading M1 columns of X are used
#             * if not given, automatically determined from input size
# 
# OUTPUT PARAMETERS:
#     C   -   array[M1,M2], cross-correlation matrix (zero if N=0 or N=1)
# 
#   -- ALGLIB --
#      Copyright 28.10.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: c = xalglib.spearmancorrm2(x, y, n, m1, m2)
SYNTAX: c = xalglib.spearmancorrm2(x, y)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_basestat_d_cm2' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_spearmanrankcorrelation'></a><h3 class=pageheader><code>spearmanrankcorrelation</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Obsolete function, we recommend to use SpearmanCorr2().
# 
#     -- ALGLIB --
#     Copyright 09.04.2007 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.spearmanrankcorrelation(x, y, n)

</div></pre>
<a name='example_basestat_d_base'></a><h3 class=pageheader>basestat_d_base example</h3>
<pre class=source>
import xalglib



x = [0,1,4,9,16,25,36,49,64,81]

<font color=darkcyan>#</font>
<font color=darkcyan># Here we demonstrate calculation of sample moments</font>
<font color=darkcyan># (mean, variance, skewness, kurtosis)</font>
<font color=darkcyan>#</font>
mean, variance, skewness, kurtosis = xalglib.samplemoments(x)
print(mean) <font color=darkcyan># expected 28.5</font>
print(variance) <font color=darkcyan># expected 801.1667</font>
print(skewness) <font color=darkcyan># expected 0.5751</font>
print(kurtosis) <font color=darkcyan># expected -1.2666</font>

<font color=darkcyan>#</font>
<font color=darkcyan># Average deviation</font>
<font color=darkcyan>#</font>
adev = xalglib.sampleadev(x)
print(adev) <font color=darkcyan># expected 23.2</font>

<font color=darkcyan>#</font>
<font color=darkcyan># Median and percentile</font>
<font color=darkcyan>#</font>
v = xalglib.samplemedian(x)
print(v) <font color=darkcyan># expected 20.5</font>
p = 0.5
v = xalglib.samplepercentile(x, p)
print(v) <font color=darkcyan># expected 20.5</font>


</pre><a name='example_basestat_d_c2'></a><h3 class=pageheader>basestat_d_c2 example</h3>
<pre class=source>
import xalglib



<font color=darkcyan>#</font>
<font color=darkcyan># We have two samples - x and y, and want to measure dependency between them</font>
<font color=darkcyan>#</font>
x = [0,1,4,9,16,25,36,49,64,81]
y = [0,1,2,3,4,5,6,7,8,9]

<font color=darkcyan>#</font>
<font color=darkcyan># Three dependency measures are calculated:</font>
<font color=darkcyan># * covariation</font>
<font color=darkcyan># * Pearson correlation</font>
<font color=darkcyan># * Spearman rank correlation</font>
<font color=darkcyan>#</font>
v = xalglib.cov2(x, y)
print(v) <font color=darkcyan># expected 82.5</font>
v = xalglib.pearsoncorr2(x, y)
print(v) <font color=darkcyan># expected 0.9627</font>
v = xalglib.spearmancorr2(x, y)
print(v) <font color=darkcyan># expected 1.000</font>


</pre><a name='example_basestat_d_cm'></a><h3 class=pageheader>basestat_d_cm example</h3>
<pre class=source>
import xalglib



<font color=darkcyan>#</font>
<font color=darkcyan># X is a sample matrix:</font>
<font color=darkcyan># * I-th row corresponds to I-th observation</font>
<font color=darkcyan># * J-th column corresponds to J-th variable</font>
<font color=darkcyan>#</font>
x = [[1,0,1],[1,1,0],[-1,1,0],[-2,-1,1],[-1,0,9]]

<font color=darkcyan>#</font>
<font color=darkcyan># Three dependency measures are calculated:</font>
<font color=darkcyan># * covariation</font>
<font color=darkcyan># * Pearson correlation</font>
<font color=darkcyan># * Spearman rank correlation</font>
<font color=darkcyan>#</font>
<font color=darkcyan># Result is stored into C, with C[i,j] equal to correlation</font>
<font color=darkcyan># (covariance) between I-th and J-th variables of X.</font>
<font color=darkcyan>#</font>
c = xalglib.covm(x)
print(c) <font color=darkcyan># expected [[1.80,0.60,-1.40],[0.60,0.70,-0.80],[-1.40,-0.80,14.70]]</font>
c = xalglib.pearsoncorrm(x)
print(c) <font color=darkcyan># expected [[1.000,0.535,-0.272],[0.535,1.000,-0.249],[-0.272,-0.249,1.000]]</font>
c = xalglib.spearmancorrm(x)
print(c) <font color=darkcyan># expected [[1.000,0.556,-0.306],[0.556,1.000,-0.750],[-0.306,-0.750,1.000]]</font>


</pre><a name='example_basestat_d_cm2'></a><h3 class=pageheader>basestat_d_cm2 example</h3>
<pre class=source>
import xalglib



<font color=darkcyan>#</font>
<font color=darkcyan># X and Y are sample matrices:</font>
<font color=darkcyan># * I-th row corresponds to I-th observation</font>
<font color=darkcyan># * J-th column corresponds to J-th variable</font>
<font color=darkcyan>#</font>
x = [[1,0,1],[1,1,0],[-1,1,0],[-2,-1,1],[-1,0,9]]
y = [[2,3],[2,1],[-1,6],[-9,9],[7,1]]

<font color=darkcyan>#</font>
<font color=darkcyan># Three dependency measures are calculated:</font>
<font color=darkcyan># * covariation</font>
<font color=darkcyan># * Pearson correlation</font>
<font color=darkcyan># * Spearman rank correlation</font>
<font color=darkcyan>#</font>
<font color=darkcyan># Result is stored into C, with C[i,j] equal to correlation</font>
<font color=darkcyan># (covariance) between I-th variable of X and J-th variable of Y.</font>
<font color=darkcyan>#</font>
c = xalglib.covm2(x, y)
print(c) <font color=darkcyan># expected [[4.100,-3.250],[2.450,-1.500],[13.450,-5.750]]</font>
c = xalglib.pearsoncorrm2(x, y)
print(c) <font color=darkcyan># expected [[0.519,-0.699],[0.497,-0.518],[0.596,-0.433]]</font>
c = xalglib.spearmancorrm2(x, y)
print(c) <font color=darkcyan># expected [[0.541,-0.649],[0.216,-0.433],[0.433,-0.135]]</font>


</pre><a name=unit_bdss></a><h2 class=pageheader><code>bdss</code> module</h2>
<div class=pagecontent>
<h3 class=pageheader>Functions</h3>
<a href='#sub_dsoptimalsplit2' class=toc>dsoptimalsplit2</a><br>
<a href='#sub_dsoptimalsplit2fast' class=toc>dsoptimalsplit2fast</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='sub_dsoptimalsplit2'></a><h3 class=pageheader><code>dsoptimalsplit2</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Optimal binary classification
# 
# Algorithms finds optimal (=with minimal cross-entropy) binary partition.
# Internal subroutine.
# 
# INPUT PARAMETERS:
#     A       -   array[0..N-1], variable
#     C       -   array[0..N-1], class numbers (0 or 1).
#     N       -   array size
# 
# OUTPUT PARAMETERS:
#     Info    -   completetion code:
#                 * -3, all values of A[] are same (partition is impossible)
#                 * -2, one of C[] is incorrect (&lt;0, &gt;1)
#                 * -1, incorrect pararemets were passed (N&lt;=0).
#                 *  1, OK
#     Threshold-  partiton boundary. Left part contains values which are
#                 strictly less than Threshold. Right part contains values
#                 which are greater than or equal to Threshold.
#     PAL, PBL-   probabilities P(0|v&lt;Threshold) and P(1|v&lt;Threshold)
#     PAR, PBR-   probabilities P(0|v&gt;=Threshold) and P(1|v&gt;=Threshold)
#     CVE     -   cross-validation estimate of cross-entropy
# 
#   -- ALGLIB --
#      Copyright 22.05.2008 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: info, threshold, pal, pbl, par, pbr, cve = xalglib.dsoptimalsplit2(a, c, n)

</div></pre>
<a name='sub_dsoptimalsplit2fast'></a><h3 class=pageheader><code>dsoptimalsplit2fast</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Optimal partition, internal subroutine. Fast version.
# 
# Accepts:
#     A       array[0..N-1]       array of attributes     array[0..N-1]
#     C       array[0..N-1]       array of class labels
#     TiesBuf array[0..N]         temporaries (ties)
#     CntBuf  array[0..2*NC-1]    temporaries (counts)
#     Alpha                       centering factor (0&lt;=alpha&lt;=1, recommended value - 0.05)
#     BufR    array[0..N-1]       temporaries
#     BufI    array[0..N-1]       temporaries
# 
# Output:
#     Info    error code (&quot;&gt;0&quot;=OK, &quot;&lt;0&quot;=bad)
#     RMS     training set RMS error
#     CVRMS   leave-one-out RMS error
# 
# Note:
#     content of all arrays is changed by subroutine;
#     it doesn't allocate temporaries.
# 
#   -- ALGLIB --
#      Copyright 11.12.2008 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: a, c, tiesbuf, cntbuf, bufr, bufi, info, threshold, rms, cvrms = xalglib.dsoptimalsplit2fast(a, c, tiesbuf, cntbuf, bufr, bufi, n, nc, alpha)

</div></pre>
<a name=unit_bdsvd></a><h2 class=pageheader><code>bdsvd</code> module</h2>
<div class=pagecontent>
<h3 class=pageheader>Functions</h3>
<a href='#sub_rmatrixbdsvd' class=toc>rmatrixbdsvd</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='sub_rmatrixbdsvd'></a><h3 class=pageheader><code>rmatrixbdsvd</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Singular value decomposition of a bidiagonal matrix (extended algorithm)
# 
# The algorithm performs the singular value decomposition  of  a  bidiagonal
# matrix B (upper or lower) representing it as B = Q*S*P^T, where Q and  P -
# orthogonal matrices, S - diagonal matrix with non-negative elements on the
# main diagonal, in descending order.
# 
# The  algorithm  finds  singular  values.  In  addition,  the algorithm can
# calculate  matrices  Q  and P (more precisely, not the matrices, but their
# product  with  given  matrices U and VT - U*Q and (P^T)*VT)).  Of  course,
# matrices U and VT can be of any type, including identity. Furthermore, the
# algorithm can calculate Q'*C (this product is calculated more  effectively
# than U*Q,  because  this calculation operates with rows instead  of matrix
# columns).
# 
# The feature of the algorithm is its ability to find  all  singular  values
# including those which are arbitrarily close to 0  with  relative  accuracy
# close to  machine precision. If the parameter IsFractionalAccuracyRequired
# is set to True, all singular values will have high relative accuracy close
# to machine precision. If the parameter is set to False, only  the  biggest
# singular value will have relative accuracy  close  to  machine  precision.
# The absolute error of other singular values is equal to the absolute error
# of the biggest singular value.
# 
# Input parameters:
#     D       -   main diagonal of matrix B.
#                 Array whose index ranges within [0..N-1].
#     E       -   superdiagonal (or subdiagonal) of matrix B.
#                 Array whose index ranges within [0..N-2].
#     N       -   size of matrix B.
#     IsUpper -   True, if the matrix is upper bidiagonal.
#     IsFractionalAccuracyRequired -
#                 accuracy to search singular values with.
#     U       -   matrix to be multiplied by Q.
#                 Array whose indexes range within [0..NRU-1, 0..N-1].
#                 The matrix can be bigger, in that case only the  submatrix
#                 [0..NRU-1, 0..N-1] will be multiplied by Q.
#     NRU     -   number of rows in matrix U.
#     C       -   matrix to be multiplied by Q'.
#                 Array whose indexes range within [0..N-1, 0..NCC-1].
#                 The matrix can be bigger, in that case only the  submatrix
#                 [0..N-1, 0..NCC-1] will be multiplied by Q'.
#     NCC     -   number of columns in matrix C.
#     VT      -   matrix to be multiplied by P^T.
#                 Array whose indexes range within [0..N-1, 0..NCVT-1].
#                 The matrix can be bigger, in that case only the  submatrix
#                 [0..N-1, 0..NCVT-1] will be multiplied by P^T.
#     NCVT    -   number of columns in matrix VT.
# 
# Output parameters:
#     D       -   singular values of matrix B in descending order.
#     U       -   if NRU&gt;0, contains matrix U*Q.
#     VT      -   if NCVT&gt;0, contains matrix (P^T)*VT.
#     C       -   if NCC&gt;0, contains matrix Q'*C.
# 
# Result:
#     True, if the algorithm has converged.
#     False, if the algorithm hasn't converged (rare case).
# 
# Additional information:
#     The type of convergence is controlled by the internal  parameter  TOL.
#     If the parameter is greater than 0, the singular values will have
#     relative accuracy TOL. If TOL&lt;0, the singular values will have
#     absolute accuracy ABS(TOL)*norm(B).
#     By default, |TOL| falls within the range of 10*Epsilon and 100*Epsilon,
#     where Epsilon is the machine precision. It is not  recommended  to  use
#     TOL less than 10*Epsilon since this will  considerably  slow  down  the
#     algorithm and may not lead to error decreasing.
# History:
#     * 31 March, 2007.
#         changed MAXITR from 6 to 12.
# 
#   -- LAPACK routine (version 3.0) --
#      Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
#      Courant Institute, Argonne National Lab, and Rice University
#      October 31, 1999.
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result, d, u, c, vt = xalglib.rmatrixbdsvd(d, e, n, isupper, isfractionalaccuracyrequired, u, nru, c, ncc, vt, ncvt)

</div></pre>
<a name=unit_bessel></a><h2 class=pageheader><code>bessel</code> module</h2>
<div class=pagecontent>
<h3 class=pageheader>Functions</h3>
<a href='#sub_besseli0' class=toc>besseli0</a><br>
<a href='#sub_besseli1' class=toc>besseli1</a><br>
<a href='#sub_besselj0' class=toc>besselj0</a><br>
<a href='#sub_besselj1' class=toc>besselj1</a><br>
<a href='#sub_besseljn' class=toc>besseljn</a><br>
<a href='#sub_besselk0' class=toc>besselk0</a><br>
<a href='#sub_besselk1' class=toc>besselk1</a><br>
<a href='#sub_besselkn' class=toc>besselkn</a><br>
<a href='#sub_bessely0' class=toc>bessely0</a><br>
<a href='#sub_bessely1' class=toc>bessely1</a><br>
<a href='#sub_besselyn' class=toc>besselyn</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='sub_besseli0'></a><h3 class=pageheader><code>besseli0</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Modified Bessel function of order zero
# 
# Returns modified Bessel function of order zero of the
# argument.
# 
# The function is defined as i0(x) = j0( ix ).
# 
# The range is partitioned into the two intervals [0,8] and
# (8, infinity).  Chebyshev polynomial expansions are employed
# in each interval.
# 
# ACCURACY:
# 
#                      Relative error:
# arithmetic   domain     # trials      peak         rms
#    IEEE      0,30        30000       5.8e-16     1.4e-16
# 
# Cephes Math Library Release 2.8:  June, 2000
# Copyright 1984, 1987, 2000 by Stephen L. Moshier
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.besseli0(x)

</div></pre>
<a name='sub_besseli1'></a><h3 class=pageheader><code>besseli1</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Modified Bessel function of order one
# 
# Returns modified Bessel function of order one of the
# argument.
# 
# The function is defined as i1(x) = -i j1( ix ).
# 
# The range is partitioned into the two intervals [0,8] and
# (8, infinity).  Chebyshev polynomial expansions are employed
# in each interval.
# 
# ACCURACY:
# 
#                      Relative error:
# arithmetic   domain     # trials      peak         rms
#    IEEE      0, 30       30000       1.9e-15     2.1e-16
# 
# Cephes Math Library Release 2.8:  June, 2000
# Copyright 1985, 1987, 2000 by Stephen L. Moshier
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.besseli1(x)

</div></pre>
<a name='sub_besselj0'></a><h3 class=pageheader><code>besselj0</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Bessel function of order zero
# 
# Returns Bessel function of order zero of the argument.
# 
# The domain is divided into the intervals [0, 5] and
# (5, infinity). In the first interval the following rational
# approximation is used:
# 
# 
#        2         2
# (w - r  ) (w - r  ) P (w) / Q (w)
#       1         2    3       8
# 
#            2
# where w = x  and the two r's are zeros of the function.
# 
# In the second interval, the Hankel asymptotic expansion
# is employed with two rational functions of degree 6/6
# and 7/7.
# 
# ACCURACY:
# 
#                      Absolute error:
# arithmetic   domain     # trials      peak         rms
#    IEEE      0, 30       60000       4.2e-16     1.1e-16
# 
# Cephes Math Library Release 2.8:  June, 2000
# Copyright 1984, 1987, 1989, 2000 by Stephen L. Moshier
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.besselj0(x)

</div></pre>
<a name='sub_besselj1'></a><h3 class=pageheader><code>besselj1</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Bessel function of order one
# 
# Returns Bessel function of order one of the argument.
# 
# The domain is divided into the intervals [0, 8] and
# (8, infinity). In the first interval a 24 term Chebyshev
# expansion is used. In the second, the asymptotic
# trigonometric representation is employed using two
# rational functions of degree 5/5.
# 
# ACCURACY:
# 
#                      Absolute error:
# arithmetic   domain      # trials      peak         rms
#    IEEE      0, 30       30000       2.6e-16     1.1e-16
# 
# Cephes Math Library Release 2.8:  June, 2000
# Copyright 1984, 1987, 1989, 2000 by Stephen L. Moshier
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.besselj1(x)

</div></pre>
<a name='sub_besseljn'></a><h3 class=pageheader><code>besseljn</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Bessel function of integer order
# 
# Returns Bessel function of order n, where n is a
# (possibly negative) integer.
# 
# The ratio of jn(x) to j0(x) is computed by backward
# recurrence.  First the ratio jn/jn-1 is found by a
# continued fraction expansion.  Then the recurrence
# relating successive orders is applied until j0 or j1 is
# reached.
# 
# If n = 0 or 1 the routine for j0 or j1 is called
# directly.
# 
# ACCURACY:
# 
#                      Absolute error:
# arithmetic   range      # trials      peak         rms
#    IEEE      0, 30        5000       4.4e-16     7.9e-17
# 
# 
# Not suitable for large n or x. Use jv() (fractional order) instead.
# 
# Cephes Math Library Release 2.8:  June, 2000
# Copyright 1984, 1987, 2000 by Stephen L. Moshier
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.besseljn(n, x)

</div></pre>
<a name='sub_besselk0'></a><h3 class=pageheader><code>besselk0</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Modified Bessel function, second kind, order zero
# 
# Returns modified Bessel function of the second kind
# of order zero of the argument.
# 
# The range is partitioned into the two intervals [0,8] and
# (8, infinity).  Chebyshev polynomial expansions are employed
# in each interval.
# 
# ACCURACY:
# 
# Tested at 2000 random points between 0 and 8.  Peak absolute
# error (relative when K0 &gt; 1) was 1.46e-14; rms, 4.26e-15.
#                      Relative error:
# arithmetic   domain     # trials      peak         rms
#    IEEE      0, 30       30000       1.2e-15     1.6e-16
# 
# Cephes Math Library Release 2.8:  June, 2000
# Copyright 1984, 1987, 2000 by Stephen L. Moshier
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.besselk0(x)

</div></pre>
<a name='sub_besselk1'></a><h3 class=pageheader><code>besselk1</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Modified Bessel function, second kind, order one
# 
# Computes the modified Bessel function of the second kind
# of order one of the argument.
# 
# The range is partitioned into the two intervals [0,2] and
# (2, infinity).  Chebyshev polynomial expansions are employed
# in each interval.
# 
# ACCURACY:
# 
#                      Relative error:
# arithmetic   domain     # trials      peak         rms
#    IEEE      0, 30       30000       1.2e-15     1.6e-16
# 
# Cephes Math Library Release 2.8:  June, 2000
# Copyright 1984, 1987, 2000 by Stephen L. Moshier
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.besselk1(x)

</div></pre>
<a name='sub_besselkn'></a><h3 class=pageheader><code>besselkn</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Modified Bessel function, second kind, integer order
# 
# Returns modified Bessel function of the second kind
# of order n of the argument.
# 
# The range is partitioned into the two intervals [0,9.55] and
# (9.55, infinity).  An ascending power series is used in the
# low range, and an asymptotic expansion in the high range.
# 
# ACCURACY:
# 
#                      Relative error:
# arithmetic   domain     # trials      peak         rms
#    IEEE      0,30        90000       1.8e-8      3.0e-10
# 
# Error is high only near the crossover point x = 9.55
# between the two expansions used.
# 
# Cephes Math Library Release 2.8:  June, 2000
# Copyright 1984, 1987, 1988, 2000 by Stephen L. Moshier
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.besselkn(nn, x)

</div></pre>
<a name='sub_bessely0'></a><h3 class=pageheader><code>bessely0</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Bessel function of the second kind, order zero
# 
# Returns Bessel function of the second kind, of order
# zero, of the argument.
# 
# The domain is divided into the intervals [0, 5] and
# (5, infinity). In the first interval a rational approximation
# R(x) is employed to compute
#   y0(x)  = R(x)  +   2 * log(x) * j0(x) / PI.
# Thus a call to j0() is required.
# 
# In the second interval, the Hankel asymptotic expansion
# is employed with two rational functions of degree 6/6
# and 7/7.
# 
# 
# 
# ACCURACY:
# 
#  Absolute error, when y0(x) &lt; 1; else relative error:
# 
# arithmetic   domain     # trials      peak         rms
#    IEEE      0, 30       30000       1.3e-15     1.6e-16
# 
# Cephes Math Library Release 2.8:  June, 2000
# Copyright 1984, 1987, 1989, 2000 by Stephen L. Moshier
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.bessely0(x)

</div></pre>
<a name='sub_bessely1'></a><h3 class=pageheader><code>bessely1</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Bessel function of second kind of order one
# 
# Returns Bessel function of the second kind of order one
# of the argument.
# 
# The domain is divided into the intervals [0, 8] and
# (8, infinity). In the first interval a 25 term Chebyshev
# expansion is used, and a call to j1() is required.
# In the second, the asymptotic trigonometric representation
# is employed using two rational functions of degree 5/5.
# 
# ACCURACY:
# 
#                      Absolute error:
# arithmetic   domain      # trials      peak         rms
#    IEEE      0, 30       30000       1.0e-15     1.3e-16
# 
# Cephes Math Library Release 2.8:  June, 2000
# Copyright 1984, 1987, 1989, 2000 by Stephen L. Moshier
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.bessely1(x)

</div></pre>
<a name='sub_besselyn'></a><h3 class=pageheader><code>besselyn</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Bessel function of second kind of integer order
# 
# Returns Bessel function of order n, where n is a
# (possibly negative) integer.
# 
# The function is evaluated by forward recurrence on
# n, starting with values computed by the routines
# y0() and y1().
# 
# If n = 0 or 1 the routine for y0 or y1 is called
# directly.
# 
# ACCURACY:
#                      Absolute error, except relative
#                      when y &gt; 1:
# arithmetic   domain     # trials      peak         rms
#    IEEE      0, 30       30000       3.4e-15     4.3e-16
# 
# Cephes Math Library Release 2.8:  June, 2000
# Copyright 1984, 1987, 2000 by Stephen L. Moshier
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.besselyn(n, x)

</div></pre>
<a name=unit_betaf></a><h2 class=pageheader><code>betaf</code> module</h2>
<div class=pagecontent>
<h3 class=pageheader>Functions</h3>
<a href='#sub_beta' class=toc>beta</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='sub_beta'></a><h3 class=pageheader><code>beta</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Beta function
# 
# 
#                   -     -
#                  | (a) | (b)
# beta( a, b )  =  -----------.
#                     -
#                    | (a+b)
# 
# For large arguments the logarithm of the function is
# evaluated using lgam(), then exponentiated.
# 
# ACCURACY:
# 
#                      Relative error:
# arithmetic   domain     # trials      peak         rms
#    IEEE       0,30       30000       8.1e-14     1.1e-14
# 
# Cephes Math Library Release 2.0:  April, 1987
# Copyright 1984, 1987 by Stephen L. Moshier
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.beta(a, b)

</div></pre>
<a name=unit_binomialdistr></a><h2 class=pageheader><code>binomialdistr</code> module</h2>
<div class=pagecontent>
<h3 class=pageheader>Functions</h3>
<a href='#sub_binomialcdistribution' class=toc>binomialcdistribution</a><br>
<a href='#sub_binomialdistribution' class=toc>binomialdistribution</a><br>
<a href='#sub_invbinomialdistribution' class=toc>invbinomialdistribution</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='sub_binomialcdistribution'></a><h3 class=pageheader><code>binomialcdistribution</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Complemented binomial distribution
# 
# Returns the sum of the terms k+1 through n of the Binomial
# probability density:
# 
#   n
#   --  ( n )   j      n-j
#   &gt;   (   )  p  (1-p)
#   --  ( j )
#  j=k+1
# 
# The terms are not summed directly; instead the incomplete
# beta integral is employed, according to the formula
# 
# y = bdtrc( k, n, p ) = incbet( k+1, n-k, p ).
# 
# The arguments must be positive, with p ranging from 0 to 1.
# 
# ACCURACY:
# 
# Tested at random points (a,b,p).
# 
#               a,b                     Relative error:
# arithmetic  domain     # trials      peak         rms
#  For p between 0.001 and 1:
#    IEEE     0,100       100000      6.7e-15     8.2e-16
#  For p between 0 and .001:
#    IEEE     0,100       100000      1.5e-13     2.7e-15
# 
# Cephes Math Library Release 2.8:  June, 2000
# Copyright 1984, 1987, 1995, 2000 by Stephen L. Moshier
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.binomialcdistribution(k, n, p)

</div></pre>
<a name='sub_binomialdistribution'></a><h3 class=pageheader><code>binomialdistribution</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Binomial distribution
# 
# Returns the sum of the terms 0 through k of the Binomial
# probability density:
# 
#   k
#   --  ( n )   j      n-j
#   &gt;   (   )  p  (1-p)
#   --  ( j )
#  j=0
# 
# The terms are not summed directly; instead the incomplete
# beta integral is employed, according to the formula
# 
# y = bdtr( k, n, p ) = incbet( n-k, k+1, 1-p ).
# 
# The arguments must be positive, with p ranging from 0 to 1.
# 
# ACCURACY:
# 
# Tested at random points (a,b,p), with p between 0 and 1.
# 
#               a,b                     Relative error:
# arithmetic  domain     # trials      peak         rms
#  For p between 0.001 and 1:
#    IEEE     0,100       100000      4.3e-15     2.6e-16
# 
# Cephes Math Library Release 2.8:  June, 2000
# Copyright 1984, 1987, 1995, 2000 by Stephen L. Moshier
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.binomialdistribution(k, n, p)

</div></pre>
<a name='sub_invbinomialdistribution'></a><h3 class=pageheader><code>invbinomialdistribution</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Inverse binomial distribution
# 
# Finds the event probability p such that the sum of the
# terms 0 through k of the Binomial probability density
# is equal to the given cumulative probability y.
# 
# This is accomplished using the inverse beta integral
# function and the relation
# 
# 1 - p = incbi( n-k, k+1, y ).
# 
# ACCURACY:
# 
# Tested at random points (a,b,p).
# 
#               a,b                     Relative error:
# arithmetic  domain     # trials      peak         rms
#  For p between 0.001 and 1:
#    IEEE     0,100       100000      2.3e-14     6.4e-16
#    IEEE     0,10000     100000      6.6e-12     1.2e-13
#  For p between 10^-6 and 0.001:
#    IEEE     0,100       100000      2.0e-12     1.3e-14
#    IEEE     0,10000     100000      1.5e-12     3.2e-14
# 
# Cephes Math Library Release 2.8:  June, 2000
# Copyright 1984, 1987, 1995, 2000 by Stephen L. Moshier
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.invbinomialdistribution(k, n, y)

</div></pre>
<a name=unit_chebyshev></a><h2 class=pageheader><code>chebyshev</code> module</h2>
<div class=pagecontent>
<h3 class=pageheader>Functions</h3>
<a href='#sub_chebyshevcalculate' class=toc>chebyshevcalculate</a><br>
<a href='#sub_chebyshevcoefficients' class=toc>chebyshevcoefficients</a><br>
<a href='#sub_chebyshevsum' class=toc>chebyshevsum</a><br>
<a href='#sub_fromchebyshev' class=toc>fromchebyshev</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='sub_chebyshevcalculate'></a><h3 class=pageheader><code>chebyshevcalculate</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Calculation of the value of the Chebyshev polynomials of the
# first and second kinds.
# 
# Parameters:
#     r   -   polynomial kind, either 1 or 2.
#     n   -   degree, n&gt;=0
#     x   -   argument, -1 &lt;= x &lt;= 1
# 
# Result:
#     the value of the Chebyshev polynomial at x
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.chebyshevcalculate(r, n, x)

</div></pre>
<a name='sub_chebyshevcoefficients'></a><h3 class=pageheader><code>chebyshevcoefficients</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Representation of Tn as C[0] + C[1]*X + ... + C[N]*X^N
# 
# Input parameters:
#     N   -   polynomial degree, n&gt;=0
# 
# Output parameters:
#     C   -   coefficients
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: c = xalglib.chebyshevcoefficients(n)

</div></pre>
<a name='sub_chebyshevsum'></a><h3 class=pageheader><code>chebyshevsum</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Summation of Chebyshev polynomials using Clenshaws recurrence formula.
# 
# This routine calculates
#     c[0]*T0(x) + c[1]*T1(x) + ... + c[N]*TN(x)
# or
#     c[0]*U0(x) + c[1]*U1(x) + ... + c[N]*UN(x)
# depending on the R.
# 
# Parameters:
#     r   -   polynomial kind, either 1 or 2.
#     n   -   degree, n&gt;=0
#     x   -   argument
# 
# Result:
#     the value of the Chebyshev polynomial at x
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.chebyshevsum(c, r, n, x)

</div></pre>
<a name='sub_fromchebyshev'></a><h3 class=pageheader><code>fromchebyshev</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Conversion of a series of Chebyshev polynomials to a power series.
# 
# Represents A[0]*T0(x) + A[1]*T1(x) + ... + A[N]*Tn(x) as
# B[0] + B[1]*X + ... + B[N]*X^N.
# 
# Input parameters:
#     A   -   Chebyshev series coefficients
#     N   -   degree, N&gt;=0
# 
# Output parameters
#     B   -   power series coefficients
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: b = xalglib.fromchebyshev(a, n)

</div></pre>
<a name=unit_chisquaredistr></a><h2 class=pageheader><code>chisquaredistr</code> module</h2>
<div class=pagecontent>
<h3 class=pageheader>Functions</h3>
<a href='#sub_chisquarecdistribution' class=toc>chisquarecdistribution</a><br>
<a href='#sub_chisquaredistribution' class=toc>chisquaredistribution</a><br>
<a href='#sub_invchisquaredistribution' class=toc>invchisquaredistribution</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='sub_chisquarecdistribution'></a><h3 class=pageheader><code>chisquarecdistribution</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Complemented Chi-square distribution
# 
# Returns the area under the right hand tail (from x to
# infinity) of the Chi square probability density function
# with v degrees of freedom:
# 
#                                  inf.
#                                    -
#                        1          | |  v/2-1  -t/2
#  P( x | v )   =   -----------     |   t      e     dt
#                    v/2  -       | |
#                   2    | (v/2)   -
#                                   x
# 
# where x is the Chi-square variable.
# 
# The incomplete gamma integral is used, according to the
# formula
# 
# y = chdtr( v, x ) = igamc( v/2.0, x/2.0 ).
# 
# The arguments must both be positive.
# 
# ACCURACY:
# 
# See incomplete gamma function
# 
# Cephes Math Library Release 2.8:  June, 2000
# Copyright 1984, 1987, 2000 by Stephen L. Moshier
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.chisquarecdistribution(v, x)

</div></pre>
<a name='sub_chisquaredistribution'></a><h3 class=pageheader><code>chisquaredistribution</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Chi-square distribution
# 
# Returns the area under the left hand tail (from 0 to x)
# of the Chi square probability density function with
# v degrees of freedom.
# 
# 
#                                   x
#                                    -
#                        1          | |  v/2-1  -t/2
#  P( x | v )   =   -----------     |   t      e     dt
#                    v/2  -       | |
#                   2    | (v/2)   -
#                                   0
# 
# where x is the Chi-square variable.
# 
# The incomplete gamma integral is used, according to the
# formula
# 
# y = chdtr( v, x ) = igam( v/2.0, x/2.0 ).
# 
# The arguments must both be positive.
# 
# ACCURACY:
# 
# See incomplete gamma function
# 
# 
# Cephes Math Library Release 2.8:  June, 2000
# Copyright 1984, 1987, 2000 by Stephen L. Moshier
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.chisquaredistribution(v, x)

</div></pre>
<a name='sub_invchisquaredistribution'></a><h3 class=pageheader><code>invchisquaredistribution</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Inverse of complemented Chi-square distribution
# 
# Finds the Chi-square argument x such that the integral
# from x to infinity of the Chi-square density is equal
# to the given cumulative probability y.
# 
# This is accomplished using the inverse gamma integral
# function and the relation
# 
#    x/2 = igami( df/2, y );
# 
# ACCURACY:
# 
# See inverse incomplete gamma function
# 
# 
# Cephes Math Library Release 2.8:  June, 2000
# Copyright 1984, 1987, 2000 by Stephen L. Moshier
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.invchisquaredistribution(v, y)

</div></pre>
<a name=unit_conv></a><h2 class=pageheader><code>conv</code> module</h2>
<div class=pagecontent>
<h3 class=pageheader>Functions</h3>
<a href='#sub_convc1d' class=toc>convc1d</a><br>
<a href='#sub_convc1dcircular' class=toc>convc1dcircular</a><br>
<a href='#sub_convc1dcircularinv' class=toc>convc1dcircularinv</a><br>
<a href='#sub_convc1dinv' class=toc>convc1dinv</a><br>
<a href='#sub_convr1d' class=toc>convr1d</a><br>
<a href='#sub_convr1dcircular' class=toc>convr1dcircular</a><br>
<a href='#sub_convr1dcircularinv' class=toc>convr1dcircularinv</a><br>
<a href='#sub_convr1dinv' class=toc>convr1dinv</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='sub_convc1d'></a><h3 class=pageheader><code>convc1d</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# 1-dimensional complex convolution.
# 
# For given A/B returns conv(A,B) (non-circular). Subroutine can automatically
# choose between three implementations: straightforward O(M*N)  formula  for
# very small N (or M), overlap-add algorithm for  cases  where  max(M,N)  is
# significantly larger than min(M,N), but O(M*N) algorithm is too slow,  and
# general FFT-based formula for cases where two previois algorithms are  too
# slow.
# 
# Algorithm has max(M,N)*log(max(M,N)) complexity for any M/N.
# 
# INPUT PARAMETERS
#     A   -   array[0..M-1] - complex function to be transformed
#     M   -   problem size
#     B   -   array[0..N-1] - complex function to be transformed
#     N   -   problem size
# 
# OUTPUT PARAMETERS
#     R   -   convolution: A*B. array[0..N+M-2].
# 
# NOTE:
#     It is assumed that A is zero at T&lt;0, B is zero too.  If  one  or  both
# functions have non-zero values at negative T's, you  can  still  use  this
# subroutine - just shift its result correspondingly.
# 
#   -- ALGLIB --
#      Copyright 21.07.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: r = xalglib.convc1d(a, m, b, n)

</div></pre>
<a name='sub_convc1dcircular'></a><h3 class=pageheader><code>convc1dcircular</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# 1-dimensional circular complex convolution.
# 
# For given S/R returns conv(S,R) (circular). Algorithm has linearithmic
# complexity for any M/N.
# 
# IMPORTANT:  normal convolution is commutative,  i.e.   it  is symmetric  -
# conv(A,B)=conv(B,A).  Cyclic convolution IS NOT.  One function - S - is  a
# signal,  periodic function, and another - R - is a response,  non-periodic
# function with limited length.
# 
# INPUT PARAMETERS
#     S   -   array[0..M-1] - complex periodic signal
#     M   -   problem size
#     B   -   array[0..N-1] - complex non-periodic response
#     N   -   problem size
# 
# OUTPUT PARAMETERS
#     R   -   convolution: A*B. array[0..M-1].
# 
# NOTE:
#     It is assumed that B is zero at T&lt;0. If  it  has  non-zero  values  at
# negative T's, you can still use this subroutine - just  shift  its  result
# correspondingly.
# 
#   -- ALGLIB --
#      Copyright 21.07.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: c = xalglib.convc1dcircular(s, m, r, n)

</div></pre>
<a name='sub_convc1dcircularinv'></a><h3 class=pageheader><code>convc1dcircularinv</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# 1-dimensional circular complex deconvolution (inverse of ConvC1DCircular()).
# 
# Algorithm has M*log(M)) complexity for any M (composite or prime).
# 
# INPUT PARAMETERS
#     A   -   array[0..M-1] - convolved periodic signal, A = conv(R, B)
#     M   -   convolved signal length
#     B   -   array[0..N-1] - non-periodic response
#     N   -   response length
# 
# OUTPUT PARAMETERS
#     R   -   deconvolved signal. array[0..M-1].
# 
# NOTE:
#     deconvolution is unstable process and may result in division  by  zero
# (if your response function is degenerate, i.e. has zero Fourier coefficient).
# 
# NOTE:
#     It is assumed that B is zero at T&lt;0. If  it  has  non-zero  values  at
# negative T's, you can still use this subroutine - just  shift  its  result
# correspondingly.
# 
#   -- ALGLIB --
#      Copyright 21.07.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: r = xalglib.convc1dcircularinv(a, m, b, n)

</div></pre>
<a name='sub_convc1dinv'></a><h3 class=pageheader><code>convc1dinv</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# 1-dimensional complex non-circular deconvolution (inverse of ConvC1D()).
# 
# Algorithm has M*log(M)) complexity for any M (composite or prime).
# 
# INPUT PARAMETERS
#     A   -   array[0..M-1] - convolved signal, A = conv(R, B)
#     M   -   convolved signal length
#     B   -   array[0..N-1] - response
#     N   -   response length, N&lt;=M
# 
# OUTPUT PARAMETERS
#     R   -   deconvolved signal. array[0..M-N].
# 
# NOTE:
#     deconvolution is unstable process and may result in division  by  zero
# (if your response function is degenerate, i.e. has zero Fourier coefficient).
# 
# NOTE:
#     It is assumed that A is zero at T&lt;0, B is zero too.  If  one  or  both
# functions have non-zero values at negative T's, you  can  still  use  this
# subroutine - just shift its result correspondingly.
# 
#   -- ALGLIB --
#      Copyright 21.07.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: r = xalglib.convc1dinv(a, m, b, n)

</div></pre>
<a name='sub_convr1d'></a><h3 class=pageheader><code>convr1d</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# 1-dimensional real convolution.
# 
# Analogous to ConvC1D(), see ConvC1D() comments for more details.
# 
# INPUT PARAMETERS
#     A   -   array[0..M-1] - real function to be transformed
#     M   -   problem size
#     B   -   array[0..N-1] - real function to be transformed
#     N   -   problem size
# 
# OUTPUT PARAMETERS
#     R   -   convolution: A*B. array[0..N+M-2].
# 
# NOTE:
#     It is assumed that A is zero at T&lt;0, B is zero too.  If  one  or  both
# functions have non-zero values at negative T's, you  can  still  use  this
# subroutine - just shift its result correspondingly.
# 
#   -- ALGLIB --
#      Copyright 21.07.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: r = xalglib.convr1d(a, m, b, n)

</div></pre>
<a name='sub_convr1dcircular'></a><h3 class=pageheader><code>convr1dcircular</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# 1-dimensional circular real convolution.
# 
# Analogous to ConvC1DCircular(), see ConvC1DCircular() comments for more details.
# 
# INPUT PARAMETERS
#     S   -   array[0..M-1] - real signal
#     M   -   problem size
#     B   -   array[0..N-1] - real response
#     N   -   problem size
# 
# OUTPUT PARAMETERS
#     R   -   convolution: A*B. array[0..M-1].
# 
# NOTE:
#     It is assumed that B is zero at T&lt;0. If  it  has  non-zero  values  at
# negative T's, you can still use this subroutine - just  shift  its  result
# correspondingly.
# 
#   -- ALGLIB --
#      Copyright 21.07.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: c = xalglib.convr1dcircular(s, m, r, n)

</div></pre>
<a name='sub_convr1dcircularinv'></a><h3 class=pageheader><code>convr1dcircularinv</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# 1-dimensional complex deconvolution (inverse of ConvC1D()).
# 
# Algorithm has M*log(M)) complexity for any M (composite or prime).
# 
# INPUT PARAMETERS
#     A   -   array[0..M-1] - convolved signal, A = conv(R, B)
#     M   -   convolved signal length
#     B   -   array[0..N-1] - response
#     N   -   response length
# 
# OUTPUT PARAMETERS
#     R   -   deconvolved signal. array[0..M-N].
# 
# NOTE:
#     deconvolution is unstable process and may result in division  by  zero
# (if your response function is degenerate, i.e. has zero Fourier coefficient).
# 
# NOTE:
#     It is assumed that B is zero at T&lt;0. If  it  has  non-zero  values  at
# negative T's, you can still use this subroutine - just  shift  its  result
# correspondingly.
# 
#   -- ALGLIB --
#      Copyright 21.07.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: r = xalglib.convr1dcircularinv(a, m, b, n)

</div></pre>
<a name='sub_convr1dinv'></a><h3 class=pageheader><code>convr1dinv</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# 1-dimensional real deconvolution (inverse of ConvC1D()).
# 
# Algorithm has M*log(M)) complexity for any M (composite or prime).
# 
# INPUT PARAMETERS
#     A   -   array[0..M-1] - convolved signal, A = conv(R, B)
#     M   -   convolved signal length
#     B   -   array[0..N-1] - response
#     N   -   response length, N&lt;=M
# 
# OUTPUT PARAMETERS
#     R   -   deconvolved signal. array[0..M-N].
# 
# NOTE:
#     deconvolution is unstable process and may result in division  by  zero
# (if your response function is degenerate, i.e. has zero Fourier coefficient).
# 
# NOTE:
#     It is assumed that A is zero at T&lt;0, B is zero too.  If  one  or  both
# functions have non-zero values at negative T's, you  can  still  use  this
# subroutine - just shift its result correspondingly.
# 
#   -- ALGLIB --
#      Copyright 21.07.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: r = xalglib.convr1dinv(a, m, b, n)

</div></pre>
<a name=unit_corr></a><h2 class=pageheader><code>corr</code> module</h2>
<div class=pagecontent>
<h3 class=pageheader>Functions</h3>
<a href='#sub_corrc1d' class=toc>corrc1d</a><br>
<a href='#sub_corrc1dcircular' class=toc>corrc1dcircular</a><br>
<a href='#sub_corrr1d' class=toc>corrr1d</a><br>
<a href='#sub_corrr1dcircular' class=toc>corrr1dcircular</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='sub_corrc1d'></a><h3 class=pageheader><code>corrc1d</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# 1-dimensional complex cross-correlation.
# 
# For given Pattern/Signal returns corr(Pattern,Signal) (non-circular).
# 
# Correlation is calculated using reduction to  convolution.  Algorithm with
# max(N,N)*log(max(N,N)) complexity is used (see  ConvC1D()  for  more  info
# about performance).
# 
# IMPORTANT:
#     for  historical reasons subroutine accepts its parameters in  reversed
#     order: CorrC1D(Signal, Pattern) = Pattern x Signal (using  traditional
#     definition of cross-correlation, denoting cross-correlation as &quot;x&quot;).
# 
# INPUT PARAMETERS
#     Signal  -   array[0..N-1] - complex function to be transformed,
#                 signal containing pattern
#     N       -   problem size
#     Pattern -   array[0..M-1] - complex function to be transformed,
#                 pattern to search withing signal
#     M       -   problem size
# 
# OUTPUT PARAMETERS
#     R       -   cross-correlation, array[0..N+M-2]:
#                 * positive lags are stored in R[0..N-1],
#                   R[i] = sum(conj(pattern[j])*signal[i+j]
#                 * negative lags are stored in R[N..N+M-2],
#                   R[N+M-1-i] = sum(conj(pattern[j])*signal[-i+j]
# 
# NOTE:
#     It is assumed that pattern domain is [0..M-1].  If Pattern is non-zero
# on [-K..M-1],  you can still use this subroutine, just shift result by K.
# 
#   -- ALGLIB --
#      Copyright 21.07.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: r = xalglib.corrc1d(signal, n, pattern, m)

</div></pre>
<a name='sub_corrc1dcircular'></a><h3 class=pageheader><code>corrc1dcircular</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# 1-dimensional circular complex cross-correlation.
# 
# For given Pattern/Signal returns corr(Pattern,Signal) (circular).
# Algorithm has linearithmic complexity for any M/N.
# 
# IMPORTANT:
#     for  historical reasons subroutine accepts its parameters in  reversed
#     order:   CorrC1DCircular(Signal, Pattern) = Pattern x Signal    (using
#     traditional definition of cross-correlation, denoting cross-correlation
#     as &quot;x&quot;).
# 
# INPUT PARAMETERS
#     Signal  -   array[0..N-1] - complex function to be transformed,
#                 periodic signal containing pattern
#     N       -   problem size
#     Pattern -   array[0..M-1] - complex function to be transformed,
#                 non-periodic pattern to search withing signal
#     M       -   problem size
# 
# OUTPUT PARAMETERS
#     R   -   convolution: A*B. array[0..M-1].
# 
# 
#   -- ALGLIB --
#      Copyright 21.07.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: c = xalglib.corrc1dcircular(signal, m, pattern, n)

</div></pre>
<a name='sub_corrr1d'></a><h3 class=pageheader><code>corrr1d</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# 1-dimensional real cross-correlation.
# 
# For given Pattern/Signal returns corr(Pattern,Signal) (non-circular).
# 
# Correlation is calculated using reduction to  convolution.  Algorithm with
# max(N,N)*log(max(N,N)) complexity is used (see  ConvC1D()  for  more  info
# about performance).
# 
# IMPORTANT:
#     for  historical reasons subroutine accepts its parameters in  reversed
#     order: CorrR1D(Signal, Pattern) = Pattern x Signal (using  traditional
#     definition of cross-correlation, denoting cross-correlation as &quot;x&quot;).
# 
# INPUT PARAMETERS
#     Signal  -   array[0..N-1] - real function to be transformed,
#                 signal containing pattern
#     N       -   problem size
#     Pattern -   array[0..M-1] - real function to be transformed,
#                 pattern to search withing signal
#     M       -   problem size
# 
# OUTPUT PARAMETERS
#     R       -   cross-correlation, array[0..N+M-2]:
#                 * positive lags are stored in R[0..N-1],
#                   R[i] = sum(pattern[j]*signal[i+j]
#                 * negative lags are stored in R[N..N+M-2],
#                   R[N+M-1-i] = sum(pattern[j]*signal[-i+j]
# 
# NOTE:
#     It is assumed that pattern domain is [0..M-1].  If Pattern is non-zero
# on [-K..M-1],  you can still use this subroutine, just shift result by K.
# 
#   -- ALGLIB --
#      Copyright 21.07.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: r = xalglib.corrr1d(signal, n, pattern, m)

</div></pre>
<a name='sub_corrr1dcircular'></a><h3 class=pageheader><code>corrr1dcircular</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# 1-dimensional circular real cross-correlation.
# 
# For given Pattern/Signal returns corr(Pattern,Signal) (circular).
# Algorithm has linearithmic complexity for any M/N.
# 
# IMPORTANT:
#     for  historical reasons subroutine accepts its parameters in  reversed
#     order:   CorrR1DCircular(Signal, Pattern) = Pattern x Signal    (using
#     traditional definition of cross-correlation, denoting cross-correlation
#     as &quot;x&quot;).
# 
# INPUT PARAMETERS
#     Signal  -   array[0..N-1] - real function to be transformed,
#                 periodic signal containing pattern
#     N       -   problem size
#     Pattern -   array[0..M-1] - real function to be transformed,
#                 non-periodic pattern to search withing signal
#     M       -   problem size
# 
# OUTPUT PARAMETERS
#     R   -   convolution: A*B. array[0..M-1].
# 
# 
#   -- ALGLIB --
#      Copyright 21.07.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: c = xalglib.corrr1dcircular(signal, m, pattern, n)

</div></pre>
<a name=unit_correlationtests></a><h2 class=pageheader><code>correlationtests</code> module</h2>
<div class=pagecontent>
<h3 class=pageheader>Functions</h3>
<a href='#sub_pearsoncorrelationsignificance' class=toc>pearsoncorrelationsignificance</a><br>
<a href='#sub_spearmanrankcorrelationsignificance' class=toc>spearmanrankcorrelationsignificance</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='sub_pearsoncorrelationsignificance'></a><h3 class=pageheader><code>pearsoncorrelationsignificance</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Pearson's correlation coefficient significance test
# 
# This test checks hypotheses about whether X  and  Y  are  samples  of  two
# continuous  distributions  having  zero  correlation  or   whether   their
# correlation is non-zero.
# 
# The following tests are performed:
#     * two-tailed test (null hypothesis - X and Y have zero correlation)
#     * left-tailed test (null hypothesis - the correlation  coefficient  is
#       greater than or equal to 0)
#     * right-tailed test (null hypothesis - the correlation coefficient  is
#       less than or equal to 0).
# 
# Requirements:
#     * the number of elements in each sample is not less than 5
#     * normality of distributions of X and Y.
# 
# Input parameters:
#     R   -   Pearson's correlation coefficient for X and Y
#     N   -   number of elements in samples, N&gt;=5.
# 
# Output parameters:
#     BothTails   -   p-value for two-tailed test.
#                     If BothTails is less than the given significance level
#                     the null hypothesis is rejected.
#     LeftTail    -   p-value for left-tailed test.
#                     If LeftTail is less than the given significance level,
#                     the null hypothesis is rejected.
#     RightTail   -   p-value for right-tailed test.
#                     If RightTail is less than the given significance level
#                     the null hypothesis is rejected.
# 
#   -- ALGLIB --
#      Copyright 09.04.2007 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: bothtails, lefttail, righttail = xalglib.pearsoncorrelationsignificance(r, n)

</div></pre>
<a name='sub_spearmanrankcorrelationsignificance'></a><h3 class=pageheader><code>spearmanrankcorrelationsignificance</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Spearman's rank correlation coefficient significance test
# 
# This test checks hypotheses about whether X  and  Y  are  samples  of  two
# continuous  distributions  having  zero  correlation  or   whether   their
# correlation is non-zero.
# 
# The following tests are performed:
#     * two-tailed test (null hypothesis - X and Y have zero correlation)
#     * left-tailed test (null hypothesis - the correlation  coefficient  is
#       greater than or equal to 0)
#     * right-tailed test (null hypothesis - the correlation coefficient  is
#       less than or equal to 0).
# 
# Requirements:
#     * the number of elements in each sample is not less than 5.
# 
# The test is non-parametric and doesn't require distributions X and Y to be
# normal.
# 
# Input parameters:
#     R   -   Spearman's rank correlation coefficient for X and Y
#     N   -   number of elements in samples, N&gt;=5.
# 
# Output parameters:
#     BothTails   -   p-value for two-tailed test.
#                     If BothTails is less than the given significance level
#                     the null hypothesis is rejected.
#     LeftTail    -   p-value for left-tailed test.
#                     If LeftTail is less than the given significance level,
#                     the null hypothesis is rejected.
#     RightTail   -   p-value for right-tailed test.
#                     If RightTail is less than the given significance level
#                     the null hypothesis is rejected.
# 
#   -- ALGLIB --
#      Copyright 09.04.2007 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: bothtails, lefttail, righttail = xalglib.spearmanrankcorrelationsignificance(r, n)

</div></pre>
<a name=unit_dawson></a><h2 class=pageheader><code>dawson</code> module</h2>
<div class=pagecontent>
<h3 class=pageheader>Functions</h3>
<a href='#sub_dawsonintegral' class=toc>dawsonintegral</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='sub_dawsonintegral'></a><h3 class=pageheader><code>dawsonintegral</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Dawson's Integral
# 
# Approximates the integral
# 
#                             x
#                             -
#                      2     | |        2
#  dawsn(x)  =  exp( -x  )   |    exp( t  ) dt
#                          | |
#                           -
#                           0
# 
# Three different rational approximations are employed, for
# the intervals 0 to 3.25; 3.25 to 6.25; and 6.25 up.
# 
# ACCURACY:
# 
#                      Relative error:
# arithmetic   domain     # trials      peak         rms
#    IEEE      0,10        10000       6.9e-16     1.0e-16
# 
# Cephes Math Library Release 2.8:  June, 2000
# Copyright 1984, 1987, 1989, 2000 by Stephen L. Moshier
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.dawsonintegral(x)

</div></pre>
<a name=unit_densesolver></a><h2 class=pageheader><code>densesolver</code> module</h2>
<div class=pagecontent>
<h3 class=pageheader>Classes</h3>
<a href='#struct_densesolverlsreport' class=toc>densesolverlsreport</a><br>
<a href='#struct_densesolverreport' class=toc>densesolverreport</a><br>
<h3 class=pageheader>Functions</h3>
<a href='#sub_cmatrixlusolve' class=toc>cmatrixlusolve</a><br>
<a href='#sub_cmatrixlusolvem' class=toc>cmatrixlusolvem</a><br>
<a href='#sub_cmatrixmixedsolve' class=toc>cmatrixmixedsolve</a><br>
<a href='#sub_cmatrixmixedsolvem' class=toc>cmatrixmixedsolvem</a><br>
<a href='#sub_cmatrixsolve' class=toc>cmatrixsolve</a><br>
<a href='#sub_cmatrixsolvem' class=toc>cmatrixsolvem</a><br>
<a href='#sub_hpdmatrixcholeskysolve' class=toc>hpdmatrixcholeskysolve</a><br>
<a href='#sub_hpdmatrixcholeskysolvem' class=toc>hpdmatrixcholeskysolvem</a><br>
<a href='#sub_hpdmatrixsolve' class=toc>hpdmatrixsolve</a><br>
<a href='#sub_hpdmatrixsolvem' class=toc>hpdmatrixsolvem</a><br>
<a href='#sub_rmatrixlusolve' class=toc>rmatrixlusolve</a><br>
<a href='#sub_rmatrixlusolvem' class=toc>rmatrixlusolvem</a><br>
<a href='#sub_rmatrixmixedsolve' class=toc>rmatrixmixedsolve</a><br>
<a href='#sub_rmatrixmixedsolvem' class=toc>rmatrixmixedsolvem</a><br>
<a href='#sub_rmatrixsolve' class=toc>rmatrixsolve</a><br>
<a href='#sub_rmatrixsolvels' class=toc>rmatrixsolvels</a><br>
<a href='#sub_rmatrixsolvem' class=toc>rmatrixsolvem</a><br>
<a href='#sub_spdmatrixcholeskysolve' class=toc>spdmatrixcholeskysolve</a><br>
<a href='#sub_spdmatrixcholeskysolvem' class=toc>spdmatrixcholeskysolvem</a><br>
<a href='#sub_spdmatrixsolve' class=toc>spdmatrixsolve</a><br>
<a href='#sub_spdmatrixsolvem' class=toc>spdmatrixsolvem</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='struct_densesolverlsreport'></a><h3 class=pageheader><code>densesolverlsreport</code> class</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# 
#

</div><div style='margin-top: 0; margin-bottom: 0;'><span style='font-weight: bold; color: green;'>class</span> densesolverlsreport(object):
    ...

</div></pre>
<a name='struct_densesolverreport'></a><h3 class=pageheader><code>densesolverreport</code> class</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# 
#

</div><div style='margin-top: 0; margin-bottom: 0;'><span style='font-weight: bold; color: green;'>class</span> densesolverreport(object):
    ...

</div></pre>
<a name='sub_cmatrixlusolve'></a><h3 class=pageheader><code>cmatrixlusolve</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Dense solver. Same as RMatrixLUSolve(), but for complex matrices.
# 
# Algorithm features:
# * automatic detection of degenerate cases
# * O(N^2) complexity
# * condition number estimation
# 
# No iterative refinement is provided because exact form of original matrix
# is not known to subroutine. Use CMatrixSolve or CMatrixMixedSolve  if  you
# need iterative refinement.
# 
# INPUT PARAMETERS
#     LUA     -   array[0..N-1,0..N-1], LU decomposition, CMatrixLU result
#     P       -   array[0..N-1], pivots array, CMatrixLU result
#     N       -   size of A
#     B       -   array[0..N-1], right part
# 
# OUTPUT PARAMETERS
#     Info    -   same as in RMatrixSolve
#     Rep     -   same as in RMatrixSolve
#     X       -   same as in RMatrixSolve
# 
#   -- ALGLIB --
#      Copyright 27.01.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: info, rep, x = xalglib.cmatrixlusolve(lua, p, n, b)

</div></pre>
<a name='sub_cmatrixlusolvem'></a><h3 class=pageheader><code>cmatrixlusolvem</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Dense solver. Same as RMatrixLUSolveM(), but for complex matrices.
# 
# Algorithm features:
# * automatic detection of degenerate cases
# * O(M*N^2) complexity
# * condition number estimation
# 
# No iterative refinement  is provided because exact form of original matrix
# is not known to subroutine. Use CMatrixSolve or CMatrixMixedSolve  if  you
# need iterative refinement.
# 
# INPUT PARAMETERS
#     LUA     -   array[0..N-1,0..N-1], LU decomposition, RMatrixLU result
#     P       -   array[0..N-1], pivots array, RMatrixLU result
#     N       -   size of A
#     B       -   array[0..N-1,0..M-1], right part
#     M       -   right part size
# 
# OUTPUT PARAMETERS
#     Info    -   same as in RMatrixSolve
#     Rep     -   same as in RMatrixSolve
#     X       -   same as in RMatrixSolve
# 
#   -- ALGLIB --
#      Copyright 27.01.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: info, rep, x = xalglib.cmatrixlusolvem(lua, p, n, b, m)

</div></pre>
<a name='sub_cmatrixmixedsolve'></a><h3 class=pageheader><code>cmatrixmixedsolve</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Dense solver. Same as RMatrixMixedSolve(), but for complex matrices.
# 
# Algorithm features:
# * automatic detection of degenerate cases
# * condition number estimation
# * iterative refinement
# * O(N^2) complexity
# 
# INPUT PARAMETERS
#     A       -   array[0..N-1,0..N-1], system matrix
#     LUA     -   array[0..N-1,0..N-1], LU decomposition, CMatrixLU result
#     P       -   array[0..N-1], pivots array, CMatrixLU result
#     N       -   size of A
#     B       -   array[0..N-1], right part
# 
# OUTPUT PARAMETERS
#     Info    -   same as in RMatrixSolveM
#     Rep     -   same as in RMatrixSolveM
#     X       -   same as in RMatrixSolveM
# 
#   -- ALGLIB --
#      Copyright 27.01.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: info, rep, x = xalglib.cmatrixmixedsolve(a, lua, p, n, b)

</div></pre>
<a name='sub_cmatrixmixedsolvem'></a><h3 class=pageheader><code>cmatrixmixedsolvem</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Dense solver. Same as RMatrixMixedSolveM(), but for complex matrices.
# 
# Algorithm features:
# * automatic detection of degenerate cases
# * condition number estimation
# * iterative refinement
# * O(M*N^2) complexity
# 
# INPUT PARAMETERS
#     A       -   array[0..N-1,0..N-1], system matrix
#     LUA     -   array[0..N-1,0..N-1], LU decomposition, CMatrixLU result
#     P       -   array[0..N-1], pivots array, CMatrixLU result
#     N       -   size of A
#     B       -   array[0..N-1,0..M-1], right part
#     M       -   right part size
# 
# OUTPUT PARAMETERS
#     Info    -   same as in RMatrixSolveM
#     Rep     -   same as in RMatrixSolveM
#     X       -   same as in RMatrixSolveM
# 
#   -- ALGLIB --
#      Copyright 27.01.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: info, rep, x = xalglib.cmatrixmixedsolvem(a, lua, p, n, b, m)

</div></pre>
<a name='sub_cmatrixsolve'></a><h3 class=pageheader><code>cmatrixsolve</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Dense solver. Same as RMatrixSolve(), but for complex matrices.
# 
# Algorithm features:
# * automatic detection of degenerate cases
# * condition number estimation
# * iterative refinement
# * O(N^3) complexity
# 
# INPUT PARAMETERS
#     A       -   array[0..N-1,0..N-1], system matrix
#     N       -   size of A
#     B       -   array[0..N-1], right part
# 
# OUTPUT PARAMETERS
#     Info    -   same as in RMatrixSolve
#     Rep     -   same as in RMatrixSolve
#     X       -   same as in RMatrixSolve
# 
#   -- ALGLIB --
#      Copyright 27.01.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: info, rep, x = xalglib.cmatrixsolve(a, n, b)

</div></pre>
<a name='sub_cmatrixsolvem'></a><h3 class=pageheader><code>cmatrixsolvem</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Dense solver. Same as RMatrixSolveM(), but for complex matrices.
# 
# Algorithm features:
# * automatic detection of degenerate cases
# * condition number estimation
# * iterative refinement
# * O(N^3+M*N^2) complexity
# 
# INPUT PARAMETERS
#     A       -   array[0..N-1,0..N-1], system matrix
#     N       -   size of A
#     B       -   array[0..N-1,0..M-1], right part
#     M       -   right part size
#     RFS     -   iterative refinement switch:
#                 * True - refinement is used.
#                   Less performance, more precision.
#                 * False - refinement is not used.
#                   More performance, less precision.
# 
# OUTPUT PARAMETERS
#     Info    -   same as in RMatrixSolve
#     Rep     -   same as in RMatrixSolve
#     X       -   same as in RMatrixSolve
# 
#   -- ALGLIB --
#      Copyright 27.01.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: info, rep, x = xalglib.cmatrixsolvem(a, n, b, m, rfs)

</div></pre>
<a name='sub_hpdmatrixcholeskysolve'></a><h3 class=pageheader><code>hpdmatrixcholeskysolve</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Dense solver. Same as RMatrixLUSolve(), but for  HPD matrices  represented
# by their Cholesky decomposition.
# 
# Algorithm features:
# * automatic detection of degenerate cases
# * O(N^2) complexity
# * condition number estimation
# * matrix is represented by its upper or lower triangle
# 
# No iterative refinement is provided because such partial representation of
# matrix does not allow efficient calculation of extra-precise  matrix-vector
# products for large matrices. Use RMatrixSolve or RMatrixMixedSolve  if  you
# need iterative refinement.
# 
# INPUT PARAMETERS
#     CHA     -   array[0..N-1,0..N-1], Cholesky decomposition,
#                 SPDMatrixCholesky result
#     N       -   size of A
#     IsUpper -   what half of CHA is provided
#     B       -   array[0..N-1], right part
# 
# OUTPUT PARAMETERS
#     Info    -   same as in RMatrixSolve
#     Rep     -   same as in RMatrixSolve
#     X       -   same as in RMatrixSolve
# 
#   -- ALGLIB --
#      Copyright 27.01.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: info, rep, x = xalglib.hpdmatrixcholeskysolve(cha, n, isupper, b)

</div></pre>
<a name='sub_hpdmatrixcholeskysolvem'></a><h3 class=pageheader><code>hpdmatrixcholeskysolvem</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Dense solver. Same as RMatrixLUSolveM(), but for HPD matrices  represented
# by their Cholesky decomposition.
# 
# Algorithm features:
# * automatic detection of degenerate cases
# * O(M*N^2) complexity
# * condition number estimation
# * matrix is represented by its upper or lower triangle
# 
# No iterative refinement is provided because such partial representation of
# matrix does not allow efficient calculation of extra-precise  matrix-vector
# products for large matrices. Use RMatrixSolve or RMatrixMixedSolve  if  you
# need iterative refinement.
# 
# INPUT PARAMETERS
#     CHA     -   array[0..N-1,0..N-1], Cholesky decomposition,
#                 HPDMatrixCholesky result
#     N       -   size of CHA
#     IsUpper -   what half of CHA is provided
#     B       -   array[0..N-1,0..M-1], right part
#     M       -   right part size
# 
# OUTPUT PARAMETERS
#     Info    -   same as in RMatrixSolve
#     Rep     -   same as in RMatrixSolve
#     X       -   same as in RMatrixSolve
# 
#   -- ALGLIB --
#      Copyright 27.01.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: info, rep, x = xalglib.hpdmatrixcholeskysolvem(cha, n, isupper, b, m)

</div></pre>
<a name='sub_hpdmatrixsolve'></a><h3 class=pageheader><code>hpdmatrixsolve</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Dense solver. Same as RMatrixSolve(),  but for Hermitian positive definite
# matrices.
# 
# Algorithm features:
# * automatic detection of degenerate cases
# * condition number estimation
# * O(N^3) complexity
# * matrix is represented by its upper or lower triangle
# 
# No iterative refinement is provided because such partial representation of
# matrix does not allow efficient calculation of extra-precise  matrix-vector
# products for large matrices. Use RMatrixSolve or RMatrixMixedSolve  if  you
# need iterative refinement.
# 
# INPUT PARAMETERS
#     A       -   array[0..N-1,0..N-1], system matrix
#     N       -   size of A
#     IsUpper -   what half of A is provided
#     B       -   array[0..N-1], right part
# 
# OUTPUT PARAMETERS
#     Info    -   same as in RMatrixSolve
#                 Returns -3 for non-HPD matrices.
#     Rep     -   same as in RMatrixSolve
#     X       -   same as in RMatrixSolve
# 
#   -- ALGLIB --
#      Copyright 27.01.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: info, rep, x = xalglib.hpdmatrixsolve(a, n, isupper, b)

</div></pre>
<a name='sub_hpdmatrixsolvem'></a><h3 class=pageheader><code>hpdmatrixsolvem</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Dense solver. Same as RMatrixSolveM(), but for Hermitian positive definite
# matrices.
# 
# Algorithm features:
# * automatic detection of degenerate cases
# * condition number estimation
# * O(N^3+M*N^2) complexity
# * matrix is represented by its upper or lower triangle
# 
# No iterative refinement is provided because such partial representation of
# matrix does not allow efficient calculation of extra-precise  matrix-vector
# products for large matrices. Use RMatrixSolve or RMatrixMixedSolve  if  you
# need iterative refinement.
# 
# INPUT PARAMETERS
#     A       -   array[0..N-1,0..N-1], system matrix
#     N       -   size of A
#     IsUpper -   what half of A is provided
#     B       -   array[0..N-1,0..M-1], right part
#     M       -   right part size
# 
# OUTPUT PARAMETERS
#     Info    -   same as in RMatrixSolve.
#                 Returns -3 for non-HPD matrices.
#     Rep     -   same as in RMatrixSolve
#     X       -   same as in RMatrixSolve
# 
#   -- ALGLIB --
#      Copyright 27.01.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: info, rep, x = xalglib.hpdmatrixsolvem(a, n, isupper, b, m)

</div></pre>
<a name='sub_rmatrixlusolve'></a><h3 class=pageheader><code>rmatrixlusolve</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Dense solver.
# 
# This  subroutine  solves  a  system  A*X=B,  where A is NxN non-denegerate
# real matrix given by its LU decomposition, X and B are NxM real matrices.
# 
# Algorithm features:
# * automatic detection of degenerate cases
# * O(N^2) complexity
# * condition number estimation
# 
# No iterative refinement  is provided because exact form of original matrix
# is not known to subroutine. Use RMatrixSolve or RMatrixMixedSolve  if  you
# need iterative refinement.
# 
# INPUT PARAMETERS
#     LUA     -   array[0..N-1,0..N-1], LU decomposition, RMatrixLU result
#     P       -   array[0..N-1], pivots array, RMatrixLU result
#     N       -   size of A
#     B       -   array[0..N-1], right part
# 
# OUTPUT PARAMETERS
#     Info    -   same as in RMatrixSolve
#     Rep     -   same as in RMatrixSolve
#     X       -   same as in RMatrixSolve
# 
#   -- ALGLIB --
#      Copyright 27.01.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: info, rep, x = xalglib.rmatrixlusolve(lua, p, n, b)

</div></pre>
<a name='sub_rmatrixlusolvem'></a><h3 class=pageheader><code>rmatrixlusolvem</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Dense solver.
# 
# Similar to RMatrixLUSolve() but solves task with multiple right parts
# (where b and x are NxM matrices).
# 
# Algorithm features:
# * automatic detection of degenerate cases
# * O(M*N^2) complexity
# * condition number estimation
# 
# No iterative refinement  is provided because exact form of original matrix
# is not known to subroutine. Use RMatrixSolve or RMatrixMixedSolve  if  you
# need iterative refinement.
# 
# INPUT PARAMETERS
#     LUA     -   array[0..N-1,0..N-1], LU decomposition, RMatrixLU result
#     P       -   array[0..N-1], pivots array, RMatrixLU result
#     N       -   size of A
#     B       -   array[0..N-1,0..M-1], right part
#     M       -   right part size
# 
# OUTPUT PARAMETERS
#     Info    -   same as in RMatrixSolve
#     Rep     -   same as in RMatrixSolve
#     X       -   same as in RMatrixSolve
# 
#   -- ALGLIB --
#      Copyright 27.01.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: info, rep, x = xalglib.rmatrixlusolvem(lua, p, n, b, m)

</div></pre>
<a name='sub_rmatrixmixedsolve'></a><h3 class=pageheader><code>rmatrixmixedsolve</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Dense solver.
# 
# This  subroutine  solves  a  system  A*x=b,  where BOTH ORIGINAL A AND ITS
# LU DECOMPOSITION ARE KNOWN. You can use it if for some  reasons  you  have
# both A and its LU decomposition.
# 
# Algorithm features:
# * automatic detection of degenerate cases
# * condition number estimation
# * iterative refinement
# * O(N^2) complexity
# 
# INPUT PARAMETERS
#     A       -   array[0..N-1,0..N-1], system matrix
#     LUA     -   array[0..N-1,0..N-1], LU decomposition, RMatrixLU result
#     P       -   array[0..N-1], pivots array, RMatrixLU result
#     N       -   size of A
#     B       -   array[0..N-1], right part
# 
# OUTPUT PARAMETERS
#     Info    -   same as in RMatrixSolveM
#     Rep     -   same as in RMatrixSolveM
#     X       -   same as in RMatrixSolveM
# 
#   -- ALGLIB --
#      Copyright 27.01.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: info, rep, x = xalglib.rmatrixmixedsolve(a, lua, p, n, b)

</div></pre>
<a name='sub_rmatrixmixedsolvem'></a><h3 class=pageheader><code>rmatrixmixedsolvem</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Dense solver.
# 
# Similar to RMatrixMixedSolve() but  solves task with multiple right  parts
# (where b and x are NxM matrices).
# 
# Algorithm features:
# * automatic detection of degenerate cases
# * condition number estimation
# * iterative refinement
# * O(M*N^2) complexity
# 
# INPUT PARAMETERS
#     A       -   array[0..N-1,0..N-1], system matrix
#     LUA     -   array[0..N-1,0..N-1], LU decomposition, RMatrixLU result
#     P       -   array[0..N-1], pivots array, RMatrixLU result
#     N       -   size of A
#     B       -   array[0..N-1,0..M-1], right part
#     M       -   right part size
# 
# OUTPUT PARAMETERS
#     Info    -   same as in RMatrixSolveM
#     Rep     -   same as in RMatrixSolveM
#     X       -   same as in RMatrixSolveM
# 
#   -- ALGLIB --
#      Copyright 27.01.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: info, rep, x = xalglib.rmatrixmixedsolvem(a, lua, p, n, b, m)

</div></pre>
<a name='sub_rmatrixsolve'></a><h3 class=pageheader><code>rmatrixsolve</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Dense solver.
# 
# This  subroutine  solves  a  system  A*x=b,  where A is NxN non-denegerate
# real matrix, x and b are vectors.
# 
# Algorithm features:
# * automatic detection of degenerate cases
# * condition number estimation
# * iterative refinement
# * O(N^3) complexity
# 
# INPUT PARAMETERS
#     A       -   array[0..N-1,0..N-1], system matrix
#     N       -   size of A
#     B       -   array[0..N-1], right part
# 
# OUTPUT PARAMETERS
#     Info    -   return code:
#                 * -3    A is singular, or VERY close to singular.
#                         X is filled by zeros in such cases.
#                 * -1    N&lt;=0 was passed
#                 *  1    task is solved (but matrix A may be ill-conditioned,
#                         check R1/RInf parameters for condition numbers).
#     Rep     -   solver report, see below for more info
#     X       -   array[0..N-1], it contains:
#                 * solution of A*x=b if A is non-singular (well-conditioned
#                   or ill-conditioned, but not very close to singular)
#                 * zeros,  if  A  is  singular  or  VERY  close to singular
#                   (in this case Info=-3).
# 
# SOLVER REPORT
# 
# Subroutine sets following fields of the Rep structure:
# * R1        reciprocal of condition number: 1/cond(A), 1-norm.
# * RInf      reciprocal of condition number: 1/cond(A), inf-norm.
# 
#   -- ALGLIB --
#      Copyright 27.01.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: info, rep, x = xalglib.rmatrixsolve(a, n, b)

</div></pre>
<a name='sub_rmatrixsolvels'></a><h3 class=pageheader><code>rmatrixsolvels</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Dense solver.
# 
# This subroutine finds solution of the linear system A*X=B with non-square,
# possibly degenerate A.  System  is  solved in the least squares sense, and
# general least squares solution  X = X0 + CX*y  which  minimizes |A*X-B| is
# returned. If A is non-degenerate, solution in the  usual sense is returned
# 
# Algorithm features:
# * automatic detection of degenerate cases
# * iterative refinement
# * O(N^3) complexity
# 
# INPUT PARAMETERS
#     A       -   array[0..NRows-1,0..NCols-1], system matrix
#     NRows   -   vertical size of A
#     NCols   -   horizontal size of A
#     B       -   array[0..NCols-1], right part
#     Threshold-  a number in [0,1]. Singular values  beyond  Threshold  are
#                 considered  zero.  Set  it to 0.0, if you don't understand
#                 what it means, so the solver will choose good value on its
#                 own.
# 
# OUTPUT PARAMETERS
#     Info    -   return code:
#                 * -4    SVD subroutine failed
#                 * -1    if NRows&lt;=0 or NCols&lt;=0 or Threshold&lt;0 was passed
#                 *  1    if task is solved
#     Rep     -   solver report, see below for more info
#     X       -   array[0..N-1,0..M-1], it contains:
#                 * solution of A*X=B if A is non-singular (well-conditioned
#                   or ill-conditioned, but not very close to singular)
#                 * zeros,  if  A  is  singular  or  VERY  close to singular
#                   (in this case Info=-3).
# 
# SOLVER REPORT
# 
# Subroutine sets following fields of the Rep structure:
# * R2        reciprocal of condition number: 1/cond(A), 2-norm.
# * N         = NCols
# * K         dim(Null(A))
# * CX        array[0..N-1,0..K-1], kernel of A.
#             Columns of CX store such vectors that A*CX[i]=0.
# 
#   -- ALGLIB --
#      Copyright 24.08.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: info, rep, x = xalglib.rmatrixsolvels(a, nrows, ncols, b, threshold)

</div></pre>
<a name='sub_rmatrixsolvem'></a><h3 class=pageheader><code>rmatrixsolvem</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Dense solver.
# 
# Similar to RMatrixSolve() but solves task with multiple right parts (where
# b and x are NxM matrices).
# 
# Algorithm features:
# * automatic detection of degenerate cases
# * condition number estimation
# * optional iterative refinement
# * O(N^3+M*N^2) complexity
# 
# INPUT PARAMETERS
#     A       -   array[0..N-1,0..N-1], system matrix
#     N       -   size of A
#     B       -   array[0..N-1,0..M-1], right part
#     M       -   right part size
#     RFS     -   iterative refinement switch:
#                 * True - refinement is used.
#                   Less performance, more precision.
#                 * False - refinement is not used.
#                   More performance, less precision.
# 
# OUTPUT PARAMETERS
#     Info    -   same as in RMatrixSolve
#     Rep     -   same as in RMatrixSolve
#     X       -   same as in RMatrixSolve
# 
#   -- ALGLIB --
#      Copyright 27.01.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: info, rep, x = xalglib.rmatrixsolvem(a, n, b, m, rfs)

</div></pre>
<a name='sub_spdmatrixcholeskysolve'></a><h3 class=pageheader><code>spdmatrixcholeskysolve</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Dense solver. Same as RMatrixLUSolve(), but for  SPD matrices  represented
# by their Cholesky decomposition.
# 
# Algorithm features:
# * automatic detection of degenerate cases
# * O(N^2) complexity
# * condition number estimation
# * matrix is represented by its upper or lower triangle
# 
# No iterative refinement is provided because such partial representation of
# matrix does not allow efficient calculation of extra-precise  matrix-vector
# products for large matrices. Use RMatrixSolve or RMatrixMixedSolve  if  you
# need iterative refinement.
# 
# INPUT PARAMETERS
#     CHA     -   array[0..N-1,0..N-1], Cholesky decomposition,
#                 SPDMatrixCholesky result
#     N       -   size of A
#     IsUpper -   what half of CHA is provided
#     B       -   array[0..N-1], right part
# 
# OUTPUT PARAMETERS
#     Info    -   same as in RMatrixSolve
#     Rep     -   same as in RMatrixSolve
#     X       -   same as in RMatrixSolve
# 
#   -- ALGLIB --
#      Copyright 27.01.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: info, rep, x = xalglib.spdmatrixcholeskysolve(cha, n, isupper, b)

</div></pre>
<a name='sub_spdmatrixcholeskysolvem'></a><h3 class=pageheader><code>spdmatrixcholeskysolvem</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Dense solver. Same as RMatrixLUSolveM(), but for SPD matrices  represented
# by their Cholesky decomposition.
# 
# Algorithm features:
# * automatic detection of degenerate cases
# * O(M*N^2) complexity
# * condition number estimation
# * matrix is represented by its upper or lower triangle
# 
# No iterative refinement is provided because such partial representation of
# matrix does not allow efficient calculation of extra-precise  matrix-vector
# products for large matrices. Use RMatrixSolve or RMatrixMixedSolve  if  you
# need iterative refinement.
# 
# INPUT PARAMETERS
#     CHA     -   array[0..N-1,0..N-1], Cholesky decomposition,
#                 SPDMatrixCholesky result
#     N       -   size of CHA
#     IsUpper -   what half of CHA is provided
#     B       -   array[0..N-1,0..M-1], right part
#     M       -   right part size
# 
# OUTPUT PARAMETERS
#     Info    -   same as in RMatrixSolve
#     Rep     -   same as in RMatrixSolve
#     X       -   same as in RMatrixSolve
# 
#   -- ALGLIB --
#      Copyright 27.01.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: info, rep, x = xalglib.spdmatrixcholeskysolvem(cha, n, isupper, b, m)

</div></pre>
<a name='sub_spdmatrixsolve'></a><h3 class=pageheader><code>spdmatrixsolve</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Dense solver. Same as RMatrixSolve(), but for SPD matrices.
# 
# Algorithm features:
# * automatic detection of degenerate cases
# * condition number estimation
# * O(N^3) complexity
# * matrix is represented by its upper or lower triangle
# 
# No iterative refinement is provided because such partial representation of
# matrix does not allow efficient calculation of extra-precise  matrix-vector
# products for large matrices. Use RMatrixSolve or RMatrixMixedSolve  if  you
# need iterative refinement.
# 
# INPUT PARAMETERS
#     A       -   array[0..N-1,0..N-1], system matrix
#     N       -   size of A
#     IsUpper -   what half of A is provided
#     B       -   array[0..N-1], right part
# 
# OUTPUT PARAMETERS
#     Info    -   same as in RMatrixSolve
#                 Returns -3 for non-SPD matrices.
#     Rep     -   same as in RMatrixSolve
#     X       -   same as in RMatrixSolve
# 
#   -- ALGLIB --
#      Copyright 27.01.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: info, rep, x = xalglib.spdmatrixsolve(a, n, isupper, b)

</div></pre>
<a name='sub_spdmatrixsolvem'></a><h3 class=pageheader><code>spdmatrixsolvem</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Dense solver. Same as RMatrixSolveM(), but for symmetric positive definite
# matrices.
# 
# Algorithm features:
# * automatic detection of degenerate cases
# * condition number estimation
# * O(N^3+M*N^2) complexity
# * matrix is represented by its upper or lower triangle
# 
# No iterative refinement is provided because such partial representation of
# matrix does not allow efficient calculation of extra-precise  matrix-vector
# products for large matrices. Use RMatrixSolve or RMatrixMixedSolve  if  you
# need iterative refinement.
# 
# INPUT PARAMETERS
#     A       -   array[0..N-1,0..N-1], system matrix
#     N       -   size of A
#     IsUpper -   what half of A is provided
#     B       -   array[0..N-1,0..M-1], right part
#     M       -   right part size
# 
# OUTPUT PARAMETERS
#     Info    -   same as in RMatrixSolve.
#                 Returns -3 for non-SPD matrices.
#     Rep     -   same as in RMatrixSolve
#     X       -   same as in RMatrixSolve
# 
#   -- ALGLIB --
#      Copyright 27.01.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: info, rep, x = xalglib.spdmatrixsolvem(a, n, isupper, b, m)

</div></pre>
<a name=unit_dforest></a><h2 class=pageheader><code>dforest</code> module</h2>
<div class=pagecontent>
<h3 class=pageheader>Classes</h3>
<a href='#struct_decisionforest' class=toc>decisionforest</a><br>
<a href='#struct_dfreport' class=toc>dfreport</a><br>
<h3 class=pageheader>Functions</h3>
<a href='#sub_dfavgce' class=toc>dfavgce</a><br>
<a href='#sub_dfavgerror' class=toc>dfavgerror</a><br>
<a href='#sub_dfavgrelerror' class=toc>dfavgrelerror</a><br>
<a href='#sub_dfbuildrandomdecisionforest' class=toc>dfbuildrandomdecisionforest</a><br>
<a href='#sub_dfprocess' class=toc>dfprocess</a><br>
<a href='#sub_dfprocessi' class=toc>dfprocessi</a><br>
<a href='#sub_dfrelclserror' class=toc>dfrelclserror</a><br>
<a href='#sub_dfrmserror' class=toc>dfrmserror</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='struct_decisionforest'></a><h3 class=pageheader><code>decisionforest</code> class</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# 
#

</div><div style='margin-top: 0; margin-bottom: 0;'><span style='font-weight: bold; color: green;'>class</span> decisionforest(object):
    ...

</div></pre>
<a name='struct_dfreport'></a><h3 class=pageheader><code>dfreport</code> class</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# 
#

</div><div style='margin-top: 0; margin-bottom: 0;'><span style='font-weight: bold; color: green;'>class</span> dfreport(object):
    ...

</div></pre>
<a name='sub_dfavgce'></a><h3 class=pageheader><code>dfavgce</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Average cross-entropy (in bits per element) on the test set
# 
# INPUT PARAMETERS:
#     DF      -   decision forest model
#     XY      -   test set
#     NPoints -   test set size
# 
# RESULT:
#     CrossEntropy/(NPoints*LN(2)).
#     Zero if model solves regression task.
# 
#   -- ALGLIB --
#      Copyright 16.02.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.dfavgce(df, xy, npoints)

</div></pre>
<a name='sub_dfavgerror'></a><h3 class=pageheader><code>dfavgerror</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Average error on the test set
# 
# INPUT PARAMETERS:
#     DF      -   decision forest model
#     XY      -   test set
#     NPoints -   test set size
# 
# RESULT:
#     Its meaning for regression task is obvious. As for
#     classification task, it means average error when estimating posterior
#     probabilities.
# 
#   -- ALGLIB --
#      Copyright 16.02.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.dfavgerror(df, xy, npoints)

</div></pre>
<a name='sub_dfavgrelerror'></a><h3 class=pageheader><code>dfavgrelerror</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Average relative error on the test set
# 
# INPUT PARAMETERS:
#     DF      -   decision forest model
#     XY      -   test set
#     NPoints -   test set size
# 
# RESULT:
#     Its meaning for regression task is obvious. As for
#     classification task, it means average relative error when estimating
#     posterior probability of belonging to the correct class.
# 
#   -- ALGLIB --
#      Copyright 16.02.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.dfavgrelerror(df, xy, npoints)

</div></pre>
<a name='sub_dfbuildrandomdecisionforest'></a><h3 class=pageheader><code>dfbuildrandomdecisionforest</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# This subroutine builds random decision forest.
# 
# INPUT PARAMETERS:
#     XY          -   training set
#     NPoints     -   training set size, NPoints&gt;=1
#     NVars       -   number of independent variables, NVars&gt;=1
#     NClasses    -   task type:
#                     * NClasses=1 - regression task with one
#                                    dependent variable
#                     * NClasses&gt;1 - classification task with
#                                    NClasses classes.
#     NTrees      -   number of trees in a forest, NTrees&gt;=1.
#                     recommended values: 50-100.
#     R           -   percent of a training set used to build
#                     individual trees. 0&lt;R&lt;=1.
#                     recommended values: 0.1 &lt;= R &lt;= 0.66.
# 
# OUTPUT PARAMETERS:
#     Info        -   return code:
#                     * -2, if there is a point with class number
#                           outside of [0..NClasses-1].
#                     * -1, if incorrect parameters was passed
#                           (NPoints&lt;1, NVars&lt;1, NClasses&lt;1, NTrees&lt;1, R&lt;=0
#                           or R&gt;1).
#                     *  1, if task has been solved
#     DF          -   model built
#     Rep         -   training report, contains error on a training set
#                     and out-of-bag estimates of generalization error.
# 
#   -- ALGLIB --
#      Copyright 19.02.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: info, df, rep = xalglib.dfbuildrandomdecisionforest(xy, npoints, nvars, nclasses, ntrees, r)

</div></pre>
<a name='sub_dfprocess'></a><h3 class=pageheader><code>dfprocess</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Procesing
# 
# INPUT PARAMETERS:
#     DF      -   decision forest model
#     X       -   input vector,  array[0..NVars-1].
# 
# OUTPUT PARAMETERS:
#     Y       -   result. Regression estimate when solving regression  task,
#                 vector of posterior probabilities for classification task.
# 
# See also DFProcessI.
# 
#   -- ALGLIB --
#      Copyright 16.02.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: y = xalglib.dfprocess(df, x, y)

</div></pre>
<a name='sub_dfprocessi'></a><h3 class=pageheader><code>dfprocessi</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# 'interactive' variant of DFProcess for languages like Python which support
# constructs like &quot;Y = DFProcessI(DF,X)&quot; and interactive mode of interpreter
# 
# This function allocates new array on each call,  so  it  is  significantly
# slower than its 'non-interactive' counterpart, but it is  more  convenient
# when you call it from command line.
# 
#   -- ALGLIB --
#      Copyright 28.02.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: y = xalglib.dfprocessi(df, x)

</div></pre>
<a name='sub_dfrelclserror'></a><h3 class=pageheader><code>dfrelclserror</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Relative classification error on the test set
# 
# INPUT PARAMETERS:
#     DF      -   decision forest model
#     XY      -   test set
#     NPoints -   test set size
# 
# RESULT:
#     percent of incorrectly classified cases.
#     Zero if model solves regression task.
# 
#   -- ALGLIB --
#      Copyright 16.02.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.dfrelclserror(df, xy, npoints)

</div></pre>
<a name='sub_dfrmserror'></a><h3 class=pageheader><code>dfrmserror</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# RMS error on the test set
# 
# INPUT PARAMETERS:
#     DF      -   decision forest model
#     XY      -   test set
#     NPoints -   test set size
# 
# RESULT:
#     root mean square error.
#     Its meaning for regression task is obvious. As for
#     classification task, RMS error means error when estimating posterior
#     probabilities.
# 
#   -- ALGLIB --
#      Copyright 16.02.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.dfrmserror(df, xy, npoints)

</div></pre>
<a name=unit_elliptic></a><h2 class=pageheader><code>elliptic</code> module</h2>
<div class=pagecontent>
<h3 class=pageheader>Functions</h3>
<a href='#sub_ellipticintegrale' class=toc>ellipticintegrale</a><br>
<a href='#sub_ellipticintegralk' class=toc>ellipticintegralk</a><br>
<a href='#sub_ellipticintegralkhighprecision' class=toc>ellipticintegralkhighprecision</a><br>
<a href='#sub_incompleteellipticintegrale' class=toc>incompleteellipticintegrale</a><br>
<a href='#sub_incompleteellipticintegralk' class=toc>incompleteellipticintegralk</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='sub_ellipticintegrale'></a><h3 class=pageheader><code>ellipticintegrale</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Complete elliptic integral of the second kind
# 
# Approximates the integral
# 
# 
#            pi/2
#             -
#            | |                 2
# E(m)  =    |    sqrt( 1 - m sin t ) dt
#          | |
#           -
#            0
# 
# using the approximation
# 
#      P(x)  -  x log x Q(x).
# 
# ACCURACY:
# 
#                      Relative error:
# arithmetic   domain     # trials      peak         rms
#    IEEE       0, 1       10000       2.1e-16     7.3e-17
# 
# Cephes Math Library, Release 2.8: June, 2000
# Copyright 1984, 1987, 1989, 2000 by Stephen L. Moshier
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.ellipticintegrale(m)

</div></pre>
<a name='sub_ellipticintegralk'></a><h3 class=pageheader><code>ellipticintegralk</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Complete elliptic integral of the first kind
# 
# Approximates the integral
# 
# 
# 
#            pi/2
#             -
#            | |
#            |           dt
# K(m)  =    |    ------------------
#            |                   2
#          | |    sqrt( 1 - m sin t )
#           -
#            0
# 
# using the approximation
# 
#     P(x)  -  log x Q(x).
# 
# ACCURACY:
# 
#                      Relative error:
# arithmetic   domain     # trials      peak         rms
#    IEEE       0,1        30000       2.5e-16     6.8e-17
# 
# Cephes Math Library, Release 2.8:  June, 2000
# Copyright 1984, 1987, 2000 by Stephen L. Moshier
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.ellipticintegralk(m)

</div></pre>
<a name='sub_ellipticintegralkhighprecision'></a><h3 class=pageheader><code>ellipticintegralkhighprecision</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Complete elliptic integral of the first kind
# 
# Approximates the integral
# 
# 
# 
#            pi/2
#             -
#            | |
#            |           dt
# K(m)  =    |    ------------------
#            |                   2
#          | |    sqrt( 1 - m sin t )
#           -
#            0
# 
# where m = 1 - m1, using the approximation
# 
#     P(x)  -  log x Q(x).
# 
# The argument m1 is used rather than m so that the logarithmic
# singularity at m = 1 will be shifted to the origin; this
# preserves maximum accuracy.
# 
# K(0) = pi/2.
# 
# ACCURACY:
# 
#                      Relative error:
# arithmetic   domain     # trials      peak         rms
#    IEEE       0,1        30000       2.5e-16     6.8e-17
# 
#     Cephes
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.ellipticintegralkhighprecision(m1)

</div></pre>
<a name='sub_incompleteellipticintegrale'></a><h3 class=pageheader><code>incompleteellipticintegrale</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Incomplete elliptic integral of the second kind
# 
# Approximates the integral
# 
# 
#                phi
#                 -
#                | |
#                |                   2
# E(phi_\m)  =    |    sqrt( 1 - m sin t ) dt
#                |
#              | |
#               -
#                0
# 
# of amplitude phi and modulus m, using the arithmetic -
# geometric mean algorithm.
# 
# ACCURACY:
# 
# Tested at random arguments with phi in [-10, 10] and m in
# [0, 1].
#                      Relative error:
# arithmetic   domain     # trials      peak         rms
#    IEEE     -10,10      150000       3.3e-15     1.4e-16
# 
# Cephes Math Library Release 2.8:  June, 2000
# Copyright 1984, 1987, 1993, 2000 by Stephen L. Moshier
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.incompleteellipticintegrale(phi, m)

</div></pre>
<a name='sub_incompleteellipticintegralk'></a><h3 class=pageheader><code>incompleteellipticintegralk</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Incomplete elliptic integral of the first kind F(phi|m)
# 
# Approximates the integral
# 
# 
# 
#                phi
#                 -
#                | |
#                |           dt
# F(phi_\m)  =    |    ------------------
#                |                   2
#              | |    sqrt( 1 - m sin t )
#               -
#                0
# 
# of amplitude phi and modulus m, using the arithmetic -
# geometric mean algorithm.
# 
# 
# 
# 
# ACCURACY:
# 
# Tested at random points with m in [0, 1] and phi as indicated.
# 
#                      Relative error:
# arithmetic   domain     # trials      peak         rms
#    IEEE     -10,10       200000      7.4e-16     1.0e-16
# 
# Cephes Math Library Release 2.8:  June, 2000
# Copyright 1984, 1987, 2000 by Stephen L. Moshier
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.incompleteellipticintegralk(phi, m)

</div></pre>
<a name=unit_evd></a><h2 class=pageheader><code>evd</code> module</h2>
<div class=pagecontent>
<h3 class=pageheader>Functions</h3>
<a href='#sub_hmatrixevd' class=toc>hmatrixevd</a><br>
<a href='#sub_hmatrixevdi' class=toc>hmatrixevdi</a><br>
<a href='#sub_hmatrixevdr' class=toc>hmatrixevdr</a><br>
<a href='#sub_rmatrixevd' class=toc>rmatrixevd</a><br>
<a href='#sub_smatrixevd' class=toc>smatrixevd</a><br>
<a href='#sub_smatrixevdi' class=toc>smatrixevdi</a><br>
<a href='#sub_smatrixevdr' class=toc>smatrixevdr</a><br>
<a href='#sub_smatrixtdevd' class=toc>smatrixtdevd</a><br>
<a href='#sub_smatrixtdevdi' class=toc>smatrixtdevdi</a><br>
<a href='#sub_smatrixtdevdr' class=toc>smatrixtdevdr</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='sub_hmatrixevd'></a><h3 class=pageheader><code>hmatrixevd</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Finding the eigenvalues and eigenvectors of a Hermitian matrix
# 
# The algorithm finds eigen pairs of a Hermitian matrix by  reducing  it  to
# real tridiagonal form and using the QL/QR algorithm.
# 
# Input parameters:
#     A       -   Hermitian matrix which is given  by  its  upper  or  lower
#                 triangular part.
#                 Array whose indexes range within [0..N-1, 0..N-1].
#     N       -   size of matrix A.
#     IsUpper -   storage format.
#     ZNeeded -   flag controlling whether the eigenvectors  are  needed  or
#                 not. If ZNeeded is equal to:
#                  * 0, the eigenvectors are not returned;
#                  * 1, the eigenvectors are returned.
# 
# Output parameters:
#     D       -   eigenvalues in ascending order.
#                 Array whose index ranges within [0..N-1].
#     Z       -   if ZNeeded is equal to:
#                  * 0, Z hasnt changed;
#                  * 1, Z contains the eigenvectors.
#                 Array whose indexes range within [0..N-1, 0..N-1].
#                 The eigenvectors are stored in the matrix columns.
# 
# Result:
#     True, if the algorithm has converged.
#     False, if the algorithm hasn't converged (rare case).
# 
# Note:
#     eigenvectors of Hermitian matrix are defined up to  multiplication  by
#     a complex number L, such that |L|=1.
# 
#   -- ALGLIB --
#      Copyright 2005, 23 March 2007 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result, d, z = xalglib.hmatrixevd(a, n, zneeded, isupper)

</div></pre>
<a name='sub_hmatrixevdi'></a><h3 class=pageheader><code>hmatrixevdi</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Subroutine for finding the eigenvalues and  eigenvectors  of  a  Hermitian
# matrix with given indexes by using bisection and inverse iteration methods
# 
# Input parameters:
#     A       -   Hermitian matrix which is given  by  its  upper  or  lower
#                 triangular part.
#                 Array whose indexes range within [0..N-1, 0..N-1].
#     N       -   size of matrix A.
#     ZNeeded -   flag controlling whether the eigenvectors  are  needed  or
#                 not. If ZNeeded is equal to:
#                  * 0, the eigenvectors are not returned;
#                  * 1, the eigenvectors are returned.
#     IsUpperA -  storage format of matrix A.
#     I1, I2 -    index interval for searching (from I1 to I2).
#                 0 &lt;= I1 &lt;= I2 &lt;= N-1.
# 
# Output parameters:
#     W       -   array of the eigenvalues found.
#                 Array whose index ranges within [0..I2-I1].
#     Z       -   if ZNeeded is equal to:
#                  * 0, Z hasnt changed;
#                  * 1, Z contains eigenvectors.
#                 Array whose indexes range within [0..N-1, 0..I2-I1].
#                 In  that  case,  the eigenvectors are stored in the matrix
#                 columns.
# 
# Result:
#     True, if successful. W contains the eigenvalues, Z contains the
#     eigenvectors (if needed).
# 
#     False, if the bisection method subroutine  wasn't  able  to  find  the
#     eigenvalues  in  the  given  interval  or  if  the  inverse  iteration
#     subroutine wasn't able to find  all  the  corresponding  eigenvectors.
#     In that case, the eigenvalues and eigenvectors are not returned.
# 
# Note:
#     eigen vectors of Hermitian matrix are defined up to multiplication  by
#     a complex number L, such as |L|=1.
# 
#   -- ALGLIB --
#      Copyright 07.01.2006, 24.03.2007 by Bochkanov Sergey.
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result, w, z = xalglib.hmatrixevdi(a, n, zneeded, isupper, i1, i2)

</div></pre>
<a name='sub_hmatrixevdr'></a><h3 class=pageheader><code>hmatrixevdr</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Subroutine for finding the eigenvalues (and eigenvectors) of  a  Hermitian
# matrix  in  a  given half-interval (A, B] by using a bisection and inverse
# iteration
# 
# Input parameters:
#     A       -   Hermitian matrix which is given  by  its  upper  or  lower
#                 triangular  part.  Array  whose   indexes   range   within
#                 [0..N-1, 0..N-1].
#     N       -   size of matrix A.
#     ZNeeded -   flag controlling whether the eigenvectors  are  needed  or
#                 not. If ZNeeded is equal to:
#                  * 0, the eigenvectors are not returned;
#                  * 1, the eigenvectors are returned.
#     IsUpperA -  storage format of matrix A.
#     B1, B2 -    half-interval (B1, B2] to search eigenvalues in.
# 
# Output parameters:
#     M       -   number of eigenvalues found in a given half-interval, M&gt;=0
#     W       -   array of the eigenvalues found.
#                 Array whose index ranges within [0..M-1].
#     Z       -   if ZNeeded is equal to:
#                  * 0, Z hasnt changed;
#                  * 1, Z contains eigenvectors.
#                 Array whose indexes range within [0..N-1, 0..M-1].
#                 The eigenvectors are stored in the matrix columns.
# 
# Result:
#     True, if successful. M contains the number of eigenvalues in the given
#     half-interval (could be equal to 0), W contains the eigenvalues,
#     Z contains the eigenvectors (if needed).
# 
#     False, if the bisection method subroutine  wasn't  able  to  find  the
#     eigenvalues  in  the  given  interval  or  if  the  inverse  iteration
#     subroutine  wasn't  able  to  find all the corresponding eigenvectors.
#     In that case, the eigenvalues and eigenvectors are not returned, M  is
#     equal to 0.
# 
# Note:
#     eigen vectors of Hermitian matrix are defined up to multiplication  by
#     a complex number L, such as |L|=1.
# 
#   -- ALGLIB --
#      Copyright 07.01.2006, 24.03.2007 by Bochkanov Sergey.
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result, m, w, z = xalglib.hmatrixevdr(a, n, zneeded, isupper, b1, b2)

</div></pre>
<a name='sub_rmatrixevd'></a><h3 class=pageheader><code>rmatrixevd</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Finding eigenvalues and eigenvectors of a general matrix
# 
# The algorithm finds eigenvalues and eigenvectors of a general matrix by
# using the QR algorithm with multiple shifts. The algorithm can find
# eigenvalues and both left and right eigenvectors.
# 
# The right eigenvector is a vector x such that A*x = w*x, and the left
# eigenvector is a vector y such that y'*A = w*y' (here y' implies a complex
# conjugate transposition of vector y).
# 
# Input parameters:
#     A       -   matrix. Array whose indexes range within [0..N-1, 0..N-1].
#     N       -   size of matrix A.
#     VNeeded -   flag controlling whether eigenvectors are needed or not.
#                 If VNeeded is equal to:
#                  * 0, eigenvectors are not returned;
#                  * 1, right eigenvectors are returned;
#                  * 2, left eigenvectors are returned;
#                  * 3, both left and right eigenvectors are returned.
# 
# Output parameters:
#     WR      -   real parts of eigenvalues.
#                 Array whose index ranges within [0..N-1].
#     WR      -   imaginary parts of eigenvalues.
#                 Array whose index ranges within [0..N-1].
#     VL, VR  -   arrays of left and right eigenvectors (if they are needed).
#                 If WI[i]=0, the respective eigenvalue is a real number,
#                 and it corresponds to the column number I of matrices VL/VR.
#                 If WI[i]&gt;0, we have a pair of complex conjugate numbers with
#                 positive and negative imaginary parts:
#                     the first eigenvalue WR[i] + sqrt(-1)*WI[i];
#                     the second eigenvalue WR[i+1] + sqrt(-1)*WI[i+1];
#                     WI[i]&gt;0
#                     WI[i+1] = -WI[i] &lt; 0
#                 In that case, the eigenvector  corresponding to the first
#                 eigenvalue is located in i and i+1 columns of matrices
#                 VL/VR (the column number i contains the real part, and the
#                 column number i+1 contains the imaginary part), and the vector
#                 corresponding to the second eigenvalue is a complex conjugate to
#                 the first vector.
#                 Arrays whose indexes range within [0..N-1, 0..N-1].
# 
# Result:
#     True, if the algorithm has converged.
#     False, if the algorithm has not converged.
# 
# Note 1:
#     Some users may ask the following question: what if WI[N-1]&gt;0?
#     WI[N] must contain an eigenvalue which is complex conjugate to the
#     N-th eigenvalue, but the array has only size N?
#     The answer is as follows: such a situation cannot occur because the
#     algorithm finds a pairs of eigenvalues, therefore, if WI[i]&gt;0, I is
#     strictly less than N-1.
# 
# Note 2:
#     The algorithm performance depends on the value of the internal parameter
#     NS of the InternalSchurDecomposition subroutine which defines the number
#     of shifts in the QR algorithm (similarly to the block width in block-matrix
#     algorithms of linear algebra). If you require maximum performance
#     on your machine, it is recommended to adjust this parameter manually.
# 
# 
# See also the InternalTREVC subroutine.
# 
# The algorithm is based on the LAPACK 3.0 library.
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result, wr, wi, vl, vr = xalglib.rmatrixevd(a, n, vneeded)

</div></pre>
<a name='sub_smatrixevd'></a><h3 class=pageheader><code>smatrixevd</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Finding the eigenvalues and eigenvectors of a symmetric matrix
# 
# The algorithm finds eigen pairs of a symmetric matrix by reducing it to
# tridiagonal form and using the QL/QR algorithm.
# 
# Input parameters:
#     A       -   symmetric matrix which is given by its upper or lower
#                 triangular part.
#                 Array whose indexes range within [0..N-1, 0..N-1].
#     N       -   size of matrix A.
#     ZNeeded -   flag controlling whether the eigenvectors are needed or not.
#                 If ZNeeded is equal to:
#                  * 0, the eigenvectors are not returned;
#                  * 1, the eigenvectors are returned.
#     IsUpper -   storage format.
# 
# Output parameters:
#     D       -   eigenvalues in ascending order.
#                 Array whose index ranges within [0..N-1].
#     Z       -   if ZNeeded is equal to:
#                  * 0, Z hasnt changed;
#                  * 1, Z contains the eigenvectors.
#                 Array whose indexes range within [0..N-1, 0..N-1].
#                 The eigenvectors are stored in the matrix columns.
# 
# Result:
#     True, if the algorithm has converged.
#     False, if the algorithm hasn't converged (rare case).
# 
#   -- ALGLIB --
#      Copyright 2005-2008 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result, d, z = xalglib.smatrixevd(a, n, zneeded, isupper)

</div></pre>
<a name='sub_smatrixevdi'></a><h3 class=pageheader><code>smatrixevdi</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Subroutine for finding the eigenvalues and  eigenvectors  of  a  symmetric
# matrix with given indexes by using bisection and inverse iteration methods.
# 
# Input parameters:
#     A       -   symmetric matrix which is given by its upper or lower
#                 triangular part. Array whose indexes range within [0..N-1, 0..N-1].
#     N       -   size of matrix A.
#     ZNeeded -   flag controlling whether the eigenvectors are needed or not.
#                 If ZNeeded is equal to:
#                  * 0, the eigenvectors are not returned;
#                  * 1, the eigenvectors are returned.
#     IsUpperA -  storage format of matrix A.
#     I1, I2 -    index interval for searching (from I1 to I2).
#                 0 &lt;= I1 &lt;= I2 &lt;= N-1.
# 
# Output parameters:
#     W       -   array of the eigenvalues found.
#                 Array whose index ranges within [0..I2-I1].
#     Z       -   if ZNeeded is equal to:
#                  * 0, Z hasnt changed;
#                  * 1, Z contains eigenvectors.
#                 Array whose indexes range within [0..N-1, 0..I2-I1].
#                 In that case, the eigenvectors are stored in the matrix columns.
# 
# Result:
#     True, if successful. W contains the eigenvalues, Z contains the
#     eigenvectors (if needed).
# 
#     False, if the bisection method subroutine wasn't able to find the
#     eigenvalues in the given interval or if the inverse iteration subroutine
#     wasn't able to find all the corresponding eigenvectors.
#     In that case, the eigenvalues and eigenvectors are not returned.
# 
#   -- ALGLIB --
#      Copyright 07.01.2006 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result, w, z = xalglib.smatrixevdi(a, n, zneeded, isupper, i1, i2)

</div></pre>
<a name='sub_smatrixevdr'></a><h3 class=pageheader><code>smatrixevdr</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Subroutine for finding the eigenvalues (and eigenvectors) of  a  symmetric
# matrix  in  a  given half open interval (A, B] by using  a  bisection  and
# inverse iteration
# 
# Input parameters:
#     A       -   symmetric matrix which is given by its upper or lower
#                 triangular part. Array [0..N-1, 0..N-1].
#     N       -   size of matrix A.
#     ZNeeded -   flag controlling whether the eigenvectors are needed or not.
#                 If ZNeeded is equal to:
#                  * 0, the eigenvectors are not returned;
#                  * 1, the eigenvectors are returned.
#     IsUpperA -  storage format of matrix A.
#     B1, B2 -    half open interval (B1, B2] to search eigenvalues in.
# 
# Output parameters:
#     M       -   number of eigenvalues found in a given half-interval (M&gt;=0).
#     W       -   array of the eigenvalues found.
#                 Array whose index ranges within [0..M-1].
#     Z       -   if ZNeeded is equal to:
#                  * 0, Z hasnt changed;
#                  * 1, Z contains eigenvectors.
#                 Array whose indexes range within [0..N-1, 0..M-1].
#                 The eigenvectors are stored in the matrix columns.
# 
# Result:
#     True, if successful. M contains the number of eigenvalues in the given
#     half-interval (could be equal to 0), W contains the eigenvalues,
#     Z contains the eigenvectors (if needed).
# 
#     False, if the bisection method subroutine wasn't able to find the
#     eigenvalues in the given interval or if the inverse iteration subroutine
#     wasn't able to find all the corresponding eigenvectors.
#     In that case, the eigenvalues and eigenvectors are not returned,
#     M is equal to 0.
# 
#   -- ALGLIB --
#      Copyright 07.01.2006 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result, m, w, z = xalglib.smatrixevdr(a, n, zneeded, isupper, b1, b2)

</div></pre>
<a name='sub_smatrixtdevd'></a><h3 class=pageheader><code>smatrixtdevd</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Finding the eigenvalues and eigenvectors of a tridiagonal symmetric matrix
# 
# The algorithm finds the eigen pairs of a tridiagonal symmetric matrix by
# using an QL/QR algorithm with implicit shifts.
# 
# Input parameters:
#     D       -   the main diagonal of a tridiagonal matrix.
#                 Array whose index ranges within [0..N-1].
#     E       -   the secondary diagonal of a tridiagonal matrix.
#                 Array whose index ranges within [0..N-2].
#     N       -   size of matrix A.
#     ZNeeded -   flag controlling whether the eigenvectors are needed or not.
#                 If ZNeeded is equal to:
#                  * 0, the eigenvectors are not needed;
#                  * 1, the eigenvectors of a tridiagonal matrix
#                    are multiplied by the square matrix Z. It is used if the
#                    tridiagonal matrix is obtained by the similarity
#                    transformation of a symmetric matrix;
#                  * 2, the eigenvectors of a tridiagonal matrix replace the
#                    square matrix Z;
#                  * 3, matrix Z contains the first row of the eigenvectors
#                    matrix.
#     Z       -   if ZNeeded=1, Z contains the square matrix by which the
#                 eigenvectors are multiplied.
#                 Array whose indexes range within [0..N-1, 0..N-1].
# 
# Output parameters:
#     D       -   eigenvalues in ascending order.
#                 Array whose index ranges within [0..N-1].
#     Z       -   if ZNeeded is equal to:
#                  * 0, Z hasnt changed;
#                  * 1, Z contains the product of a given matrix (from the left)
#                    and the eigenvectors matrix (from the right);
#                  * 2, Z contains the eigenvectors.
#                  * 3, Z contains the first row of the eigenvectors matrix.
#                 If ZNeeded&lt;3, Z is the array whose indexes range within [0..N-1, 0..N-1].
#                 In that case, the eigenvectors are stored in the matrix columns.
#                 If ZNeeded=3, Z is the array whose indexes range within [0..0, 0..N-1].
# 
# Result:
#     True, if the algorithm has converged.
#     False, if the algorithm hasn't converged.
# 
#   -- LAPACK routine (version 3.0) --
#      Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
#      Courant Institute, Argonne National Lab, and Rice University
#      September 30, 1994
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result, d, z = xalglib.smatrixtdevd(d, e, n, zneeded, z)

</div></pre>
<a name='sub_smatrixtdevdi'></a><h3 class=pageheader><code>smatrixtdevdi</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Subroutine for finding tridiagonal matrix eigenvalues/vectors with given
# indexes (in ascending order) by using the bisection and inverse iteraion.
# 
# Input parameters:
#     D       -   the main diagonal of a tridiagonal matrix.
#                 Array whose index ranges within [0..N-1].
#     E       -   the secondary diagonal of a tridiagonal matrix.
#                 Array whose index ranges within [0..N-2].
#     N       -   size of matrix. N&gt;=0.
#     ZNeeded -   flag controlling whether the eigenvectors are needed or not.
#                 If ZNeeded is equal to:
#                  * 0, the eigenvectors are not needed;
#                  * 1, the eigenvectors of a tridiagonal matrix are multiplied
#                    by the square matrix Z. It is used if the
#                    tridiagonal matrix is obtained by the similarity transformation
#                    of a symmetric matrix.
#                  * 2, the eigenvectors of a tridiagonal matrix replace
#                    matrix Z.
#     I1, I2  -   index interval for searching (from I1 to I2).
#                 0 &lt;= I1 &lt;= I2 &lt;= N-1.
#     Z       -   if ZNeeded is equal to:
#                  * 0, Z isn't used and remains unchanged;
#                  * 1, Z contains the square matrix (array whose indexes range within [0..N-1, 0..N-1])
#                    which reduces the given symmetric matrix to  tridiagonal form;
#                  * 2, Z isn't used (but changed on the exit).
# 
# Output parameters:
#     D       -   array of the eigenvalues found.
#                 Array whose index ranges within [0..I2-I1].
#     Z       -   if ZNeeded is equal to:
#                  * 0, doesn't contain any information;
#                  * 1, contains the product of a given NxN matrix Z (from the left) and
#                    Nx(I2-I1) matrix of the eigenvectors found (from the right).
#                    Array whose indexes range within [0..N-1, 0..I2-I1].
#                  * 2, contains the matrix of the eigenvalues found.
#                    Array whose indexes range within [0..N-1, 0..I2-I1].
# 
# 
# Result:
# 
#     True, if successful. In that case, D contains the eigenvalues,
#     Z contains the eigenvectors (if needed).
#     It should be noted that the subroutine changes the size of arrays D and Z.
# 
#     False, if the bisection method subroutine wasn't able to find the eigenvalues
#     in the given interval or if the inverse iteration subroutine wasn't able
#     to find all the corresponding eigenvectors. In that case, the eigenvalues
#     and eigenvectors are not returned.
# 
#   -- ALGLIB --
#      Copyright 25.12.2005 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result, d, z = xalglib.smatrixtdevdi(d, e, n, zneeded, i1, i2, z)

</div></pre>
<a name='sub_smatrixtdevdr'></a><h3 class=pageheader><code>smatrixtdevdr</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Subroutine for finding the tridiagonal matrix eigenvalues/vectors in a
# given half-interval (A, B] by using bisection and inverse iteration.
# 
# Input parameters:
#     D       -   the main diagonal of a tridiagonal matrix.
#                 Array whose index ranges within [0..N-1].
#     E       -   the secondary diagonal of a tridiagonal matrix.
#                 Array whose index ranges within [0..N-2].
#     N       -   size of matrix, N&gt;=0.
#     ZNeeded -   flag controlling whether the eigenvectors are needed or not.
#                 If ZNeeded is equal to:
#                  * 0, the eigenvectors are not needed;
#                  * 1, the eigenvectors of a tridiagonal matrix are multiplied
#                    by the square matrix Z. It is used if the tridiagonal
#                    matrix is obtained by the similarity transformation
#                    of a symmetric matrix.
#                  * 2, the eigenvectors of a tridiagonal matrix replace matrix Z.
#     A, B    -   half-interval (A, B] to search eigenvalues in.
#     Z       -   if ZNeeded is equal to:
#                  * 0, Z isn't used and remains unchanged;
#                  * 1, Z contains the square matrix (array whose indexes range
#                    within [0..N-1, 0..N-1]) which reduces the given symmetric
#                    matrix to tridiagonal form;
#                  * 2, Z isn't used (but changed on the exit).
# 
# Output parameters:
#     D       -   array of the eigenvalues found.
#                 Array whose index ranges within [0..M-1].
#     M       -   number of eigenvalues found in the given half-interval (M&gt;=0).
#     Z       -   if ZNeeded is equal to:
#                  * 0, doesn't contain any information;
#                  * 1, contains the product of a given NxN matrix Z (from the
#                    left) and NxM matrix of the eigenvectors found (from the
#                    right). Array whose indexes range within [0..N-1, 0..M-1].
#                  * 2, contains the matrix of the eigenvectors found.
#                    Array whose indexes range within [0..N-1, 0..M-1].
# 
# Result:
# 
#     True, if successful. In that case, M contains the number of eigenvalues
#     in the given half-interval (could be equal to 0), D contains the eigenvalues,
#     Z contains the eigenvectors (if needed).
#     It should be noted that the subroutine changes the size of arrays D and Z.
# 
#     False, if the bisection method subroutine wasn't able to find the
#     eigenvalues in the given interval or if the inverse iteration subroutine
#     wasn't able to find all the corresponding eigenvectors. In that case,
#     the eigenvalues and eigenvectors are not returned, M is equal to 0.
# 
#   -- ALGLIB --
#      Copyright 31.03.2008 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result, d, m, z = xalglib.smatrixtdevdr(d, e, n, zneeded, a, b, z)

</div></pre>
<a name=unit_expintegrals></a><h2 class=pageheader><code>expintegrals</code> module</h2>
<div class=pagecontent>
<h3 class=pageheader>Functions</h3>
<a href='#sub_exponentialintegralei' class=toc>exponentialintegralei</a><br>
<a href='#sub_exponentialintegralen' class=toc>exponentialintegralen</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='sub_exponentialintegralei'></a><h3 class=pageheader><code>exponentialintegralei</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Exponential integral Ei(x)
# 
#               x
#                -     t
#               | |   e
#    Ei(x) =   -|-   ---  dt .
#             | |     t
#              -
#             -inf
# 
# Not defined for x &lt;= 0.
# See also expn.c.
# 
# 
# 
# ACCURACY:
# 
#                      Relative error:
# arithmetic   domain     # trials      peak         rms
#    IEEE       0,100       50000      8.6e-16     1.3e-16
# 
# Cephes Math Library Release 2.8:  May, 1999
# Copyright 1999 by Stephen L. Moshier
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.exponentialintegralei(x)

</div></pre>
<a name='sub_exponentialintegralen'></a><h3 class=pageheader><code>exponentialintegralen</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Exponential integral En(x)
# 
# Evaluates the exponential integral
# 
#                 inf.
#                   -
#                  | |   -xt
#                  |    e
#      E (x)  =    |    ----  dt.
#       n          |      n
#                | |     t
#                 -
#                  1
# 
# 
# Both n and x must be nonnegative.
# 
# The routine employs either a power series, a continued
# fraction, or an asymptotic formula depending on the
# relative values of n and x.
# 
# ACCURACY:
# 
#                      Relative error:
# arithmetic   domain     # trials      peak         rms
#    IEEE      0, 30       10000       1.7e-15     3.6e-16
# 
# Cephes Math Library Release 2.8:  June, 2000
# Copyright 1985, 2000 by Stephen L. Moshier
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.exponentialintegralen(x, n)

</div></pre>
<a name=unit_fdistr></a><h2 class=pageheader><code>fdistr</code> module</h2>
<div class=pagecontent>
<h3 class=pageheader>Functions</h3>
<a href='#sub_fcdistribution' class=toc>fcdistribution</a><br>
<a href='#sub_fdistribution' class=toc>fdistribution</a><br>
<a href='#sub_invfdistribution' class=toc>invfdistribution</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='sub_fcdistribution'></a><h3 class=pageheader><code>fcdistribution</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Complemented F distribution
# 
# Returns the area from x to infinity under the F density
# function (also known as Snedcor's density or the
# variance ratio density).
# 
# 
#                      inf.
#                       -
#              1       | |  a-1      b-1
# 1-P(x)  =  ------    |   t    (1-t)    dt
#            B(a,b)  | |
#                     -
#                      x
# 
# 
# The incomplete beta integral is used, according to the
# formula
# 
# P(x) = incbet( df2/2, df1/2, (df2/(df2 + df1*x) ).
# 
# 
# ACCURACY:
# 
# Tested at random points (a,b,x) in the indicated intervals.
#                x     a,b                     Relative error:
# arithmetic  domain  domain     # trials      peak         rms
#    IEEE      0,1    1,100       100000      3.7e-14     5.9e-16
#    IEEE      1,5    1,100       100000      8.0e-15     1.6e-15
#    IEEE      0,1    1,10000     100000      1.8e-11     3.5e-13
#    IEEE      1,5    1,10000     100000      2.0e-11     3.0e-12
# 
# Cephes Math Library Release 2.8:  June, 2000
# Copyright 1984, 1987, 1995, 2000 by Stephen L. Moshier
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.fcdistribution(a, b, x)

</div></pre>
<a name='sub_fdistribution'></a><h3 class=pageheader><code>fdistribution</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# F distribution
# 
# Returns the area from zero to x under the F density
# function (also known as Snedcor's density or the
# variance ratio density).  This is the density
# of x = (u1/df1)/(u2/df2), where u1 and u2 are random
# variables having Chi square distributions with df1
# and df2 degrees of freedom, respectively.
# The incomplete beta integral is used, according to the
# formula
# 
# P(x) = incbet( df1/2, df2/2, (df1*x/(df2 + df1*x) ).
# 
# 
# The arguments a and b are greater than zero, and x is
# nonnegative.
# 
# ACCURACY:
# 
# Tested at random points (a,b,x).
# 
#                x     a,b                     Relative error:
# arithmetic  domain  domain     # trials      peak         rms
#    IEEE      0,1    0,100       100000      9.8e-15     1.7e-15
#    IEEE      1,5    0,100       100000      6.5e-15     3.5e-16
#    IEEE      0,1    1,10000     100000      2.2e-11     3.3e-12
#    IEEE      1,5    1,10000     100000      1.1e-11     1.7e-13
# 
# Cephes Math Library Release 2.8:  June, 2000
# Copyright 1984, 1987, 1995, 2000 by Stephen L. Moshier
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.fdistribution(a, b, x)

</div></pre>
<a name='sub_invfdistribution'></a><h3 class=pageheader><code>invfdistribution</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Inverse of complemented F distribution
# 
# Finds the F density argument x such that the integral
# from x to infinity of the F density is equal to the
# given probability p.
# 
# This is accomplished using the inverse beta integral
# function and the relations
# 
#      z = incbi( df2/2, df1/2, p )
#      x = df2 (1-z) / (df1 z).
# 
# Note: the following relations hold for the inverse of
# the uncomplemented F distribution:
# 
#      z = incbi( df1/2, df2/2, p )
#      x = df2 z / (df1 (1-z)).
# 
# ACCURACY:
# 
# Tested at random points (a,b,p).
# 
#              a,b                     Relative error:
# arithmetic  domain     # trials      peak         rms
#  For p between .001 and 1:
#    IEEE     1,100       100000      8.3e-15     4.7e-16
#    IEEE     1,10000     100000      2.1e-11     1.4e-13
#  For p between 10^-6 and 10^-3:
#    IEEE     1,100        50000      1.3e-12     8.4e-15
#    IEEE     1,10000      50000      3.0e-12     4.8e-14
# 
# Cephes Math Library Release 2.8:  June, 2000
# Copyright 1984, 1987, 1995, 2000 by Stephen L. Moshier
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.invfdistribution(a, b, y)

</div></pre>
<a name=unit_fft></a><h2 class=pageheader><code>fft</code> module</h2>
<div class=pagecontent>
<h3 class=pageheader>Functions</h3>
<a href='#sub_fftc1d' class=toc>fftc1d</a><br>
<a href='#sub_fftc1dinv' class=toc>fftc1dinv</a><br>
<a href='#sub_fftr1d' class=toc>fftr1d</a><br>
<a href='#sub_fftr1dinv' class=toc>fftr1dinv</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
<tr align=left valign=top><td><a href='#example_fft_complex_d1' class=toc>fft_complex_d1</a></td><td width=15>&nbsp;</td><td>Complex FFT: simple example</td></tr>
<tr align=left valign=top><td><a href='#example_fft_complex_d2' class=toc>fft_complex_d2</a></td><td width=15>&nbsp;</td><td>Complex FFT: advanced example</td></tr>
<tr align=left valign=top><td><a href='#example_fft_real_d1' class=toc>fft_real_d1</a></td><td width=15>&nbsp;</td><td>Real FFT: simple example</td></tr>
<tr align=left valign=top><td><a href='#example_fft_real_d2' class=toc>fft_real_d2</a></td><td width=15>&nbsp;</td><td>Real FFT: advanced example</td></tr>
</table></div>
<a name='sub_fftc1d'></a><h3 class=pageheader><code>fftc1d</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# 1-dimensional complex FFT.
# 
# Array size N may be arbitrary number (composite or prime).  Composite  N's
# are handled with cache-oblivious variation of  a  Cooley-Tukey  algorithm.
# Small prime-factors are transformed using hard coded  codelets (similar to
# FFTW codelets, but without low-level  optimization),  large  prime-factors
# are handled with Bluestein's algorithm.
# 
# Fastests transforms are for smooth N's (prime factors are 2, 3,  5  only),
# most fast for powers of 2. When N have prime factors  larger  than  these,
# but orders of magnitude smaller than N, computations will be about 4 times
# slower than for nearby highly composite N's. When N itself is prime, speed
# will be 6 times lower.
# 
# Algorithm has O(N*logN) complexity for any N (composite or prime).
# 
# INPUT PARAMETERS
#     A   -   array[0..N-1] - complex function to be transformed
#     N   -   problem size
# 
# OUTPUT PARAMETERS
#     A   -   DFT of a input array, array[0..N-1]
#             A_out[j] = SUM(A_in[k]*exp(-2*pi*sqrt(-1)*j*k/N), k = 0..N-1)
# 
# 
#   -- ALGLIB --
#      Copyright 29.05.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: a = xalglib.fftc1d(a, n)
SYNTAX: a = xalglib.fftc1d(a)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_fft_complex_d1' class=nav>[1]</a>&nbsp;&nbsp;<a href='#example_fft_complex_d2' class=nav>[2]</a>&nbsp;&nbsp;</p>
<a name='sub_fftc1dinv'></a><h3 class=pageheader><code>fftc1dinv</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# 1-dimensional complex inverse FFT.
# 
# Array size N may be arbitrary number (composite or prime).  Algorithm  has
# O(N*logN) complexity for any N (composite or prime).
# 
# See FFTC1D() description for more information about algorithm performance.
# 
# INPUT PARAMETERS
#     A   -   array[0..N-1] - complex array to be transformed
#     N   -   problem size
# 
# OUTPUT PARAMETERS
#     A   -   inverse DFT of a input array, array[0..N-1]
#             A_out[j] = SUM(A_in[k]/N*exp(+2*pi*sqrt(-1)*j*k/N), k = 0..N-1)
# 
# 
#   -- ALGLIB --
#      Copyright 29.05.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: a = xalglib.fftc1dinv(a, n)
SYNTAX: a = xalglib.fftc1dinv(a)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_fft_complex_d1' class=nav>[1]</a>&nbsp;&nbsp;<a href='#example_fft_complex_d2' class=nav>[2]</a>&nbsp;&nbsp;</p>
<a name='sub_fftr1d'></a><h3 class=pageheader><code>fftr1d</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# 1-dimensional real FFT.
# 
# Algorithm has O(N*logN) complexity for any N (composite or prime).
# 
# INPUT PARAMETERS
#     A   -   array[0..N-1] - real function to be transformed
#     N   -   problem size
# 
# OUTPUT PARAMETERS
#     F   -   DFT of a input array, array[0..N-1]
#             F[j] = SUM(A[k]*exp(-2*pi*sqrt(-1)*j*k/N), k = 0..N-1)
# 
# NOTE:
#     F[] satisfies symmetry property F[k] = conj(F[N-k]),  so just one half
# of  array  is  usually needed. But for convinience subroutine returns full
# complex array (with frequencies above N/2), so its result may be  used  by
# other FFT-related subroutines.
# 
# 
#   -- ALGLIB --
#      Copyright 01.06.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: f = xalglib.fftr1d(a, n)
SYNTAX: f = xalglib.fftr1d(a)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_fft_real_d1' class=nav>[1]</a>&nbsp;&nbsp;<a href='#example_fft_real_d2' class=nav>[2]</a>&nbsp;&nbsp;</p>
<a name='sub_fftr1dinv'></a><h3 class=pageheader><code>fftr1dinv</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# 1-dimensional real inverse FFT.
# 
# Algorithm has O(N*logN) complexity for any N (composite or prime).
# 
# INPUT PARAMETERS
#     F   -   array[0..floor(N/2)] - frequencies from forward real FFT
#     N   -   problem size
# 
# OUTPUT PARAMETERS
#     A   -   inverse DFT of a input array, array[0..N-1]
# 
# NOTE:
#     F[] should satisfy symmetry property F[k] = conj(F[N-k]), so just  one
# half of frequencies array is needed - elements from 0 to floor(N/2).  F[0]
# is ALWAYS real. If N is even F[floor(N/2)] is real too. If N is odd,  then
# F[floor(N/2)] has no special properties.
# 
# Relying on properties noted above, FFTR1DInv subroutine uses only elements
# from 0th to floor(N/2)-th. It ignores imaginary part of F[0],  and in case
# N is even it ignores imaginary part of F[floor(N/2)] too.
# 
# When you call this function using full arguments list - &quot;FFTR1DInv(F,N,A)&quot;
# - you can pass either either frequencies array with N elements or  reduced
# array with roughly N/2 elements - subroutine will  successfully  transform
# both.
# 
# If you call this function using reduced arguments list -  &quot;FFTR1DInv(F,A)&quot;
# - you must pass FULL array with N elements (although higher  N/2 are still
# not used) because array size is used to automatically determine FFT length
# 
# 
#   -- ALGLIB --
#      Copyright 01.06.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: a = xalglib.fftr1dinv(f, n)
SYNTAX: a = xalglib.fftr1dinv(f)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_fft_real_d1' class=nav>[1]</a>&nbsp;&nbsp;<a href='#example_fft_real_d2' class=nav>[2]</a>&nbsp;&nbsp;</p>
<a name='example_fft_complex_d1'></a><h3 class=pageheader>fft_complex_d1 example</h3>
<pre class=source>
import xalglib



<font color=darkcyan>#</font>
<font color=darkcyan># first we demonstrate forward FFT:</font>
<font color=darkcyan># [1i,1i,1i,1i] is converted to [4i, 0, 0, 0]</font>
<font color=darkcyan>#</font>
z = [1j,1j,1j,1j]
z = xalglib.fftc1d(z)
print(z) <font color=darkcyan># expected [4j,0,0,0]</font>

<font color=darkcyan>#</font>
<font color=darkcyan># now we convert [4i, 0, 0, 0] back to [1i,1i,1i,1i]</font>
<font color=darkcyan># with backward FFT</font>
<font color=darkcyan>#</font>
z = xalglib.fftc1dinv(z)
print(z) <font color=darkcyan># expected [1j,1j,1j,1j]</font>


</pre><a name='example_fft_complex_d2'></a><h3 class=pageheader>fft_complex_d2 example</h3>
<pre class=source>
import xalglib



<font color=darkcyan>#</font>
<font color=darkcyan># first we demonstrate forward FFT:</font>
<font color=darkcyan># [0,1,0,1i] is converted to [1+1i, -1-1i, -1-1i, 1+1i]</font>
<font color=darkcyan>#</font>
z = [0,1,0,1j]
z = xalglib.fftc1d(z)
print(z) <font color=darkcyan># expected [1+1j, -1-1j, -1-1j, 1+1j]</font>

<font color=darkcyan>#</font>
<font color=darkcyan># now we convert result back with backward FFT</font>
<font color=darkcyan>#</font>
z = xalglib.fftc1dinv(z)
print(z) <font color=darkcyan># expected [0,1,0,1j]</font>


</pre><a name='example_fft_real_d1'></a><h3 class=pageheader>fft_real_d1 example</h3>
<pre class=source>
import xalglib



<font color=darkcyan>#</font>
<font color=darkcyan># first we demonstrate forward FFT:</font>
<font color=darkcyan># [1,1,1,1] is converted to [4, 0, 0, 0]</font>
<font color=darkcyan>#</font>
x = [1,1,1,1]
f = xalglib.fftr1d(x)
print(f) <font color=darkcyan># expected [4,0,0,0]</font>

<font color=darkcyan>#</font>
<font color=darkcyan># now we convert [4, 0, 0, 0] back to [1,1,1,1]</font>
<font color=darkcyan># with backward FFT</font>
<font color=darkcyan>#</font>
x2 = xalglib.fftr1dinv(f)
print(x2) <font color=darkcyan># expected [1,1,1,1]</font>


</pre><a name='example_fft_real_d2'></a><h3 class=pageheader>fft_real_d2 example</h3>
<pre class=source>
import xalglib



<font color=darkcyan>#</font>
<font color=darkcyan># first we demonstrate forward FFT:</font>
<font color=darkcyan># [1,2,3,4] is converted to [10, -2+2i, -2, -2-2i]</font>
<font color=darkcyan>#</font>
<font color=darkcyan># note that output array is self-adjoint:</font>
<font color=darkcyan># * f[0] = conj(f[0])</font>
<font color=darkcyan># * f[1] = conj(f[3])</font>
<font color=darkcyan># * f[2] = conj(f[2])</font>
<font color=darkcyan>#</font>
x = [1,2,3,4]
f = xalglib.fftr1d(x)
print(f) <font color=darkcyan># expected [10, -2+2j, -2, -2-2j]</font>

<font color=darkcyan>#</font>
<font color=darkcyan># now we convert [10, -2+2i, -2, -2-2i] back to [1,2,3,4]</font>
<font color=darkcyan>#</font>
x2 = xalglib.fftr1dinv(f)
print(x2) <font color=darkcyan># expected [1,2,3,4]</font>

<font color=darkcyan>#</font>
<font color=darkcyan># remember that F is self-adjoint? It means that we can pass just half</font>
<font color=darkcyan># (slightly larger than half) of F to inverse real FFT and still get our result.</font>
<font color=darkcyan>#</font>
<font color=darkcyan># I.e. instead [10, -2+2i, -2, -2-2i] we pass just [10, -2+2i, -2] and everything works!</font>
<font color=darkcyan>#</font>
<font color=darkcyan># NOTE: in this case we should explicitly pass array length (which is 4) to ALGLIB;</font>
<font color=darkcyan># <b>if</b> not, it will automatically use array length to determine FFT size and</font>
<font color=darkcyan># will erroneously make half-length FFT.</font>
<font color=darkcyan>#</font>
f = [10, -2+2j, -2]
x2 = xalglib.fftr1dinv(f, 4)
print(x2) <font color=darkcyan># expected [1,2,3,4]</font>


</pre><a name=unit_fht></a><h2 class=pageheader><code>fht</code> module</h2>
<div class=pagecontent>
<h3 class=pageheader>Functions</h3>
<a href='#sub_fhtr1d' class=toc>fhtr1d</a><br>
<a href='#sub_fhtr1dinv' class=toc>fhtr1dinv</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='sub_fhtr1d'></a><h3 class=pageheader><code>fhtr1d</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# 1-dimensional Fast Hartley Transform.
# 
# Algorithm has O(N*logN) complexity for any N (composite or prime).
# 
# INPUT PARAMETERS
#     A   -   array[0..N-1] - real function to be transformed
#     N   -   problem size
# 
# OUTPUT PARAMETERS
#     A   -   FHT of a input array, array[0..N-1],
#             A_out[k] = sum(A_in[j]*(cos(2*pi*j*k/N)+sin(2*pi*j*k/N)), j=0..N-1)
# 
# 
#   -- ALGLIB --
#      Copyright 04.06.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: a = xalglib.fhtr1d(a, n)

</div></pre>
<a name='sub_fhtr1dinv'></a><h3 class=pageheader><code>fhtr1dinv</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# 1-dimensional inverse FHT.
# 
# Algorithm has O(N*logN) complexity for any N (composite or prime).
# 
# INPUT PARAMETERS
#     A   -   array[0..N-1] - complex array to be transformed
#     N   -   problem size
# 
# OUTPUT PARAMETERS
#     A   -   inverse FHT of a input array, array[0..N-1]
# 
# 
#   -- ALGLIB --
#      Copyright 29.05.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: a = xalglib.fhtr1dinv(a, n)

</div></pre>
<a name=unit_fresnel></a><h2 class=pageheader><code>fresnel</code> module</h2>
<div class=pagecontent>
<h3 class=pageheader>Functions</h3>
<a href='#sub_fresnelintegral' class=toc>fresnelintegral</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='sub_fresnelintegral'></a><h3 class=pageheader><code>fresnelintegral</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Fresnel integral
# 
# Evaluates the Fresnel integrals
# 
#           x
#           -
#          | |
# C(x) =   |   cos(pi/2 t**2) dt,
#        | |
#         -
#          0
# 
#           x
#           -
#          | |
# S(x) =   |   sin(pi/2 t**2) dt.
#        | |
#         -
#          0
# 
# 
# The integrals are evaluated by a power series for x &lt; 1.
# For x &gt;= 1 auxiliary functions f(x) and g(x) are employed
# such that
# 
# C(x) = 0.5 + f(x) sin( pi/2 x**2 ) - g(x) cos( pi/2 x**2 )
# S(x) = 0.5 - f(x) cos( pi/2 x**2 ) - g(x) sin( pi/2 x**2 )
# 
# 
# 
# ACCURACY:
# 
#  Relative error.
# 
# Arithmetic  function   domain     # trials      peak         rms
#   IEEE       S(x)      0, 10       10000       2.0e-15     3.2e-16
#   IEEE       C(x)      0, 10       10000       1.8e-15     3.3e-16
# 
# Cephes Math Library Release 2.8:  June, 2000
# Copyright 1984, 1987, 1989, 2000 by Stephen L. Moshier
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: c, s = xalglib.fresnelintegral(x, c, s)

</div></pre>
<a name=unit_gammafunc></a><h2 class=pageheader><code>gammafunc</code> module</h2>
<div class=pagecontent>
<h3 class=pageheader>Functions</h3>
<a href='#sub_gammafunction' class=toc>gammafunction</a><br>
<a href='#sub_lngamma' class=toc>lngamma</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='sub_gammafunction'></a><h3 class=pageheader><code>gammafunction</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Gamma function
# 
# Input parameters:
#     X   -   argument
# 
# Domain:
#     0 &lt; X &lt; 171.6
#     -170 &lt; X &lt; 0, X is not an integer.
# 
# Relative error:
#  arithmetic   domain     # trials      peak         rms
#     IEEE    -170,-33      20000       2.3e-15     3.3e-16
#     IEEE     -33,  33     20000       9.4e-16     2.2e-16
#     IEEE      33, 171.6   20000       2.3e-15     3.2e-16
# 
# Cephes Math Library Release 2.8:  June, 2000
# Original copyright 1984, 1987, 1989, 1992, 2000 by Stephen L. Moshier
# Translated to AlgoPascal by Bochkanov Sergey (2005, 2006, 2007).
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.gammafunction(x)

</div></pre>
<a name='sub_lngamma'></a><h3 class=pageheader><code>lngamma</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Natural logarithm of gamma function
# 
# Input parameters:
#     X       -   argument
# 
# Result:
#     logarithm of the absolute value of the Gamma(X).
# 
# Output parameters:
#     SgnGam  -   sign(Gamma(X))
# 
# Domain:
#     0 &lt; X &lt; 2.55e305
#     -2.55e305 &lt; X &lt; 0, X is not an integer.
# 
# ACCURACY:
# arithmetic      domain        # trials     peak         rms
#    IEEE    0, 3                 28000     5.4e-16     1.1e-16
#    IEEE    2.718, 2.556e305     40000     3.5e-16     8.3e-17
# The error criterion was relative when the function magnitude
# was greater than one but absolute when it was less than one.
# 
# The following test used the relative error criterion, though
# at certain points the relative error could be much higher than
# indicated.
#    IEEE    -200, -4             10000     4.8e-16     1.3e-16
# 
# Cephes Math Library Release 2.8:  June, 2000
# Copyright 1984, 1987, 1989, 1992, 2000 by Stephen L. Moshier
# Translated to AlgoPascal by Bochkanov Sergey (2005, 2006, 2007).
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result, sgngam = xalglib.lngamma(x)

</div></pre>
<a name=unit_gkq></a><h2 class=pageheader><code>gkq</code> module</h2>
<div class=pagecontent>
<h3 class=pageheader>Functions</h3>
<a href='#sub_gkqgenerategaussjacobi' class=toc>gkqgenerategaussjacobi</a><br>
<a href='#sub_gkqgenerategausslegendre' class=toc>gkqgenerategausslegendre</a><br>
<a href='#sub_gkqgeneraterec' class=toc>gkqgeneraterec</a><br>
<a href='#sub_gkqlegendrecalc' class=toc>gkqlegendrecalc</a><br>
<a href='#sub_gkqlegendretbl' class=toc>gkqlegendretbl</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='sub_gkqgenerategaussjacobi'></a><h3 class=pageheader><code>gkqgenerategaussjacobi</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Returns   Gauss   and   Gauss-Kronrod   nodes/weights   for   Gauss-Jacobi
# quadrature on [-1,1] with weight function
# 
#     W(x)=Power(1-x,Alpha)*Power(1+x,Beta).
# 
# INPUT PARAMETERS:
#     N           -   number of Kronrod nodes, must be odd number, &gt;=3.
#     Alpha       -   power-law coefficient, Alpha&gt;-1
#     Beta        -   power-law coefficient, Beta&gt;-1
# 
# OUTPUT PARAMETERS:
#     Info        -   error code:
#                     * -5    no real and positive Gauss-Kronrod formula can
#                             be created for such a weight function  with  a
#                             given number of nodes.
#                     * -4    an  error  was   detected   when   calculating
#                             weights/nodes. Alpha or  Beta  are  too  close
#                             to -1 to obtain weights/nodes with high enough
#                             accuracy, or, may be, N is too large.  Try  to
#                             use multiple precision version.
#                     * -3    internal eigenproblem solver hasn't converged
#                     * -1    incorrect N was passed
#                     * +1    OK
#                     * +2    OK, but quadrature rule have exterior  nodes,
#                             x[0]&lt;-1 or x[n-1]&gt;+1
#     X           -   array[0..N-1] - array of quadrature nodes, ordered in
#                     ascending order.
#     WKronrod    -   array[0..N-1] - Kronrod weights
#     WGauss      -   array[0..N-1] - Gauss weights (interleaved with zeros
#                     corresponding to extended Kronrod nodes).
# 
# 
#   -- ALGLIB --
#      Copyright 12.05.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: info, x, wkronrod, wgauss = xalglib.gkqgenerategaussjacobi(n, alpha, beta)

</div></pre>
<a name='sub_gkqgenerategausslegendre'></a><h3 class=pageheader><code>gkqgenerategausslegendre</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Returns   Gauss   and   Gauss-Kronrod   nodes/weights  for  Gauss-Legendre
# quadrature with N points.
# 
# GKQLegendreCalc (calculation) or  GKQLegendreTbl  (precomputed  table)  is
# used depending on machine precision and number of nodes.
# 
# INPUT PARAMETERS:
#     N           -   number of Kronrod nodes, must be odd number, &gt;=3.
# 
# OUTPUT PARAMETERS:
#     Info        -   error code:
#                     * -4    an  error   was   detected   when  calculating
#                             weights/nodes.  N  is  too  large   to  obtain
#                             weights/nodes  with  high   enough   accuracy.
#                             Try  to   use   multiple   precision  version.
#                     * -3    internal eigenproblem solver hasn't converged
#                     * -1    incorrect N was passed
#                     * +1    OK
#     X           -   array[0..N-1] - array of quadrature nodes, ordered in
#                     ascending order.
#     WKronrod    -   array[0..N-1] - Kronrod weights
#     WGauss      -   array[0..N-1] - Gauss weights (interleaved with zeros
#                     corresponding to extended Kronrod nodes).
# 
# 
#   -- ALGLIB --
#      Copyright 12.05.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: info, x, wkronrod, wgauss = xalglib.gkqgenerategausslegendre(n)

</div></pre>
<a name='sub_gkqgeneraterec'></a><h3 class=pageheader><code>gkqgeneraterec</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Computation of nodes and weights of a Gauss-Kronrod quadrature formula
# 
# The algorithm generates the N-point Gauss-Kronrod quadrature formula  with
# weight  function  given  by  coefficients  alpha  and beta of a recurrence
# relation which generates a system of orthogonal polynomials:
# 
#     P-1(x)   =  0
#     P0(x)    =  1
#     Pn+1(x)  =  (x-alpha(n))*Pn(x)  -  beta(n)*Pn-1(x)
# 
# and zero moment Mu0
# 
#     Mu0 = integral(W(x)dx,a,b)
# 
# 
# INPUT PARAMETERS:
#     Alpha          alpha coefficients, array[0..floor(3*K/2)].
#     Beta           beta coefficients,  array[0..ceil(3*K/2)].
#                     Beta[0] is not used and may be arbitrary.
#                     Beta[I]&gt;0.
#     Mu0            zeroth moment of the weight function.
#     N              number of nodes of the Gauss-Kronrod quadrature formula,
#                     N &gt;= 3,
#                     N =  2*K+1.
# 
# OUTPUT PARAMETERS:
#     Info        -   error code:
#                     * -5    no real and positive Gauss-Kronrod formula can
#                             be created for such a weight function  with  a
#                             given number of nodes.
#                     * -4    N is too large, task may be ill  conditioned -
#                             x[i]=x[i+1] found.
#                     * -3    internal eigenproblem solver hasn't converged
#                     * -2    Beta[i]&lt;=0
#                     * -1    incorrect N was passed
#                     * +1    OK
#     X           -   array[0..N-1] - array of quadrature nodes,
#                     in ascending order.
#     WKronrod    -   array[0..N-1] - Kronrod weights
#     WGauss      -   array[0..N-1] - Gauss weights (interleaved with zeros
#                     corresponding to extended Kronrod nodes).
# 
#   -- ALGLIB --
#      Copyright 08.05.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: info, x, wkronrod, wgauss = xalglib.gkqgeneraterec(alpha, beta, mu0, n)

</div></pre>
<a name='sub_gkqlegendrecalc'></a><h3 class=pageheader><code>gkqlegendrecalc</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Returns Gauss and Gauss-Kronrod nodes for quadrature with N points.
# 
# Reduction to tridiagonal eigenproblem is used.
# 
# INPUT PARAMETERS:
#     N           -   number of Kronrod nodes, must be odd number, &gt;=3.
# 
# OUTPUT PARAMETERS:
#     Info        -   error code:
#                     * -4    an  error   was   detected   when  calculating
#                             weights/nodes.  N  is  too  large   to  obtain
#                             weights/nodes  with  high   enough   accuracy.
#                             Try  to   use   multiple   precision  version.
#                     * -3    internal eigenproblem solver hasn't converged
#                     * -1    incorrect N was passed
#                     * +1    OK
#     X           -   array[0..N-1] - array of quadrature nodes, ordered in
#                     ascending order.
#     WKronrod    -   array[0..N-1] - Kronrod weights
#     WGauss      -   array[0..N-1] - Gauss weights (interleaved with zeros
#                     corresponding to extended Kronrod nodes).
# 
#   -- ALGLIB --
#      Copyright 12.05.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: info, x, wkronrod, wgauss = xalglib.gkqlegendrecalc(n)

</div></pre>
<a name='sub_gkqlegendretbl'></a><h3 class=pageheader><code>gkqlegendretbl</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Returns Gauss and Gauss-Kronrod nodes for quadrature with N  points  using
# pre-calculated table. Nodes/weights were  computed  with  accuracy  up  to
# 1.0E-32 (if MPFR version of ALGLIB is used). In standard double  precision
# accuracy reduces to something about 2.0E-16 (depending  on your compiler's
# handling of long floating point constants).
# 
# INPUT PARAMETERS:
#     N           -   number of Kronrod nodes.
#                     N can be 15, 21, 31, 41, 51, 61.
# 
# OUTPUT PARAMETERS:
#     X           -   array[0..N-1] - array of quadrature nodes, ordered in
#                     ascending order.
#     WKronrod    -   array[0..N-1] - Kronrod weights
#     WGauss      -   array[0..N-1] - Gauss weights (interleaved with zeros
#                     corresponding to extended Kronrod nodes).
# 
# 
#   -- ALGLIB --
#      Copyright 12.05.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: x, wkronrod, wgauss, eps = xalglib.gkqlegendretbl(n)

</div></pre>
<a name=unit_gq></a><h2 class=pageheader><code>gq</code> module</h2>
<div class=pagecontent>
<h3 class=pageheader>Functions</h3>
<a href='#sub_gqgenerategausshermite' class=toc>gqgenerategausshermite</a><br>
<a href='#sub_gqgenerategaussjacobi' class=toc>gqgenerategaussjacobi</a><br>
<a href='#sub_gqgenerategausslaguerre' class=toc>gqgenerategausslaguerre</a><br>
<a href='#sub_gqgenerategausslegendre' class=toc>gqgenerategausslegendre</a><br>
<a href='#sub_gqgenerategausslobattorec' class=toc>gqgenerategausslobattorec</a><br>
<a href='#sub_gqgenerategaussradaurec' class=toc>gqgenerategaussradaurec</a><br>
<a href='#sub_gqgeneraterec' class=toc>gqgeneraterec</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='sub_gqgenerategausshermite'></a><h3 class=pageheader><code>gqgenerategausshermite</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Returns  nodes/weights  for  Gauss-Hermite  quadrature on (-inf,+inf) with
# weight function W(x)=Exp(-x*x)
# 
# INPUT PARAMETERS:
#     N           -   number of nodes, &gt;=1
# 
# OUTPUT PARAMETERS:
#     Info        -   error code:
#                     * -4    an  error  was   detected   when   calculating
#                             weights/nodes.  May be, N is too large. Try to
#                             use multiple precision version.
#                     * -3    internal eigenproblem solver hasn't converged
#                     * -1    incorrect N/Alpha was passed
#                     * +1    OK
#     X           -   array[0..N-1] - array of quadrature nodes,
#                     in ascending order.
#     W           -   array[0..N-1] - array of quadrature weights.
# 
# 
#   -- ALGLIB --
#      Copyright 12.05.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: info, x, w = xalglib.gqgenerategausshermite(n)

</div></pre>
<a name='sub_gqgenerategaussjacobi'></a><h3 class=pageheader><code>gqgenerategaussjacobi</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Returns  nodes/weights  for  Gauss-Jacobi quadrature on [-1,1] with weight
# function W(x)=Power(1-x,Alpha)*Power(1+x,Beta).
# 
# INPUT PARAMETERS:
#     N           -   number of nodes, &gt;=1
#     Alpha       -   power-law coefficient, Alpha&gt;-1
#     Beta        -   power-law coefficient, Beta&gt;-1
# 
# OUTPUT PARAMETERS:
#     Info        -   error code:
#                     * -4    an  error  was   detected   when   calculating
#                             weights/nodes. Alpha or  Beta  are  too  close
#                             to -1 to obtain weights/nodes with high enough
#                             accuracy, or, may be, N is too large.  Try  to
#                             use multiple precision version.
#                     * -3    internal eigenproblem solver hasn't converged
#                     * -1    incorrect N/Alpha/Beta was passed
#                     * +1    OK
#     X           -   array[0..N-1] - array of quadrature nodes,
#                     in ascending order.
#     W           -   array[0..N-1] - array of quadrature weights.
# 
# 
#   -- ALGLIB --
#      Copyright 12.05.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: info, x, w = xalglib.gqgenerategaussjacobi(n, alpha, beta)

</div></pre>
<a name='sub_gqgenerategausslaguerre'></a><h3 class=pageheader><code>gqgenerategausslaguerre</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Returns  nodes/weights  for  Gauss-Laguerre  quadrature  on  [0,+inf) with
# weight function W(x)=Power(x,Alpha)*Exp(-x)
# 
# INPUT PARAMETERS:
#     N           -   number of nodes, &gt;=1
#     Alpha       -   power-law coefficient, Alpha&gt;-1
# 
# OUTPUT PARAMETERS:
#     Info        -   error code:
#                     * -4    an  error  was   detected   when   calculating
#                             weights/nodes. Alpha is too  close  to  -1  to
#                             obtain weights/nodes with high enough accuracy
#                             or, may  be,  N  is  too  large.  Try  to  use
#                             multiple precision version.
#                     * -3    internal eigenproblem solver hasn't converged
#                     * -1    incorrect N/Alpha was passed
#                     * +1    OK
#     X           -   array[0..N-1] - array of quadrature nodes,
#                     in ascending order.
#     W           -   array[0..N-1] - array of quadrature weights.
# 
# 
#   -- ALGLIB --
#      Copyright 12.05.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: info, x, w = xalglib.gqgenerategausslaguerre(n, alpha)

</div></pre>
<a name='sub_gqgenerategausslegendre'></a><h3 class=pageheader><code>gqgenerategausslegendre</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Returns nodes/weights for Gauss-Legendre quadrature on [-1,1] with N
# nodes.
# 
# INPUT PARAMETERS:
#     N           -   number of nodes, &gt;=1
# 
# OUTPUT PARAMETERS:
#     Info        -   error code:
#                     * -4    an  error   was   detected   when  calculating
#                             weights/nodes.  N  is  too  large   to  obtain
#                             weights/nodes  with  high   enough   accuracy.
#                             Try  to   use   multiple   precision  version.
#                     * -3    internal eigenproblem solver hasn't  converged
#                     * -1    incorrect N was passed
#                     * +1    OK
#     X           -   array[0..N-1] - array of quadrature nodes,
#                     in ascending order.
#     W           -   array[0..N-1] - array of quadrature weights.
# 
# 
#   -- ALGLIB --
#      Copyright 12.05.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: info, x, w = xalglib.gqgenerategausslegendre(n)

</div></pre>
<a name='sub_gqgenerategausslobattorec'></a><h3 class=pageheader><code>gqgenerategausslobattorec</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Computation of nodes and weights for a Gauss-Lobatto quadrature formula
# 
# The algorithm generates the N-point Gauss-Lobatto quadrature formula  with
# weight function given by coefficients alpha and beta of a recurrence which
# generates a system of orthogonal polynomials.
# 
# P-1(x)   =  0
# P0(x)    =  1
# Pn+1(x)  =  (x-alpha(n))*Pn(x)  -  beta(n)*Pn-1(x)
# 
# and zeroth moment Mu0
# 
# Mu0 = integral(W(x)dx,a,b)
# 
# INPUT PARAMETERS:
#     Alpha      array[0..N-2], alpha coefficients
#     Beta       array[0..N-2], beta coefficients.
#                 Zero-indexed element is not used, may be arbitrary.
#                 Beta[I]&gt;0
#     Mu0        zeroth moment of the weighting function.
#     A          left boundary of the integration interval.
#     B          right boundary of the integration interval.
#     N          number of nodes of the quadrature formula, N&gt;=3
#                 (including the left and right boundary nodes).
# 
# OUTPUT PARAMETERS:
#     Info    -   error code:
#                 * -3    internal eigenproblem solver hasn't converged
#                 * -2    Beta[i]&lt;=0
#                 * -1    incorrect N was passed
#                 *  1    OK
#     X       -   array[0..N-1] - array of quadrature nodes,
#                 in ascending order.
#     W       -   array[0..N-1] - array of quadrature weights.
# 
#   -- ALGLIB --
#      Copyright 2005-2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: info, x, w = xalglib.gqgenerategausslobattorec(alpha, beta, mu0, a, b, n)

</div></pre>
<a name='sub_gqgenerategaussradaurec'></a><h3 class=pageheader><code>gqgenerategaussradaurec</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Computation of nodes and weights for a Gauss-Radau quadrature formula
# 
# The algorithm generates the N-point Gauss-Radau  quadrature  formula  with
# weight function given by the coefficients alpha and  beta  of a recurrence
# which generates a system of orthogonal polynomials.
# 
# P-1(x)   =  0
# P0(x)    =  1
# Pn+1(x)  =  (x-alpha(n))*Pn(x)  -  beta(n)*Pn-1(x)
# 
# and zeroth moment Mu0
# 
# Mu0 = integral(W(x)dx,a,b)
# 
# INPUT PARAMETERS:
#     Alpha      array[0..N-2], alpha coefficients.
#     Beta       array[0..N-1], beta coefficients
#                 Zero-indexed element is not used.
#                 Beta[I]&gt;0
#     Mu0        zeroth moment of the weighting function.
#     A          left boundary of the integration interval.
#     N          number of nodes of the quadrature formula, N&gt;=2
#                 (including the left boundary node).
# 
# OUTPUT PARAMETERS:
#     Info    -   error code:
#                 * -3    internal eigenproblem solver hasn't converged
#                 * -2    Beta[i]&lt;=0
#                 * -1    incorrect N was passed
#                 *  1    OK
#     X       -   array[0..N-1] - array of quadrature nodes,
#                 in ascending order.
#     W       -   array[0..N-1] - array of quadrature weights.
# 
# 
#   -- ALGLIB --
#      Copyright 2005-2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: info, x, w = xalglib.gqgenerategaussradaurec(alpha, beta, mu0, a, n)

</div></pre>
<a name='sub_gqgeneraterec'></a><h3 class=pageheader><code>gqgeneraterec</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Computation of nodes and weights for a Gauss quadrature formula
# 
# The algorithm generates the N-point Gauss quadrature formula  with  weight
# function given by coefficients alpha and beta  of  a  recurrence  relation
# which generates a system of orthogonal polynomials:
# 
# P-1(x)   =  0
# P0(x)    =  1
# Pn+1(x)  =  (x-alpha(n))*Pn(x)  -  beta(n)*Pn-1(x)
# 
# and zeroth moment Mu0
# 
# Mu0 = integral(W(x)dx,a,b)
# 
# INPUT PARAMETERS:
#     Alpha      array[0..N-1], alpha coefficients
#     Beta       array[0..N-1], beta coefficients
#                 Zero-indexed element is not used and may be arbitrary.
#                 Beta[I]&gt;0.
#     Mu0        zeroth moment of the weight function.
#     N          number of nodes of the quadrature formula, N&gt;=1
# 
# OUTPUT PARAMETERS:
#     Info    -   error code:
#                 * -3    internal eigenproblem solver hasn't converged
#                 * -2    Beta[i]&lt;=0
#                 * -1    incorrect N was passed
#                 *  1    OK
#     X       -   array[0..N-1] - array of quadrature nodes,
#                 in ascending order.
#     W       -   array[0..N-1] - array of quadrature weights.
# 
#   -- ALGLIB --
#      Copyright 2005-2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: info, x, w = xalglib.gqgeneraterec(alpha, beta, mu0, n)

</div></pre>
<a name=unit_hermite></a><h2 class=pageheader><code>hermite</code> module</h2>
<div class=pagecontent>
<h3 class=pageheader>Functions</h3>
<a href='#sub_hermitecalculate' class=toc>hermitecalculate</a><br>
<a href='#sub_hermitecoefficients' class=toc>hermitecoefficients</a><br>
<a href='#sub_hermitesum' class=toc>hermitesum</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='sub_hermitecalculate'></a><h3 class=pageheader><code>hermitecalculate</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Calculation of the value of the Hermite polynomial.
# 
# Parameters:
#     n   -   degree, n&gt;=0
#     x   -   argument
# 
# Result:
#     the value of the Hermite polynomial Hn at x
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.hermitecalculate(n, x)

</div></pre>
<a name='sub_hermitecoefficients'></a><h3 class=pageheader><code>hermitecoefficients</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Representation of Hn as C[0] + C[1]*X + ... + C[N]*X^N
# 
# Input parameters:
#     N   -   polynomial degree, n&gt;=0
# 
# Output parameters:
#     C   -   coefficients
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: c = xalglib.hermitecoefficients(n)

</div></pre>
<a name='sub_hermitesum'></a><h3 class=pageheader><code>hermitesum</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Summation of Hermite polynomials using Clenshaws recurrence formula.
# 
# This routine calculates
#     c[0]*H0(x) + c[1]*H1(x) + ... + c[N]*HN(x)
# 
# Parameters:
#     n   -   degree, n&gt;=0
#     x   -   argument
# 
# Result:
#     the value of the Hermite polynomial at x
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.hermitesum(c, n, x)

</div></pre>
<a name=unit_hqrnd></a><h2 class=pageheader><code>hqrnd</code> module</h2>
<div class=pagecontent>
<h3 class=pageheader>Classes</h3>
<a href='#struct_hqrndstate' class=toc>hqrndstate</a><br>
<h3 class=pageheader>Functions</h3>
<a href='#sub_hqrndexponential' class=toc>hqrndexponential</a><br>
<a href='#sub_hqrndnormal' class=toc>hqrndnormal</a><br>
<a href='#sub_hqrndnormal2' class=toc>hqrndnormal2</a><br>
<a href='#sub_hqrndrandomize' class=toc>hqrndrandomize</a><br>
<a href='#sub_hqrndseed' class=toc>hqrndseed</a><br>
<a href='#sub_hqrnduniformi' class=toc>hqrnduniformi</a><br>
<a href='#sub_hqrnduniformr' class=toc>hqrnduniformr</a><br>
<a href='#sub_hqrndunit2' class=toc>hqrndunit2</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='struct_hqrndstate'></a><h3 class=pageheader><code>hqrndstate</code> class</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Portable high quality random number generator state.
# Initialized with HQRNDRandomize() or HQRNDSeed().
# 
# Fields:
#     S1, S2      -   seed values
#     V           -   precomputed value
#     MagicV      -   'magic' value used to determine whether State structure
#                     was correctly initialized.
#

</div><div style='margin-top: 0; margin-bottom: 0;'><span style='font-weight: bold; color: green;'>class</span> hqrndstate(object):
    ...

</div></pre>
<a name='sub_hqrndexponential'></a><h3 class=pageheader><code>hqrndexponential</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Random number generator: exponential distribution
# 
# State structure must be initialized with HQRNDRandomize() or HQRNDSeed().
# 
#   -- ALGLIB --
#      Copyright 11.08.2007 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.hqrndexponential(state, lambdav)

</div></pre>
<a name='sub_hqrndnormal'></a><h3 class=pageheader><code>hqrndnormal</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Random number generator: normal numbers
# 
# This function generates one random number from normal distribution.
# Its performance is equal to that of HQRNDNormal2()
# 
# State structure must be initialized with HQRNDRandomize() or HQRNDSeed().
# 
#   -- ALGLIB --
#      Copyright 02.12.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.hqrndnormal(state)

</div></pre>
<a name='sub_hqrndnormal2'></a><h3 class=pageheader><code>hqrndnormal2</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Random number generator: normal numbers
# 
# This function generates two independent random numbers from normal
# distribution. Its performance is equal to that of HQRNDNormal()
# 
# State structure must be initialized with HQRNDRandomize() or HQRNDSeed().
# 
#   -- ALGLIB --
#      Copyright 02.12.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: x1, x2 = xalglib.hqrndnormal2(state)

</div></pre>
<a name='sub_hqrndrandomize'></a><h3 class=pageheader><code>hqrndrandomize</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# HQRNDState  initialization  with  random  values  which come from standard
# RNG.
# 
#   -- ALGLIB --
#      Copyright 02.12.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: state = xalglib.hqrndrandomize()

</div></pre>
<a name='sub_hqrndseed'></a><h3 class=pageheader><code>hqrndseed</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# HQRNDState initialization with seed values
# 
#   -- ALGLIB --
#      Copyright 02.12.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: state = xalglib.hqrndseed(s1, s2)

</div></pre>
<a name='sub_hqrnduniformi'></a><h3 class=pageheader><code>hqrnduniformi</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# This function generates random integer number in [0, N)
# 
# 1. N must be less than HQRNDMax-1.
# 2. State structure must be initialized with HQRNDRandomize() or HQRNDSeed()
# 
#   -- ALGLIB --
#      Copyright 02.12.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.hqrnduniformi(state, n)

</div></pre>
<a name='sub_hqrnduniformr'></a><h3 class=pageheader><code>hqrnduniformr</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# This function generates random real number in (0,1),
# not including interval boundaries
# 
# State structure must be initialized with HQRNDRandomize() or HQRNDSeed().
# 
#   -- ALGLIB --
#      Copyright 02.12.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.hqrnduniformr(state)

</div></pre>
<a name='sub_hqrndunit2'></a><h3 class=pageheader><code>hqrndunit2</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Random number generator: random X and Y such that X^2+Y^2=1
# 
# State structure must be initialized with HQRNDRandomize() or HQRNDSeed().
# 
#   -- ALGLIB --
#      Copyright 02.12.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: x, y = xalglib.hqrndunit2(state)

</div></pre>
<a name=unit_ibetaf></a><h2 class=pageheader><code>ibetaf</code> module</h2>
<div class=pagecontent>
<h3 class=pageheader>Functions</h3>
<a href='#sub_incompletebeta' class=toc>incompletebeta</a><br>
<a href='#sub_invincompletebeta' class=toc>invincompletebeta</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='sub_incompletebeta'></a><h3 class=pageheader><code>incompletebeta</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Incomplete beta integral
# 
# Returns incomplete beta integral of the arguments, evaluated
# from zero to x.  The function is defined as
# 
#                  x
#     -            -
#    | (a+b)      | |  a-1     b-1
#  -----------    |   t   (1-t)   dt.
#   -     -     | |
#  | (a) | (b)   -
#                 0
# 
# The domain of definition is 0 &lt;= x &lt;= 1.  In this
# implementation a and b are restricted to positive values.
# The integral from x to 1 may be obtained by the symmetry
# relation
# 
#    1 - incbet( a, b, x )  =  incbet( b, a, 1-x ).
# 
# The integral is evaluated by a continued fraction expansion
# or, when b*x is small, by a power series.
# 
# ACCURACY:
# 
# Tested at uniformly distributed random points (a,b,x) with a and b
# in &quot;domain&quot; and x between 0 and 1.
#                                        Relative error
# arithmetic   domain     # trials      peak         rms
#    IEEE      0,5         10000       6.9e-15     4.5e-16
#    IEEE      0,85       250000       2.2e-13     1.7e-14
#    IEEE      0,1000      30000       5.3e-12     6.3e-13
#    IEEE      0,10000    250000       9.3e-11     7.1e-12
#    IEEE      0,100000    10000       8.7e-10     4.8e-11
# Outputs smaller than the IEEE gradual underflow threshold
# were excluded from these statistics.
# 
# Cephes Math Library, Release 2.8:  June, 2000
# Copyright 1984, 1995, 2000 by Stephen L. Moshier
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.incompletebeta(a, b, x)

</div></pre>
<a name='sub_invincompletebeta'></a><h3 class=pageheader><code>invincompletebeta</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Inverse of imcomplete beta integral
# 
# Given y, the function finds x such that
# 
#  incbet( a, b, x ) = y .
# 
# The routine performs interval halving or Newton iterations to find the
# root of incbet(a,b,x) - y = 0.
# 
# 
# ACCURACY:
# 
#                      Relative error:
#                x     a,b
# arithmetic   domain  domain  # trials    peak       rms
#    IEEE      0,1    .5,10000   50000    5.8e-12   1.3e-13
#    IEEE      0,1   .25,100    100000    1.8e-13   3.9e-15
#    IEEE      0,1     0,5       50000    1.1e-12   5.5e-15
# With a and b constrained to half-integer or integer values:
#    IEEE      0,1    .5,10000   50000    5.8e-12   1.1e-13
#    IEEE      0,1    .5,100    100000    1.7e-14   7.9e-16
# With a = .5, b constrained to half-integer or integer values:
#    IEEE      0,1    .5,10000   10000    8.3e-11   1.0e-11
# 
# Cephes Math Library Release 2.8:  June, 2000
# Copyright 1984, 1996, 2000 by Stephen L. Moshier
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.invincompletebeta(a, b, y)

</div></pre>
<a name=unit_idwint></a><h2 class=pageheader><code>idwint</code> module</h2>
<div class=pagecontent>
<h3 class=pageheader>Classes</h3>
<a href='#struct_idwinterpolant' class=toc>idwinterpolant</a><br>
<h3 class=pageheader>Functions</h3>
<a href='#sub_idwbuildmodifiedshepard' class=toc>idwbuildmodifiedshepard</a><br>
<a href='#sub_idwbuildmodifiedshepardr' class=toc>idwbuildmodifiedshepardr</a><br>
<a href='#sub_idwbuildnoisy' class=toc>idwbuildnoisy</a><br>
<a href='#sub_idwcalc' class=toc>idwcalc</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='struct_idwinterpolant'></a><h3 class=pageheader><code>idwinterpolant</code> class</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# IDW interpolant.
#

</div><div style='margin-top: 0; margin-bottom: 0;'><span style='font-weight: bold; color: green;'>class</span> idwinterpolant(object):
    ...

</div></pre>
<a name='sub_idwbuildmodifiedshepard'></a><h3 class=pageheader><code>idwbuildmodifiedshepard</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# IDW interpolant using modified Shepard method for uniform point
# distributions.
# 
# INPUT PARAMETERS:
#     XY  -   X and Y values, array[0..N-1,0..NX].
#             First NX columns contain X-values, last column contain
#             Y-values.
#     N   -   number of nodes, N&gt;0.
#     NX  -   space dimension, NX&gt;=1.
#     D   -   nodal function type, either:
#             * 0     constant  model.  Just  for  demonstration only, worst
#                     model ever.
#             * 1     linear model, least squares fitting. Simpe  model  for
#                     datasets too small for quadratic models
#             * 2     quadratic  model,  least  squares  fitting. Best model
#                     available (if your dataset is large enough).
#             * -1    &quot;fast&quot;  linear  model,  use  with  caution!!!   It  is
#                     significantly  faster than linear/quadratic and better
#                     than constant model. But it is less robust (especially
#                     in the presence of noise).
#     NQ  -   number of points used to calculate  nodal  functions  (ignored
#             for constant models). NQ should be LARGER than:
#             * max(1.5*(1+NX),2^NX+1) for linear model,
#             * max(3/4*(NX+2)*(NX+1),2^NX+1) for quadratic model.
#             Values less than this threshold will be silently increased.
#     NW  -   number of points used to calculate weights and to interpolate.
#             Required: &gt;=2^NX+1, values less than this  threshold  will  be
#             silently increased.
#             Recommended value: about 2*NQ
# 
# OUTPUT PARAMETERS:
#     Z   -   IDW interpolant.
# 
# NOTES:
#   * best results are obtained with quadratic models, worst - with constant
#     models
#   * when N is large, NQ and NW must be significantly smaller than  N  both
#     to obtain optimal performance and to obtain optimal accuracy. In 2  or
#     3-dimensional tasks NQ=15 and NW=25 are good values to start with.
#   * NQ  and  NW  may  be  greater  than  N.  In  such  cases  they will be
#     automatically decreased.
#   * this subroutine is always succeeds (as long as correct parameters  are
#     passed).
#   * see  'Multivariate  Interpolation  of Large Sets of Scattered Data' by
#     Robert J. Renka for more information on this algorithm.
#   * this subroutine assumes that point distribution is uniform at the small
#     scales.  If  it  isn't  -  for  example,  points are concentrated along
#     &quot;lines&quot;, but &quot;lines&quot; distribution is uniform at the larger scale - then
#     you should use IDWBuildModifiedShepardR()
# 
# 
#   -- ALGLIB PROJECT --
#      Copyright 02.03.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: z = xalglib.idwbuildmodifiedshepard(xy, n, nx, d, nq, nw)

</div></pre>
<a name='sub_idwbuildmodifiedshepardr'></a><h3 class=pageheader><code>idwbuildmodifiedshepardr</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# IDW interpolant using modified Shepard method for non-uniform datasets.
# 
# This type of model uses  constant  nodal  functions and interpolates using
# all nodes which are closer than user-specified radius R. It  may  be  used
# when points distribution is non-uniform at the small scale, but it  is  at
# the distances as large as R.
# 
# INPUT PARAMETERS:
#     XY  -   X and Y values, array[0..N-1,0..NX].
#             First NX columns contain X-values, last column contain
#             Y-values.
#     N   -   number of nodes, N&gt;0.
#     NX  -   space dimension, NX&gt;=1.
#     R   -   radius, R&gt;0
# 
# OUTPUT PARAMETERS:
#     Z   -   IDW interpolant.
# 
# NOTES:
# * if there is less than IDWKMin points within  R-ball,  algorithm  selects
#   IDWKMin closest ones, so that continuity properties of  interpolant  are
#   preserved even far from points.
# 
#   -- ALGLIB PROJECT --
#      Copyright 11.04.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: z = xalglib.idwbuildmodifiedshepardr(xy, n, nx, r)

</div></pre>
<a name='sub_idwbuildnoisy'></a><h3 class=pageheader><code>idwbuildnoisy</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# IDW model for noisy data.
# 
# This subroutine may be used to handle noisy data, i.e. data with noise  in
# OUTPUT values.  It differs from IDWBuildModifiedShepard() in the following
# aspects:
# * nodal functions are not constrained to pass through  nodes:  Qi(xi)&lt;&gt;yi,
#   i.e. we have fitting  instead  of  interpolation.
# * weights which are used during least  squares fitting stage are all equal
#   to 1.0 (independently of distance)
# * &quot;fast&quot;-linear or constant nodal functions are not supported (either  not
#   robust enough or too rigid)
# 
# This problem require far more complex tuning than interpolation  problems.
# Below you can find some recommendations regarding this problem:
# * focus on tuning NQ; it controls noise reduction. As for NW, you can just
#   make it equal to 2*NQ.
# * you can use cross-validation to determine optimal NQ.
# * optimal NQ is a result of complex tradeoff  between  noise  level  (more
#   noise = larger NQ required) and underlying  function  complexity  (given
#   fixed N, larger NQ means smoothing of compex features in the data).  For
#   example, NQ=N will reduce noise to the minimum level possible,  but  you
#   will end up with just constant/linear/quadratic (depending on  D)  least
#   squares model for the whole dataset.
# 
# INPUT PARAMETERS:
#     XY  -   X and Y values, array[0..N-1,0..NX].
#             First NX columns contain X-values, last column contain
#             Y-values.
#     N   -   number of nodes, N&gt;0.
#     NX  -   space dimension, NX&gt;=1.
#     D   -   nodal function degree, either:
#             * 1     linear model, least squares fitting. Simpe  model  for
#                     datasets too small for quadratic models (or  for  very
#                     noisy problems).
#             * 2     quadratic  model,  least  squares  fitting. Best model
#                     available (if your dataset is large enough).
#     NQ  -   number of points used to calculate nodal functions.  NQ should
#             be  significantly   larger   than  1.5  times  the  number  of
#             coefficients in a nodal function to overcome effects of noise:
#             * larger than 1.5*(1+NX) for linear model,
#             * larger than 3/4*(NX+2)*(NX+1) for quadratic model.
#             Values less than this threshold will be silently increased.
#     NW  -   number of points used to calculate weights and to interpolate.
#             Required: &gt;=2^NX+1, values less than this  threshold  will  be
#             silently increased.
#             Recommended value: about 2*NQ or larger
# 
# OUTPUT PARAMETERS:
#     Z   -   IDW interpolant.
# 
# NOTES:
#   * best results are obtained with quadratic models, linear models are not
#     recommended to use unless you are pretty sure that it is what you want
#   * this subroutine is always succeeds (as long as correct parameters  are
#     passed).
#   * see  'Multivariate  Interpolation  of Large Sets of Scattered Data' by
#     Robert J. Renka for more information on this algorithm.
# 
# 
#   -- ALGLIB PROJECT --
#      Copyright 02.03.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: z = xalglib.idwbuildnoisy(xy, n, nx, d, nq, nw)

</div></pre>
<a name='sub_idwcalc'></a><h3 class=pageheader><code>idwcalc</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# IDW interpolation
# 
# INPUT PARAMETERS:
#     Z   -   IDW interpolant built with one of model building
#             subroutines.
#     X   -   array[0..NX-1], interpolation point
# 
# Result:
#     IDW interpolant Z(X)
# 
#   -- ALGLIB --
#      Copyright 02.03.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.idwcalc(z, x)

</div></pre>
<a name=unit_igammaf></a><h2 class=pageheader><code>igammaf</code> module</h2>
<div class=pagecontent>
<h3 class=pageheader>Functions</h3>
<a href='#sub_incompletegamma' class=toc>incompletegamma</a><br>
<a href='#sub_incompletegammac' class=toc>incompletegammac</a><br>
<a href='#sub_invincompletegammac' class=toc>invincompletegammac</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='sub_incompletegamma'></a><h3 class=pageheader><code>incompletegamma</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Incomplete gamma integral
# 
# The function is defined by
# 
#                           x
#                            -
#                   1       | |  -t  a-1
#  igam(a,x)  =   -----     |   e   t   dt.
#                  -      | |
#                 | (a)    -
#                           0
# 
# 
# In this implementation both arguments must be positive.
# The integral is evaluated by either a power series or
# continued fraction expansion, depending on the relative
# values of a and x.
# 
# ACCURACY:
# 
#                      Relative error:
# arithmetic   domain     # trials      peak         rms
#    IEEE      0,30       200000       3.6e-14     2.9e-15
#    IEEE      0,100      300000       9.9e-14     1.5e-14
# 
# Cephes Math Library Release 2.8:  June, 2000
# Copyright 1985, 1987, 2000 by Stephen L. Moshier
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.incompletegamma(a, x)

</div></pre>
<a name='sub_incompletegammac'></a><h3 class=pageheader><code>incompletegammac</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Complemented incomplete gamma integral
# 
# The function is defined by
# 
# 
#  igamc(a,x)   =   1 - igam(a,x)
# 
#                            inf.
#                              -
#                     1       | |  -t  a-1
#               =   -----     |   e   t   dt.
#                    -      | |
#                   | (a)    -
#                             x
# 
# 
# In this implementation both arguments must be positive.
# The integral is evaluated by either a power series or
# continued fraction expansion, depending on the relative
# values of a and x.
# 
# ACCURACY:
# 
# Tested at random a, x.
#                a         x                      Relative error:
# arithmetic   domain   domain     # trials      peak         rms
#    IEEE     0.5,100   0,100      200000       1.9e-14     1.7e-15
#    IEEE     0.01,0.5  0,100      200000       1.4e-13     1.6e-15
# 
# Cephes Math Library Release 2.8:  June, 2000
# Copyright 1985, 1987, 2000 by Stephen L. Moshier
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.incompletegammac(a, x)

</div></pre>
<a name='sub_invincompletegammac'></a><h3 class=pageheader><code>invincompletegammac</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Inverse of complemented imcomplete gamma integral
# 
# Given p, the function finds x such that
# 
#  igamc( a, x ) = p.
# 
# Starting with the approximate value
# 
#         3
#  x = a t
# 
#  where
# 
#  t = 1 - d - ndtri(p) sqrt(d)
# 
# and
# 
#  d = 1/9a,
# 
# the routine performs up to 10 Newton iterations to find the
# root of igamc(a,x) - p = 0.
# 
# ACCURACY:
# 
# Tested at random a, p in the intervals indicated.
# 
#                a        p                      Relative error:
# arithmetic   domain   domain     # trials      peak         rms
#    IEEE     0.5,100   0,0.5       100000       1.0e-14     1.7e-15
#    IEEE     0.01,0.5  0,0.5       100000       9.0e-14     3.4e-15
#    IEEE    0.5,10000  0,0.5        20000       2.3e-13     3.8e-14
# 
# Cephes Math Library Release 2.8:  June, 2000
# Copyright 1984, 1987, 1995, 2000 by Stephen L. Moshier
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.invincompletegammac(a, y0)

</div></pre>
<a name=unit_inverseupdate></a><h2 class=pageheader><code>inverseupdate</code> module</h2>
<div class=pagecontent>
<h3 class=pageheader>Functions</h3>
<a href='#sub_rmatrixinvupdatecolumn' class=toc>rmatrixinvupdatecolumn</a><br>
<a href='#sub_rmatrixinvupdaterow' class=toc>rmatrixinvupdaterow</a><br>
<a href='#sub_rmatrixinvupdatesimple' class=toc>rmatrixinvupdatesimple</a><br>
<a href='#sub_rmatrixinvupdateuv' class=toc>rmatrixinvupdateuv</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='sub_rmatrixinvupdatecolumn'></a><h3 class=pageheader><code>rmatrixinvupdatecolumn</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Inverse matrix update by the Sherman-Morrison formula
# 
# The algorithm updates matrix A^-1 when adding a vector to a column
# of matrix A.
# 
# Input parameters:
#     InvA        -   inverse of matrix A.
#                     Array whose indexes range within [0..N-1, 0..N-1].
#     N           -   size of matrix A.
#     UpdColumn   -   the column of A whose vector U was added.
#                     0 &lt;= UpdColumn &lt;= N-1
#     U           -   the vector to be added to a column.
#                     Array whose index ranges within [0..N-1].
# 
# Output parameters:
#     InvA        -   inverse of modified matrix A.
# 
#   -- ALGLIB --
#      Copyright 2005 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: inva = xalglib.rmatrixinvupdatecolumn(inva, n, updcolumn, u)

</div></pre>
<a name='sub_rmatrixinvupdaterow'></a><h3 class=pageheader><code>rmatrixinvupdaterow</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Inverse matrix update by the Sherman-Morrison formula
# 
# The algorithm updates matrix A^-1 when adding a vector to a row
# of matrix A.
# 
# Input parameters:
#     InvA    -   inverse of matrix A.
#                 Array whose indexes range within [0..N-1, 0..N-1].
#     N       -   size of matrix A.
#     UpdRow  -   the row of A whose vector V was added.
#                 0 &lt;= Row &lt;= N-1
#     V       -   the vector to be added to a row.
#                 Array whose index ranges within [0..N-1].
# 
# Output parameters:
#     InvA    -   inverse of modified matrix A.
# 
#   -- ALGLIB --
#      Copyright 2005 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: inva = xalglib.rmatrixinvupdaterow(inva, n, updrow, v)

</div></pre>
<a name='sub_rmatrixinvupdatesimple'></a><h3 class=pageheader><code>rmatrixinvupdatesimple</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Inverse matrix update by the Sherman-Morrison formula
# 
# The algorithm updates matrix A^-1 when adding a number to an element
# of matrix A.
# 
# Input parameters:
#     InvA    -   inverse of matrix A.
#                 Array whose indexes range within [0..N-1, 0..N-1].
#     N       -   size of matrix A.
#     UpdRow  -   row where the element to be updated is stored.
#     UpdColumn - column where the element to be updated is stored.
#     UpdVal  -   a number to be added to the element.
# 
# 
# Output parameters:
#     InvA    -   inverse of modified matrix A.
# 
#   -- ALGLIB --
#      Copyright 2005 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: inva = xalglib.rmatrixinvupdatesimple(inva, n, updrow, updcolumn, updval)

</div></pre>
<a name='sub_rmatrixinvupdateuv'></a><h3 class=pageheader><code>rmatrixinvupdateuv</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Inverse matrix update by the Sherman-Morrison formula
# 
# The algorithm computes the inverse of matrix A+u*v by using the given matrix
# A^-1 and the vectors u and v.
# 
# Input parameters:
#     InvA    -   inverse of matrix A.
#                 Array whose indexes range within [0..N-1, 0..N-1].
#     N       -   size of matrix A.
#     U       -   the vector modifying the matrix.
#                 Array whose index ranges within [0..N-1].
#     V       -   the vector modifying the matrix.
#                 Array whose index ranges within [0..N-1].
# 
# Output parameters:
#     InvA - inverse of matrix A + u*v'.
# 
#   -- ALGLIB --
#      Copyright 2005 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: inva = xalglib.rmatrixinvupdateuv(inva, n, u, v)

</div></pre>
<a name=unit_jacobianelliptic></a><h2 class=pageheader><code>jacobianelliptic</code> module</h2>
<div class=pagecontent>
<h3 class=pageheader>Functions</h3>
<a href='#sub_jacobianellipticfunctions' class=toc>jacobianellipticfunctions</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='sub_jacobianellipticfunctions'></a><h3 class=pageheader><code>jacobianellipticfunctions</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Jacobian Elliptic Functions
# 
# Evaluates the Jacobian elliptic functions sn(u|m), cn(u|m),
# and dn(u|m) of parameter m between 0 and 1, and real
# argument u.
# 
# These functions are periodic, with quarter-period on the
# real axis equal to the complete elliptic integral
# ellpk(1.0-m).
# 
# Relation to incomplete elliptic integral:
# If u = ellik(phi,m), then sn(u|m) = sin(phi),
# and cn(u|m) = cos(phi).  Phi is called the amplitude of u.
# 
# Computation is by means of the arithmetic-geometric mean
# algorithm, except when m is within 1e-9 of 0 or 1.  In the
# latter case with m close to 1, the approximation applies
# only for phi &lt; pi/2.
# 
# ACCURACY:
# 
# Tested at random points with u between 0 and 10, m between
# 0 and 1.
# 
#            Absolute error (* = relative error):
# arithmetic   function   # trials      peak         rms
#    IEEE      phi         10000       9.2e-16*    1.4e-16*
#    IEEE      sn          50000       4.1e-15     4.6e-16
#    IEEE      cn          40000       3.6e-15     4.4e-16
#    IEEE      dn          10000       1.3e-12     1.8e-14
# 
#  Peak error observed in consistency check using addition
# theorem for sn(u+v) was 4e-16 (absolute).  Also tested by
# the above relation to the incomplete elliptic integral.
# Accuracy deteriorates when u is large.
# 
# Cephes Math Library Release 2.8:  June, 2000
# Copyright 1984, 1987, 2000 by Stephen L. Moshier
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: sn, cn, dn, ph = xalglib.jacobianellipticfunctions(u, m)

</div></pre>
<a name=unit_jarquebera></a><h2 class=pageheader><code>jarquebera</code> module</h2>
<div class=pagecontent>
<h3 class=pageheader>Functions</h3>
<a href='#sub_jarqueberatest' class=toc>jarqueberatest</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='sub_jarqueberatest'></a><h3 class=pageheader><code>jarqueberatest</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Jarque-Bera test
# 
# This test checks hypotheses about the fact that a  given  sample  X  is  a
# sample of normal random variable.
# 
# Requirements:
#     * the number of elements in the sample is not less than 5.
# 
# Input parameters:
#     X   -   sample. Array whose index goes from 0 to N-1.
#     N   -   size of the sample. N&gt;=5
# 
# Output parameters:
#     BothTails   -   p-value for two-tailed test.
#                     If BothTails is less than the given significance level
#                     the null hypothesis is rejected.
#     LeftTail    -   p-value for left-tailed test.
#                     If LeftTail is less than the given significance level,
#                     the null hypothesis is rejected.
#     RightTail   -   p-value for right-tailed test.
#                     If RightTail is less than the given significance level
#                     the null hypothesis is rejected.
# 
# Accuracy of the approximation used (5&lt;=N&lt;=1951):
# 
# p-value  	    relative error (5&lt;=N&lt;=1951)
# [1, 0.1]            &lt; 1%
# [0.1, 0.01]         &lt; 2%
# [0.01, 0.001]       &lt; 6%
# [0.001, 0]          wasn't measured
# 
# For N&gt;1951 accuracy wasn't measured but it shouldn't be sharply  different
# from table values.
# 
#   -- ALGLIB --
#      Copyright 09.04.2007 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: p = xalglib.jarqueberatest(x, n)

</div></pre>
<a name=unit_kmeans></a><h2 class=pageheader><code>kmeans</code> module</h2>
<div class=pagecontent>
<h3 class=pageheader>Functions</h3>
<a href='#sub_kmeansgenerate' class=toc>kmeansgenerate</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='sub_kmeansgenerate'></a><h3 class=pageheader><code>kmeansgenerate</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# k-means++ clusterization
# 
# INPUT PARAMETERS:
#     XY          -   dataset, array [0..NPoints-1,0..NVars-1].
#     NPoints     -   dataset size, NPoints&gt;=K
#     NVars       -   number of variables, NVars&gt;=1
#     K           -   desired number of clusters, K&gt;=1
#     Restarts    -   number of restarts, Restarts&gt;=1
# 
# OUTPUT PARAMETERS:
#     Info        -   return code:
#                     * -3, if task is degenerate (number of distinct points is
#                           less than K)
#                     * -1, if incorrect NPoints/NFeatures/K/Restarts was passed
#                     *  1, if subroutine finished successfully
#     C           -   array[0..NVars-1,0..K-1].matrix whose columns store
#                     cluster's centers
#     XYC         -   array which contains number of clusters dataset points
#                     belong to.
# 
#   -- ALGLIB --
#      Copyright 21.03.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: info, c, xyc = xalglib.kmeansgenerate(xy, npoints, nvars, k, restarts)

</div></pre>
<a name=unit_laguerre></a><h2 class=pageheader><code>laguerre</code> module</h2>
<div class=pagecontent>
<h3 class=pageheader>Functions</h3>
<a href='#sub_laguerrecalculate' class=toc>laguerrecalculate</a><br>
<a href='#sub_laguerrecoefficients' class=toc>laguerrecoefficients</a><br>
<a href='#sub_laguerresum' class=toc>laguerresum</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='sub_laguerrecalculate'></a><h3 class=pageheader><code>laguerrecalculate</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Calculation of the value of the Laguerre polynomial.
# 
# Parameters:
#     n   -   degree, n&gt;=0
#     x   -   argument
# 
# Result:
#     the value of the Laguerre polynomial Ln at x
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.laguerrecalculate(n, x)

</div></pre>
<a name='sub_laguerrecoefficients'></a><h3 class=pageheader><code>laguerrecoefficients</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Representation of Ln as C[0] + C[1]*X + ... + C[N]*X^N
# 
# Input parameters:
#     N   -   polynomial degree, n&gt;=0
# 
# Output parameters:
#     C   -   coefficients
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: c = xalglib.laguerrecoefficients(n)

</div></pre>
<a name='sub_laguerresum'></a><h3 class=pageheader><code>laguerresum</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Summation of Laguerre polynomials using Clenshaws recurrence formula.
# 
# This routine calculates c[0]*L0(x) + c[1]*L1(x) + ... + c[N]*LN(x)
# 
# Parameters:
#     n   -   degree, n&gt;=0
#     x   -   argument
# 
# Result:
#     the value of the Laguerre polynomial at x
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.laguerresum(c, n, x)

</div></pre>
<a name=unit_lda></a><h2 class=pageheader><code>lda</code> module</h2>
<div class=pagecontent>
<h3 class=pageheader>Functions</h3>
<a href='#sub_fisherlda' class=toc>fisherlda</a><br>
<a href='#sub_fisherldan' class=toc>fisherldan</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='sub_fisherlda'></a><h3 class=pageheader><code>fisherlda</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Multiclass Fisher LDA
# 
# Subroutine finds coefficients of linear combination which optimally separates
# training set on classes.
# 
# INPUT PARAMETERS:
#     XY          -   training set, array[0..NPoints-1,0..NVars].
#                     First NVars columns store values of independent
#                     variables, next column stores number of class (from 0
#                     to NClasses-1) which dataset element belongs to. Fractional
#                     values are rounded to nearest integer.
#     NPoints     -   training set size, NPoints&gt;=0
#     NVars       -   number of independent variables, NVars&gt;=1
#     NClasses    -   number of classes, NClasses&gt;=2
# 
# 
# OUTPUT PARAMETERS:
#     Info        -   return code:
#                     * -4, if internal EVD subroutine hasn't converged
#                     * -2, if there is a point with class number
#                           outside of [0..NClasses-1].
#                     * -1, if incorrect parameters was passed (NPoints&lt;0,
#                           NVars&lt;1, NClasses&lt;2)
#                     *  1, if task has been solved
#                     *  2, if there was a multicollinearity in training set,
#                           but task has been solved.
#     W           -   linear combination coefficients, array[0..NVars-1]
# 
#   -- ALGLIB --
#      Copyright 31.05.2008 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: info, w = xalglib.fisherlda(xy, npoints, nvars, nclasses)

</div></pre>
<a name='sub_fisherldan'></a><h3 class=pageheader><code>fisherldan</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# N-dimensional multiclass Fisher LDA
# 
# Subroutine finds coefficients of linear combinations which optimally separates
# training set on classes. It returns N-dimensional basis whose vector are sorted
# by quality of training set separation (in descending order).
# 
# INPUT PARAMETERS:
#     XY          -   training set, array[0..NPoints-1,0..NVars].
#                     First NVars columns store values of independent
#                     variables, next column stores number of class (from 0
#                     to NClasses-1) which dataset element belongs to. Fractional
#                     values are rounded to nearest integer.
#     NPoints     -   training set size, NPoints&gt;=0
#     NVars       -   number of independent variables, NVars&gt;=1
#     NClasses    -   number of classes, NClasses&gt;=2
# 
# 
# OUTPUT PARAMETERS:
#     Info        -   return code:
#                     * -4, if internal EVD subroutine hasn't converged
#                     * -2, if there is a point with class number
#                           outside of [0..NClasses-1].
#                     * -1, if incorrect parameters was passed (NPoints&lt;0,
#                           NVars&lt;1, NClasses&lt;2)
#                     *  1, if task has been solved
#                     *  2, if there was a multicollinearity in training set,
#                           but task has been solved.
#     W           -   basis, array[0..NVars-1,0..NVars-1]
#                     columns of matrix stores basis vectors, sorted by
#                     quality of training set separation (in descending order)
# 
#   -- ALGLIB --
#      Copyright 31.05.2008 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: info, w = xalglib.fisherldan(xy, npoints, nvars, nclasses)

</div></pre>
<a name=unit_legendre></a><h2 class=pageheader><code>legendre</code> module</h2>
<div class=pagecontent>
<h3 class=pageheader>Functions</h3>
<a href='#sub_legendrecalculate' class=toc>legendrecalculate</a><br>
<a href='#sub_legendrecoefficients' class=toc>legendrecoefficients</a><br>
<a href='#sub_legendresum' class=toc>legendresum</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='sub_legendrecalculate'></a><h3 class=pageheader><code>legendrecalculate</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Calculation of the value of the Legendre polynomial Pn.
# 
# Parameters:
#     n   -   degree, n&gt;=0
#     x   -   argument
# 
# Result:
#     the value of the Legendre polynomial Pn at x
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.legendrecalculate(n, x)

</div></pre>
<a name='sub_legendrecoefficients'></a><h3 class=pageheader><code>legendrecoefficients</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Representation of Pn as C[0] + C[1]*X + ... + C[N]*X^N
# 
# Input parameters:
#     N   -   polynomial degree, n&gt;=0
# 
# Output parameters:
#     C   -   coefficients
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: c = xalglib.legendrecoefficients(n)

</div></pre>
<a name='sub_legendresum'></a><h3 class=pageheader><code>legendresum</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Summation of Legendre polynomials using Clenshaws recurrence formula.
# 
# This routine calculates
#     c[0]*P0(x) + c[1]*P1(x) + ... + c[N]*PN(x)
# 
# Parameters:
#     n   -   degree, n&gt;=0
#     x   -   argument
# 
# Result:
#     the value of the Legendre polynomial at x
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.legendresum(c, n, x)

</div></pre>
<a name=unit_linreg></a><h2 class=pageheader><code>linreg</code> module</h2>
<div class=pagecontent>
<h3 class=pageheader>Classes</h3>
<a href='#struct_linearmodel' class=toc>linearmodel</a><br>
<a href='#struct_lrreport' class=toc>lrreport</a><br>
<h3 class=pageheader>Functions</h3>
<a href='#sub_lravgerror' class=toc>lravgerror</a><br>
<a href='#sub_lravgrelerror' class=toc>lravgrelerror</a><br>
<a href='#sub_lrbuild' class=toc>lrbuild</a><br>
<a href='#sub_lrbuilds' class=toc>lrbuilds</a><br>
<a href='#sub_lrbuildz' class=toc>lrbuildz</a><br>
<a href='#sub_lrbuildzs' class=toc>lrbuildzs</a><br>
<a href='#sub_lrpack' class=toc>lrpack</a><br>
<a href='#sub_lrprocess' class=toc>lrprocess</a><br>
<a href='#sub_lrrmserror' class=toc>lrrmserror</a><br>
<a href='#sub_lrunpack' class=toc>lrunpack</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='struct_linearmodel'></a><h3 class=pageheader><code>linearmodel</code> class</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# 
#

</div><div style='margin-top: 0; margin-bottom: 0;'><span style='font-weight: bold; color: green;'>class</span> linearmodel(object):
    ...

</div></pre>
<a name='struct_lrreport'></a><h3 class=pageheader><code>lrreport</code> class</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# LRReport structure contains additional information about linear model:
# * C             -   covariation matrix,  array[0..NVars,0..NVars].
#                     C[i,j] = Cov(A[i],A[j])
# * RMSError      -   root mean square error on a training set
# * AvgError      -   average error on a training set
# * AvgRelError   -   average relative error on a training set (excluding
#                     observations with zero function value).
# * CVRMSError    -   leave-one-out cross-validation estimate of
#                     generalization error. Calculated using fast algorithm
#                     with O(NVars*NPoints) complexity.
# * CVAvgError    -   cross-validation estimate of average error
# * CVAvgRelError -   cross-validation estimate of average relative error
# 
# All other fields of the structure are intended for internal use and should
# not be used outside ALGLIB.
#

</div><div style='margin-top: 0; margin-bottom: 0;'><span style='font-weight: bold; color: green;'>class</span> lrreport(object):
    ...

</div></pre>
<a name='sub_lravgerror'></a><h3 class=pageheader><code>lravgerror</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Average error on the test set
# 
# INPUT PARAMETERS:
#     LM      -   linear model
#     XY      -   test set
#     NPoints -   test set size
# 
# RESULT:
#     average error.
# 
#   -- ALGLIB --
#      Copyright 30.08.2008 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.lravgerror(lm, xy, npoints)

</div></pre>
<a name='sub_lravgrelerror'></a><h3 class=pageheader><code>lravgrelerror</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# RMS error on the test set
# 
# INPUT PARAMETERS:
#     LM      -   linear model
#     XY      -   test set
#     NPoints -   test set size
# 
# RESULT:
#     average relative error.
# 
#   -- ALGLIB --
#      Copyright 30.08.2008 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.lravgrelerror(lm, xy, npoints)

</div></pre>
<a name='sub_lrbuild'></a><h3 class=pageheader><code>lrbuild</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Linear regression
# 
# Subroutine builds model:
# 
#     Y = A(0)*X[0] + ... + A(N-1)*X[N-1] + A(N)
# 
# and model found in ALGLIB format, covariation matrix, training set  errors
# (rms,  average,  average  relative)   and  leave-one-out  cross-validation
# estimate of the generalization error. CV  estimate calculated  using  fast
# algorithm with O(NPoints*NVars) complexity.
# 
# When  covariation  matrix  is  calculated  standard deviations of function
# values are assumed to be equal to RMS error on the training set.
# 
# INPUT PARAMETERS:
#     XY          -   training set, array [0..NPoints-1,0..NVars]:
#                     * NVars columns - independent variables
#                     * last column - dependent variable
#     NPoints     -   training set size, NPoints&gt;NVars+1
#     NVars       -   number of independent variables
# 
# OUTPUT PARAMETERS:
#     Info        -   return code:
#                     * -255, in case of unknown internal error
#                     * -4, if internal SVD subroutine haven't converged
#                     * -1, if incorrect parameters was passed (NPoints&lt;NVars+2, NVars&lt;1).
#                     *  1, if subroutine successfully finished
#     LM          -   linear model in the ALGLIB format. Use subroutines of
#                     this unit to work with the model.
#     AR          -   additional results
# 
# 
#   -- ALGLIB --
#      Copyright 02.08.2008 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: info, lm, ar = xalglib.lrbuild(xy, npoints, nvars)

</div></pre>
<a name='sub_lrbuilds'></a><h3 class=pageheader><code>lrbuilds</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Linear regression
# 
# Variant of LRBuild which uses vector of standatd deviations (errors in
# function values).
# 
# INPUT PARAMETERS:
#     XY          -   training set, array [0..NPoints-1,0..NVars]:
#                     * NVars columns - independent variables
#                     * last column - dependent variable
#     S           -   standard deviations (errors in function values)
#                     array[0..NPoints-1], S[i]&gt;0.
#     NPoints     -   training set size, NPoints&gt;NVars+1
#     NVars       -   number of independent variables
# 
# OUTPUT PARAMETERS:
#     Info        -   return code:
#                     * -255, in case of unknown internal error
#                     * -4, if internal SVD subroutine haven't converged
#                     * -1, if incorrect parameters was passed (NPoints&lt;NVars+2, NVars&lt;1).
#                     * -2, if S[I]&lt;=0
#                     *  1, if subroutine successfully finished
#     LM          -   linear model in the ALGLIB format. Use subroutines of
#                     this unit to work with the model.
#     AR          -   additional results
# 
# 
#   -- ALGLIB --
#      Copyright 02.08.2008 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: info, lm, ar = xalglib.lrbuilds(xy, s, npoints, nvars)

</div></pre>
<a name='sub_lrbuildz'></a><h3 class=pageheader><code>lrbuildz</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Like LRBuild but builds model
# 
#     Y = A(0)*X[0] + ... + A(N-1)*X[N-1]
# 
# i.e. with zero constant term.
# 
#   -- ALGLIB --
#      Copyright 30.10.2008 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: info, lm, ar = xalglib.lrbuildz(xy, npoints, nvars)

</div></pre>
<a name='sub_lrbuildzs'></a><h3 class=pageheader><code>lrbuildzs</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Like LRBuildS, but builds model
# 
#     Y = A(0)*X[0] + ... + A(N-1)*X[N-1]
# 
# i.e. with zero constant term.
# 
#   -- ALGLIB --
#      Copyright 30.10.2008 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: info, lm, ar = xalglib.lrbuildzs(xy, s, npoints, nvars)

</div></pre>
<a name='sub_lrpack'></a><h3 class=pageheader><code>lrpack</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# &quot;Packs&quot; coefficients and creates linear model in ALGLIB format (LRUnpack
# reversed).
# 
# INPUT PARAMETERS:
#     V           -   coefficients, array[0..NVars]
#     NVars       -   number of independent variables
# 
# OUTPUT PAREMETERS:
#     LM          -   linear model.
# 
#   -- ALGLIB --
#      Copyright 30.08.2008 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: lm = xalglib.lrpack(v, nvars)

</div></pre>
<a name='sub_lrprocess'></a><h3 class=pageheader><code>lrprocess</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Procesing
# 
# INPUT PARAMETERS:
#     LM      -   linear model
#     X       -   input vector,  array[0..NVars-1].
# 
# Result:
#     value of linear model regression estimate
# 
#   -- ALGLIB --
#      Copyright 03.09.2008 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.lrprocess(lm, x)

</div></pre>
<a name='sub_lrrmserror'></a><h3 class=pageheader><code>lrrmserror</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# RMS error on the test set
# 
# INPUT PARAMETERS:
#     LM      -   linear model
#     XY      -   test set
#     NPoints -   test set size
# 
# RESULT:
#     root mean square error.
# 
#   -- ALGLIB --
#      Copyright 30.08.2008 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.lrrmserror(lm, xy, npoints)

</div></pre>
<a name='sub_lrunpack'></a><h3 class=pageheader><code>lrunpack</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Unpacks coefficients of linear model.
# 
# INPUT PARAMETERS:
#     LM          -   linear model in ALGLIB format
# 
# OUTPUT PARAMETERS:
#     V           -   coefficients, array[0..NVars]
#     NVars       -   number of independent variables (one less than number
#                     of coefficients)
# 
#   -- ALGLIB --
#      Copyright 30.08.2008 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: v, nvars = xalglib.lrunpack(lm)

</div></pre>
<a name=unit_logit></a><h2 class=pageheader><code>logit</code> module</h2>
<div class=pagecontent>
<h3 class=pageheader>Classes</h3>
<a href='#struct_logitmodel' class=toc>logitmodel</a><br>
<a href='#struct_mnlreport' class=toc>mnlreport</a><br>
<h3 class=pageheader>Functions</h3>
<a href='#sub_mnlavgce' class=toc>mnlavgce</a><br>
<a href='#sub_mnlavgerror' class=toc>mnlavgerror</a><br>
<a href='#sub_mnlavgrelerror' class=toc>mnlavgrelerror</a><br>
<a href='#sub_mnlclserror' class=toc>mnlclserror</a><br>
<a href='#sub_mnlpack' class=toc>mnlpack</a><br>
<a href='#sub_mnlprocess' class=toc>mnlprocess</a><br>
<a href='#sub_mnlprocessi' class=toc>mnlprocessi</a><br>
<a href='#sub_mnlrelclserror' class=toc>mnlrelclserror</a><br>
<a href='#sub_mnlrmserror' class=toc>mnlrmserror</a><br>
<a href='#sub_mnltrainh' class=toc>mnltrainh</a><br>
<a href='#sub_mnlunpack' class=toc>mnlunpack</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='struct_logitmodel'></a><h3 class=pageheader><code>logitmodel</code> class</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# 
#

</div><div style='margin-top: 0; margin-bottom: 0;'><span style='font-weight: bold; color: green;'>class</span> logitmodel(object):
    ...

</div></pre>
<a name='struct_mnlreport'></a><h3 class=pageheader><code>mnlreport</code> class</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# MNLReport structure contains information about training process:
# * NGrad     -   number of gradient calculations
# * NHess     -   number of Hessian calculations
#

</div><div style='margin-top: 0; margin-bottom: 0;'><span style='font-weight: bold; color: green;'>class</span> mnlreport(object):
    ...

</div></pre>
<a name='sub_mnlavgce'></a><h3 class=pageheader><code>mnlavgce</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Average cross-entropy (in bits per element) on the test set
# 
# INPUT PARAMETERS:
#     LM      -   logit model
#     XY      -   test set
#     NPoints -   test set size
# 
# RESULT:
#     CrossEntropy/(NPoints*ln(2)).
# 
#   -- ALGLIB --
#      Copyright 10.09.2008 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.mnlavgce(lm, xy, npoints)

</div></pre>
<a name='sub_mnlavgerror'></a><h3 class=pageheader><code>mnlavgerror</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Average error on the test set
# 
# INPUT PARAMETERS:
#     LM      -   logit model
#     XY      -   test set
#     NPoints -   test set size
# 
# RESULT:
#     average error (error when estimating posterior probabilities).
# 
#   -- ALGLIB --
#      Copyright 30.08.2008 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.mnlavgerror(lm, xy, npoints)

</div></pre>
<a name='sub_mnlavgrelerror'></a><h3 class=pageheader><code>mnlavgrelerror</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Average relative error on the test set
# 
# INPUT PARAMETERS:
#     LM      -   logit model
#     XY      -   test set
#     NPoints -   test set size
# 
# RESULT:
#     average relative error (error when estimating posterior probabilities).
# 
#   -- ALGLIB --
#      Copyright 30.08.2008 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.mnlavgrelerror(lm, xy, ssize)

</div></pre>
<a name='sub_mnlclserror'></a><h3 class=pageheader><code>mnlclserror</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Classification error on test set = MNLRelClsError*NPoints
# 
#   -- ALGLIB --
#      Copyright 10.09.2008 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.mnlclserror(lm, xy, npoints)

</div></pre>
<a name='sub_mnlpack'></a><h3 class=pageheader><code>mnlpack</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# &quot;Packs&quot; coefficients and creates logit model in ALGLIB format (MNLUnpack
# reversed).
# 
# INPUT PARAMETERS:
#     A           -   model (see MNLUnpack)
#     NVars       -   number of independent variables
#     NClasses    -   number of classes
# 
# OUTPUT PARAMETERS:
#     LM          -   logit model.
# 
#   -- ALGLIB --
#      Copyright 10.09.2008 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: lm = xalglib.mnlpack(a, nvars, nclasses)

</div></pre>
<a name='sub_mnlprocess'></a><h3 class=pageheader><code>mnlprocess</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Procesing
# 
# INPUT PARAMETERS:
#     LM      -   logit model, passed by non-constant reference
#                 (some fields of structure are used as temporaries
#                 when calculating model output).
#     X       -   input vector,  array[0..NVars-1].
#     Y       -   (possibly) preallocated buffer; if size of Y is less than
#                 NClasses, it will be reallocated.If it is large enough, it
#                 is NOT reallocated, so we can save some time on reallocation.
# 
# OUTPUT PARAMETERS:
#     Y       -   result, array[0..NClasses-1]
#                 Vector of posterior probabilities for classification task.
# 
#   -- ALGLIB --
#      Copyright 10.09.2008 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: y = xalglib.mnlprocess(lm, x, y)

</div></pre>
<a name='sub_mnlprocessi'></a><h3 class=pageheader><code>mnlprocessi</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# 'interactive'  variant  of  MNLProcess  for  languages  like  Python which
# support constructs like &quot;Y = MNLProcess(LM,X)&quot; and interactive mode of the
# interpreter
# 
# This function allocates new array on each call,  so  it  is  significantly
# slower than its 'non-interactive' counterpart, but it is  more  convenient
# when you call it from command line.
# 
#   -- ALGLIB --
#      Copyright 10.09.2008 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: y = xalglib.mnlprocessi(lm, x)

</div></pre>
<a name='sub_mnlrelclserror'></a><h3 class=pageheader><code>mnlrelclserror</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Relative classification error on the test set
# 
# INPUT PARAMETERS:
#     LM      -   logit model
#     XY      -   test set
#     NPoints -   test set size
# 
# RESULT:
#     percent of incorrectly classified cases.
# 
#   -- ALGLIB --
#      Copyright 10.09.2008 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.mnlrelclserror(lm, xy, npoints)

</div></pre>
<a name='sub_mnlrmserror'></a><h3 class=pageheader><code>mnlrmserror</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# RMS error on the test set
# 
# INPUT PARAMETERS:
#     LM      -   logit model
#     XY      -   test set
#     NPoints -   test set size
# 
# RESULT:
#     root mean square error (error when estimating posterior probabilities).
# 
#   -- ALGLIB --
#      Copyright 30.08.2008 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.mnlrmserror(lm, xy, npoints)

</div></pre>
<a name='sub_mnltrainh'></a><h3 class=pageheader><code>mnltrainh</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# This subroutine trains logit model.
# 
# INPUT PARAMETERS:
#     XY          -   training set, array[0..NPoints-1,0..NVars]
#                     First NVars columns store values of independent
#                     variables, next column stores number of class (from 0
#                     to NClasses-1) which dataset element belongs to. Fractional
#                     values are rounded to nearest integer.
#     NPoints     -   training set size, NPoints&gt;=1
#     NVars       -   number of independent variables, NVars&gt;=1
#     NClasses    -   number of classes, NClasses&gt;=2
# 
# OUTPUT PARAMETERS:
#     Info        -   return code:
#                     * -2, if there is a point with class number
#                           outside of [0..NClasses-1].
#                     * -1, if incorrect parameters was passed
#                           (NPoints&lt;NVars+2, NVars&lt;1, NClasses&lt;2).
#                     *  1, if task has been solved
#     LM          -   model built
#     Rep         -   training report
# 
#   -- ALGLIB --
#      Copyright 10.09.2008 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: info, lm, rep = xalglib.mnltrainh(xy, npoints, nvars, nclasses)

</div></pre>
<a name='sub_mnlunpack'></a><h3 class=pageheader><code>mnlunpack</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Unpacks coefficients of logit model. Logit model have form:
# 
#     P(class=i) = S(i) / (S(0) + S(1) + ... +S(M-1))
#           S(i) = Exp(A[i,0]*X[0] + ... + A[i,N-1]*X[N-1] + A[i,N]), when i&lt;M-1
#         S(M-1) = 1
# 
# INPUT PARAMETERS:
#     LM          -   logit model in ALGLIB format
# 
# OUTPUT PARAMETERS:
#     V           -   coefficients, array[0..NClasses-2,0..NVars]
#     NVars       -   number of independent variables
#     NClasses    -   number of classes
# 
#   -- ALGLIB --
#      Copyright 10.09.2008 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: a, nvars, nclasses = xalglib.mnlunpack(lm)

</div></pre>
<a name=unit_lsfit></a><h2 class=pageheader><code>lsfit</code> module</h2>
<div class=pagecontent>
<h3 class=pageheader>Classes</h3>
<a href='#struct_barycentricfitreport' class=toc>barycentricfitreport</a><br>
<a href='#struct_lsfitreport' class=toc>lsfitreport</a><br>
<a href='#struct_lsfitstate' class=toc>lsfitstate</a><br>
<a href='#struct_polynomialfitreport' class=toc>polynomialfitreport</a><br>
<a href='#struct_spline1dfitreport' class=toc>spline1dfitreport</a><br>
<h3 class=pageheader>Functions</h3>
<a href='#sub_barycentricfitfloaterhormann' class=toc>barycentricfitfloaterhormann</a><br>
<a href='#sub_barycentricfitfloaterhormannwc' class=toc>barycentricfitfloaterhormannwc</a><br>
<a href='#sub_lsfitcreatef' class=toc>lsfitcreatef</a><br>
<a href='#sub_lsfitcreatefg' class=toc>lsfitcreatefg</a><br>
<a href='#sub_lsfitcreatefgh' class=toc>lsfitcreatefgh</a><br>
<a href='#sub_lsfitcreatewf' class=toc>lsfitcreatewf</a><br>
<a href='#sub_lsfitcreatewfg' class=toc>lsfitcreatewfg</a><br>
<a href='#sub_lsfitcreatewfgh' class=toc>lsfitcreatewfgh</a><br>
<a href='#sub_lsfitfit' class=toc>lsfitfit</a><br>
<a href='#sub_lsfitlinear' class=toc>lsfitlinear</a><br>
<a href='#sub_lsfitlinearc' class=toc>lsfitlinearc</a><br>
<a href='#sub_lsfitlinearw' class=toc>lsfitlinearw</a><br>
<a href='#sub_lsfitlinearwc' class=toc>lsfitlinearwc</a><br>
<a href='#sub_lsfitresults' class=toc>lsfitresults</a><br>
<a href='#sub_lsfitsetcond' class=toc>lsfitsetcond</a><br>
<a href='#sub_lsfitsetstpmax' class=toc>lsfitsetstpmax</a><br>
<a href='#sub_lsfitsetxrep' class=toc>lsfitsetxrep</a><br>
<a href='#sub_polynomialfit' class=toc>polynomialfit</a><br>
<a href='#sub_polynomialfitwc' class=toc>polynomialfitwc</a><br>
<a href='#sub_spline1dfitcubic' class=toc>spline1dfitcubic</a><br>
<a href='#sub_spline1dfitcubicwc' class=toc>spline1dfitcubicwc</a><br>
<a href='#sub_spline1dfithermite' class=toc>spline1dfithermite</a><br>
<a href='#sub_spline1dfithermitewc' class=toc>spline1dfithermitewc</a><br>
<a href='#sub_spline1dfitpenalized' class=toc>spline1dfitpenalized</a><br>
<a href='#sub_spline1dfitpenalizedw' class=toc>spline1dfitpenalizedw</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
<tr align=left valign=top><td><a href='#example_lsfit_d_f' class=toc>lsfit_d_f</a></td><td width=15>&nbsp;</td><td>Nonlinear fitting using function value only</td></tr>
<tr align=left valign=top><td><a href='#example_lsfit_d_fg' class=toc>lsfit_d_fg</a></td><td width=15>&nbsp;</td><td>Nonlinear fitting using gradient</td></tr>
<tr align=left valign=top><td><a href='#example_lsfit_d_fgh' class=toc>lsfit_d_fgh</a></td><td width=15>&nbsp;</td><td>Nonlinear fitting using gradient and Hessian</td></tr>
<tr align=left valign=top><td><a href='#example_lsfit_d_lin' class=toc>lsfit_d_lin</a></td><td width=15>&nbsp;</td><td>Unconstrained (general) linear least squares fitting with and without weights</td></tr>
<tr align=left valign=top><td><a href='#example_lsfit_d_linc' class=toc>lsfit_d_linc</a></td><td width=15>&nbsp;</td><td>Constrained (general) linear least squares fitting with and without weights</td></tr>
<tr align=left valign=top><td><a href='#example_lsfit_d_pol' class=toc>lsfit_d_pol</a></td><td width=15>&nbsp;</td><td>Unconstrained polynomial fitting</td></tr>
<tr align=left valign=top><td><a href='#example_lsfit_d_polc' class=toc>lsfit_d_polc</a></td><td width=15>&nbsp;</td><td>Constrained polynomial fitting</td></tr>
<tr align=left valign=top><td><a href='#example_lsfit_d_spline' class=toc>lsfit_d_spline</a></td><td width=15>&nbsp;</td><td>Unconstrained fitting by penalized regression spline</td></tr>
</table></div>
<a name='struct_barycentricfitreport'></a><h3 class=pageheader><code>barycentricfitreport</code> class</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Barycentric fitting report:
#     RMSError        RMS error
#     AvgError        average error
#     AvgRelError     average relative error (for non-zero Y[I])
#     MaxError        maximum error
#     TaskRCond       reciprocal of task's condition number
#

</div><div style='margin-top: 0; margin-bottom: 0;'><span style='font-weight: bold; color: green;'>class</span> barycentricfitreport(object):
    ...

</div></pre>
<a name='struct_lsfitreport'></a><h3 class=pageheader><code>lsfitreport</code> class</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Least squares fitting report:
#     TaskRCond       reciprocal of task's condition number
#     RMSError        RMS error
#     AvgError        average error
#     AvgRelError     average relative error (for non-zero Y[I])
#     MaxError        maximum error
#

</div><div style='margin-top: 0; margin-bottom: 0;'><span style='font-weight: bold; color: green;'>class</span> lsfitreport(object):
    ...

</div></pre>
<a name='struct_lsfitstate'></a><h3 class=pageheader><code>lsfitstate</code> class</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Nonlinear fitter.
# 
# You should use ALGLIB functions to work with fitter.
# Never try to access its fields directly!
#

</div><div style='margin-top: 0; margin-bottom: 0;'><span style='font-weight: bold; color: green;'>class</span> lsfitstate(object):
    ...

</div></pre>
<a name='struct_polynomialfitreport'></a><h3 class=pageheader><code>polynomialfitreport</code> class</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Polynomial fitting report:
#     TaskRCond       reciprocal of task's condition number
#     RMSError        RMS error
#     AvgError        average error
#     AvgRelError     average relative error (for non-zero Y[I])
#     MaxError        maximum error
#

</div><div style='margin-top: 0; margin-bottom: 0;'><span style='font-weight: bold; color: green;'>class</span> polynomialfitreport(object):
    ...

</div></pre>
<a name='struct_spline1dfitreport'></a><h3 class=pageheader><code>spline1dfitreport</code> class</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Spline fitting report:
#     RMSError        RMS error
#     AvgError        average error
#     AvgRelError     average relative error (for non-zero Y[I])
#     MaxError        maximum error
# 
# Fields  below are  filled  by   obsolete    functions   (Spline1DFitCubic,
# Spline1DFitHermite). Modern fitting functions do NOT fill these fields:
#     TaskRCond       reciprocal of task's condition number
#

</div><div style='margin-top: 0; margin-bottom: 0;'><span style='font-weight: bold; color: green;'>class</span> spline1dfitreport(object):
    ...

</div></pre>
<a name='sub_barycentricfitfloaterhormann'></a><h3 class=pageheader><code>barycentricfitfloaterhormann</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Rational least squares fitting using  Floater-Hormann  rational  functions
# with optimal D chosen from [0,9].
# 
# Equidistant  grid  with M node on [min(x),max(x)]  is  used to build basis
# functions. Different values of D are tried, optimal  D  (least  root  mean
# square error) is chosen.  Task  is  linear, so linear least squares solver
# is used. Complexity  of  this  computational  scheme is  O(N*M^2)  (mostly
# dominated by the least squares solver).
# 
# INPUT PARAMETERS:
#     X   -   points, array[0..N-1].
#     Y   -   function values, array[0..N-1].
#     N   -   number of points, N&gt;0.
#     M   -   number of basis functions ( = number_of_nodes), M&gt;=2.
# 
# OUTPUT PARAMETERS:
#     Info-   same format as in LSFitLinearWC() subroutine.
#             * Info&gt;0    task is solved
#             * Info&lt;=0   an error occured:
#                         -4 means inconvergence of internal SVD
#                         -3 means inconsistent constraints
#     B   -   barycentric interpolant.
#     Rep -   report, same format as in LSFitLinearWC() subroutine.
#             Following fields are set:
#             * DBest         best value of the D parameter
#             * RMSError      rms error on the (X,Y).
#             * AvgError      average error on the (X,Y).
#             * AvgRelError   average relative error on the non-zero Y
#             * MaxError      maximum error
#                             NON-WEIGHTED ERRORS ARE CALCULATED
# 
#   -- ALGLIB PROJECT --
#      Copyright 18.08.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: info, b, rep = xalglib.barycentricfitfloaterhormann(x, y, n, m)

</div></pre>
<a name='sub_barycentricfitfloaterhormannwc'></a><h3 class=pageheader><code>barycentricfitfloaterhormannwc</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Weghted rational least  squares  fitting  using  Floater-Hormann  rational
# functions  with  optimal  D  chosen  from  [0,9],  with  constraints   and
# individual weights.
# 
# Equidistant  grid  with M node on [min(x),max(x)]  is  used to build basis
# functions. Different values of D are tried, optimal D (least WEIGHTED root
# mean square error) is chosen.  Task  is  linear,  so  linear least squares
# solver  is  used.  Complexity  of  this  computational  scheme is O(N*M^2)
# (mostly dominated by the least squares solver).
# 
# SEE ALSO
# * BarycentricFitFloaterHormann(), &quot;lightweight&quot; fitting without invididual
#   weights and constraints.
# 
# INPUT PARAMETERS:
#     X   -   points, array[0..N-1].
#     Y   -   function values, array[0..N-1].
#     W   -   weights, array[0..N-1]
#             Each summand in square  sum  of  approximation deviations from
#             given  values  is  multiplied  by  the square of corresponding
#             weight. Fill it by 1's if you don't  want  to  solve  weighted
#             task.
#     N   -   number of points, N&gt;0.
#     XC  -   points where function values/derivatives are constrained,
#             array[0..K-1].
#     YC  -   values of constraints, array[0..K-1]
#     DC  -   array[0..K-1], types of constraints:
#             * DC[i]=0   means that S(XC[i])=YC[i]
#             * DC[i]=1   means that S'(XC[i])=YC[i]
#             SEE BELOW FOR IMPORTANT INFORMATION ON CONSTRAINTS
#     K   -   number of constraints, 0&lt;=K&lt;M.
#             K=0 means no constraints (XC/YC/DC are not used in such cases)
#     M   -   number of basis functions ( = number_of_nodes), M&gt;=2.
# 
# OUTPUT PARAMETERS:
#     Info-   same format as in LSFitLinearWC() subroutine.
#             * Info&gt;0    task is solved
#             * Info&lt;=0   an error occured:
#                         -4 means inconvergence of internal SVD
#                         -3 means inconsistent constraints
#                         -1 means another errors in parameters passed
#                            (N&lt;=0, for example)
#     B   -   barycentric interpolant.
#     Rep -   report, same format as in LSFitLinearWC() subroutine.
#             Following fields are set:
#             * DBest         best value of the D parameter
#             * RMSError      rms error on the (X,Y).
#             * AvgError      average error on the (X,Y).
#             * AvgRelError   average relative error on the non-zero Y
#             * MaxError      maximum error
#                             NON-WEIGHTED ERRORS ARE CALCULATED
# 
# IMPORTANT:
#     this subroutine doesn't calculate task's condition number for K&lt;&gt;0.
# 
# SETTING CONSTRAINTS - DANGERS AND OPPORTUNITIES:
# 
# Setting constraints can lead  to undesired  results,  like ill-conditioned
# behavior, or inconsistency being detected. From the other side,  it allows
# us to improve quality of the fit. Here we summarize  our  experience  with
# constrained barycentric interpolants:
# * excessive  constraints  can  be  inconsistent.   Floater-Hormann   basis
#   functions aren't as flexible as splines (although they are very smooth).
# * the more evenly constraints are spread across [min(x),max(x)],  the more
#   chances that they will be consistent
# * the  greater  is  M (given  fixed  constraints),  the  more chances that
#   constraints will be consistent
# * in the general case, consistency of constraints IS NOT GUARANTEED.
# * in the several special cases, however, we CAN guarantee consistency.
# * one of this cases is constraints on the function  VALUES at the interval
#   boundaries. Note that consustency of the  constraints  on  the  function
#   DERIVATIVES is NOT guaranteed (you can use in such cases  cubic  splines
#   which are more flexible).
# * another  special  case  is ONE constraint on the function value (OR, but
#   not AND, derivative) anywhere in the interval
# 
# Our final recommendation is to use constraints  WHEN  AND  ONLY  WHEN  you
# can't solve your task without them. Anything beyond  special  cases  given
# above is not guaranteed and may result in inconsistency.
# 
#   -- ALGLIB PROJECT --
#      Copyright 18.08.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: info, b, rep = xalglib.barycentricfitfloaterhormannwc(x, y, w, n, xc, yc, dc, k, m)

</div></pre>
<a name='sub_lsfitcreatef'></a><h3 class=pageheader><code>lsfitcreatef</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Nonlinear least squares fitting using function values only.
# 
# Combination of numerical differentiation and secant updates is used to
# obtain function Jacobian.
# 
# Nonlinear task min(F(c)) is solved, where
# 
#     F(c) = (f(c,x[0])-y[0])^2 + ... + (f(c,x[n-1])-y[n-1])^2,
# 
#     * N is a number of points,
#     * M is a dimension of a space points belong to,
#     * K is a dimension of a space of parameters being fitted,
#     * w is an N-dimensional vector of weight coefficients,
#     * x is a set of N points, each of them is an M-dimensional vector,
#     * c is a K-dimensional vector of parameters being fitted
# 
# This subroutine uses only f(c,x[i]).
# 
# INPUT PARAMETERS:
#     X       -   array[0..N-1,0..M-1], points (one row = one point)
#     Y       -   array[0..N-1], function values.
#     C       -   array[0..K-1], initial approximation to the solution,
#     N       -   number of points, N&gt;1
#     M       -   dimension of space
#     K       -   number of parameters being fitted
#     DiffStep-   numerical differentiation step;
#                 should not be very small or large;
#                 large = loss of accuracy
#                 small = growth of round-off errors
# 
# OUTPUT PARAMETERS:
#     State   -   structure which stores algorithm state
# 
#   -- ALGLIB --
#      Copyright 18.10.2008 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: state = xalglib.lsfitcreatef(x, y, c, n, m, k, diffstep)
SYNTAX: state = xalglib.lsfitcreatef(x, y, c, diffstep)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_lsfit_d_f' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_lsfitcreatefg'></a><h3 class=pageheader><code>lsfitcreatefg</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Nonlinear least squares fitting using gradient only, without individual
# weights.
# 
# Nonlinear task min(F(c)) is solved, where
# 
#     F(c) = ((f(c,x[0])-y[0]))^2 + ... + ((f(c,x[n-1])-y[n-1]))^2,
# 
#     * N is a number of points,
#     * M is a dimension of a space points belong to,
#     * K is a dimension of a space of parameters being fitted,
#     * x is a set of N points, each of them is an M-dimensional vector,
#     * c is a K-dimensional vector of parameters being fitted
# 
# This subroutine uses only f(c,x[i]) and its gradient.
# 
# INPUT PARAMETERS:
#     X       -   array[0..N-1,0..M-1], points (one row = one point)
#     Y       -   array[0..N-1], function values.
#     C       -   array[0..K-1], initial approximation to the solution,
#     N       -   number of points, N&gt;1
#     M       -   dimension of space
#     K       -   number of parameters being fitted
#     CheapFG -   boolean flag, which is:
#                 * True  if both function and gradient calculation complexity
#                         are less than O(M^2).  An improved  algorithm  can
#                         be  used  which corresponds  to  FGJ  scheme  from
#                         MINLM unit.
#                 * False otherwise.
#                         Standard Jacibian-bases  Levenberg-Marquardt  algo
#                         will be used (FJ scheme).
# 
# OUTPUT PARAMETERS:
#     State   -   structure which stores algorithm state
# 
#   -- ALGLIB --
#      Copyright 17.08.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: state = xalglib.lsfitcreatefg(x, y, c, n, m, k, cheapfg)
SYNTAX: state = xalglib.lsfitcreatefg(x, y, c, cheapfg)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_lsfit_d_fg' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_lsfitcreatefgh'></a><h3 class=pageheader><code>lsfitcreatefgh</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Nonlinear least squares fitting using gradient/Hessian, without individial
# weights.
# 
# Nonlinear task min(F(c)) is solved, where
# 
#     F(c) = ((f(c,x[0])-y[0]))^2 + ... + ((f(c,x[n-1])-y[n-1]))^2,
# 
#     * N is a number of points,
#     * M is a dimension of a space points belong to,
#     * K is a dimension of a space of parameters being fitted,
#     * x is a set of N points, each of them is an M-dimensional vector,
#     * c is a K-dimensional vector of parameters being fitted
# 
# This subroutine uses f(c,x[i]), its gradient and its Hessian.
# 
# INPUT PARAMETERS:
#     X       -   array[0..N-1,0..M-1], points (one row = one point)
#     Y       -   array[0..N-1], function values.
#     C       -   array[0..K-1], initial approximation to the solution,
#     N       -   number of points, N&gt;1
#     M       -   dimension of space
#     K       -   number of parameters being fitted
# 
# OUTPUT PARAMETERS:
#     State   -   structure which stores algorithm state
# 
# 
#   -- ALGLIB --
#      Copyright 17.08.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: state = xalglib.lsfitcreatefgh(x, y, c, n, m, k)
SYNTAX: state = xalglib.lsfitcreatefgh(x, y, c)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_lsfit_d_fgh' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_lsfitcreatewf'></a><h3 class=pageheader><code>lsfitcreatewf</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Weighted nonlinear least squares fitting using function values only.
# 
# Combination of numerical differentiation and secant updates is used to
# obtain function Jacobian.
# 
# Nonlinear task min(F(c)) is solved, where
# 
#     F(c) = (w[0]*(f(c,x[0])-y[0]))^2 + ... + (w[n-1]*(f(c,x[n-1])-y[n-1]))^2,
# 
#     * N is a number of points,
#     * M is a dimension of a space points belong to,
#     * K is a dimension of a space of parameters being fitted,
#     * w is an N-dimensional vector of weight coefficients,
#     * x is a set of N points, each of them is an M-dimensional vector,
#     * c is a K-dimensional vector of parameters being fitted
# 
# This subroutine uses only f(c,x[i]).
# 
# INPUT PARAMETERS:
#     X       -   array[0..N-1,0..M-1], points (one row = one point)
#     Y       -   array[0..N-1], function values.
#     W       -   weights, array[0..N-1]
#     C       -   array[0..K-1], initial approximation to the solution,
#     N       -   number of points, N&gt;1
#     M       -   dimension of space
#     K       -   number of parameters being fitted
#     DiffStep-   numerical differentiation step;
#                 should not be very small or large;
#                 large = loss of accuracy
#                 small = growth of round-off errors
# 
# OUTPUT PARAMETERS:
#     State   -   structure which stores algorithm state
# 
#   -- ALGLIB --
#      Copyright 18.10.2008 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: state = xalglib.lsfitcreatewf(x, y, w, c, n, m, k, diffstep)
SYNTAX: state = xalglib.lsfitcreatewf(x, y, w, c, diffstep)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_lsfit_d_f' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_lsfitcreatewfg'></a><h3 class=pageheader><code>lsfitcreatewfg</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Weighted nonlinear least squares fitting using gradient only.
# 
# Nonlinear task min(F(c)) is solved, where
# 
#     F(c) = (w[0]*(f(c,x[0])-y[0]))^2 + ... + (w[n-1]*(f(c,x[n-1])-y[n-1]))^2,
# 
#     * N is a number of points,
#     * M is a dimension of a space points belong to,
#     * K is a dimension of a space of parameters being fitted,
#     * w is an N-dimensional vector of weight coefficients,
#     * x is a set of N points, each of them is an M-dimensional vector,
#     * c is a K-dimensional vector of parameters being fitted
# 
# This subroutine uses only f(c,x[i]) and its gradient.
# 
# INPUT PARAMETERS:
#     X       -   array[0..N-1,0..M-1], points (one row = one point)
#     Y       -   array[0..N-1], function values.
#     W       -   weights, array[0..N-1]
#     C       -   array[0..K-1], initial approximation to the solution,
#     N       -   number of points, N&gt;1
#     M       -   dimension of space
#     K       -   number of parameters being fitted
#     CheapFG -   boolean flag, which is:
#                 * True  if both function and gradient calculation complexity
#                         are less than O(M^2).  An improved  algorithm  can
#                         be  used  which corresponds  to  FGJ  scheme  from
#                         MINLM unit.
#                 * False otherwise.
#                         Standard Jacibian-bases  Levenberg-Marquardt  algo
#                         will be used (FJ scheme).
# 
# OUTPUT PARAMETERS:
#     State   -   structure which stores algorithm state
# 
# See also:
#     LSFitResults
#     LSFitCreateFG (fitting without weights)
#     LSFitCreateWFGH (fitting using Hessian)
#     LSFitCreateFGH (fitting using Hessian, without weights)
# 
#   -- ALGLIB --
#      Copyright 17.08.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: state = xalglib.lsfitcreatewfg(x, y, w, c, n, m, k, cheapfg)
SYNTAX: state = xalglib.lsfitcreatewfg(x, y, w, c, cheapfg)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_lsfit_d_fg' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_lsfitcreatewfgh'></a><h3 class=pageheader><code>lsfitcreatewfgh</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Weighted nonlinear least squares fitting using gradient/Hessian.
# 
# Nonlinear task min(F(c)) is solved, where
# 
#     F(c) = (w[0]*(f(c,x[0])-y[0]))^2 + ... + (w[n-1]*(f(c,x[n-1])-y[n-1]))^2,
# 
#     * N is a number of points,
#     * M is a dimension of a space points belong to,
#     * K is a dimension of a space of parameters being fitted,
#     * w is an N-dimensional vector of weight coefficients,
#     * x is a set of N points, each of them is an M-dimensional vector,
#     * c is a K-dimensional vector of parameters being fitted
# 
# This subroutine uses f(c,x[i]), its gradient and its Hessian.
# 
# INPUT PARAMETERS:
#     X       -   array[0..N-1,0..M-1], points (one row = one point)
#     Y       -   array[0..N-1], function values.
#     W       -   weights, array[0..N-1]
#     C       -   array[0..K-1], initial approximation to the solution,
#     N       -   number of points, N&gt;1
#     M       -   dimension of space
#     K       -   number of parameters being fitted
# 
# OUTPUT PARAMETERS:
#     State   -   structure which stores algorithm state
# 
#   -- ALGLIB --
#      Copyright 17.08.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: state = xalglib.lsfitcreatewfgh(x, y, w, c, n, m, k)
SYNTAX: state = xalglib.lsfitcreatewfgh(x, y, w, c)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_lsfit_d_fgh' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_lsfitfit'></a><h3 class=pageheader><code>lsfitfit</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# This family of functions is used to launcn iterations of nonlinear fitter
# 
# These functions accept following parameters:
#     state   -   algorithm state
#     func    -   callback which calculates function (or merit function)
#                 value func at given point x
#     grad    -   callback which calculates function (or merit function)
#                 value func and gradient grad at given point x
#     hess    -   callback which calculates function (or merit function)
#                 value func, gradient grad and Hessian hess at given point x
#     rep     -   optional callback which is called after each iteration
#                 can be NULL
#     ptr     -   optional pointer which is passed to func/grad/hess/jac/rep
#                 can be NULL
# 
# NOTES:
# 
# 1. this algorithm is somewhat unusual because it works with  parameterized
#    function f(C,X), where X is a function argument (we  have  many  points
#    which are characterized by different  argument  values),  and  C  is  a
#    parameter to fit.
# 
#    For example, if we want to do linear fit by f(c0,c1,x) = c0*x+c1,  then
#    x will be argument, and {c0,c1} will be parameters.
# 
#    It is important to understand that this algorithm finds minimum in  the
#    space of function PARAMETERS (not arguments), so it  needs  derivatives
#    of f() with respect to C, not X.
# 
#    In the example above it will need f=c0*x+c1 and {df/dc0,df/dc1} = {x,1}
#    instead of {df/dx} = {c0}.
# 
# 2. Callback functions accept C as the first parameter, and X as the second
# 
# 3. If  state  was  created  with  LSFitCreateFG(),  algorithm  needs  just
#    function   and   its   gradient,   but   if   state   was  created with
#    LSFitCreateFGH(), algorithm will need function, gradient and Hessian.
# 
#    According  to  the  said  above,  there  ase  several  versions of this
#    function, which accept different sets of callbacks.
# 
#    This flexibility opens way to subtle errors - you may create state with
#    LSFitCreateFGH() (optimization using Hessian), but call function  which
#    does not accept Hessian. So when algorithm will request Hessian,  there
#    will be no callback to call. In this case exception will be thrown.
# 
#    Be careful to avoid such errors because there is no way to find them at
#    compile time - you can see them at runtime only.
# 
#   -- ALGLIB --
#      Copyright 17.08.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: xalglib.lsfitfit_f(state, func, rep = None, param = None)
SYNTAX: xalglib.lsfitfit_fg(state, func, grad, rep = None, param = None)
SYNTAX: xalglib.lsfitfit_fgh(state, func, grad, hess, rep = None, param = None)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_lsfit_d_f' class=nav>[1]</a>&nbsp;&nbsp;<a href='#example_lsfit_d_fg' class=nav>[2]</a>&nbsp;&nbsp;<a href='#example_lsfit_d_fgh' class=nav>[3]</a>&nbsp;&nbsp;</p>
<a name='sub_lsfitlinear'></a><h3 class=pageheader><code>lsfitlinear</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Linear least squares fitting.
# 
# QR decomposition is used to reduce task to MxM, then triangular solver  or
# SVD-based solver is used depending on condition number of the  system.  It
# allows to maximize speed and retain decent accuracy.
# 
# INPUT PARAMETERS:
#     Y       -   array[0..N-1] Function values in  N  points.
#     FMatrix -   a table of basis functions values, array[0..N-1, 0..M-1].
#                 FMatrix[I, J] - value of J-th basis function in I-th point.
#     N       -   number of points used. N&gt;=1.
#     M       -   number of basis functions, M&gt;=1.
# 
# OUTPUT PARAMETERS:
#     Info    -   error code:
#                 * -4    internal SVD decomposition subroutine failed (very
#                         rare and for degenerate systems only)
#                 *  1    task is solved
#     C       -   decomposition coefficients, array[0..M-1]
#     Rep     -   fitting report. Following fields are set:
#                 * Rep.TaskRCond     reciprocal of condition number
#                 * RMSError          rms error on the (X,Y).
#                 * AvgError          average error on the (X,Y).
#                 * AvgRelError       average relative error on the non-zero Y
#                 * MaxError          maximum error
#                                     NON-WEIGHTED ERRORS ARE CALCULATED
# 
#   -- ALGLIB --
#      Copyright 17.08.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: info, c, rep = xalglib.lsfitlinear(y, fmatrix, n, m)
SYNTAX: info, c, rep = xalglib.lsfitlinear(y, fmatrix)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_lsfit_d_lin' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_lsfitlinearc'></a><h3 class=pageheader><code>lsfitlinearc</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Constained linear least squares fitting.
# 
# This  is  variation  of LSFitLinear(),  which searchs for min|A*x=b| given
# that  K  additional  constaints  C*x=bc are satisfied. It reduces original
# task to modified one: min|B*y-d| WITHOUT constraints,  then  LSFitLinear()
# is called.
# 
# INPUT PARAMETERS:
#     Y       -   array[0..N-1] Function values in  N  points.
#     FMatrix -   a table of basis functions values, array[0..N-1, 0..M-1].
#                 FMatrix[I,J] - value of J-th basis function in I-th point.
#     CMatrix -   a table of constaints, array[0..K-1,0..M].
#                 I-th row of CMatrix corresponds to I-th linear constraint:
#                 CMatrix[I,0]*C[0] + ... + CMatrix[I,M-1]*C[M-1] = CMatrix[I,M]
#     N       -   number of points used. N&gt;=1.
#     M       -   number of basis functions, M&gt;=1.
#     K       -   number of constraints, 0 &lt;= K &lt; M
#                 K=0 corresponds to absence of constraints.
# 
# OUTPUT PARAMETERS:
#     Info    -   error code:
#                 * -4    internal SVD decomposition subroutine failed (very
#                         rare and for degenerate systems only)
#                 * -3    either   too   many  constraints  (M   or   more),
#                         degenerate  constraints   (some   constraints  are
#                         repetead twice) or inconsistent  constraints  were
#                         specified.
#                 *  1    task is solved
#     C       -   decomposition coefficients, array[0..M-1]
#     Rep     -   fitting report. Following fields are set:
#                 * RMSError          rms error on the (X,Y).
#                 * AvgError          average error on the (X,Y).
#                 * AvgRelError       average relative error on the non-zero Y
#                 * MaxError          maximum error
#                                     NON-WEIGHTED ERRORS ARE CALCULATED
# 
# IMPORTANT:
#     this subroitine doesn't calculate task's condition number for K&lt;&gt;0.
# 
#   -- ALGLIB --
#      Copyright 07.09.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: info, c, rep = xalglib.lsfitlinearc(y, fmatrix, cmatrix, n, m, k)
SYNTAX: info, c, rep = xalglib.lsfitlinearc(y, fmatrix, cmatrix)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_lsfit_d_linc' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_lsfitlinearw'></a><h3 class=pageheader><code>lsfitlinearw</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Weighted linear least squares fitting.
# 
# QR decomposition is used to reduce task to MxM, then triangular solver  or
# SVD-based solver is used depending on condition number of the  system.  It
# allows to maximize speed and retain decent accuracy.
# 
# INPUT PARAMETERS:
#     Y       -   array[0..N-1] Function values in  N  points.
#     W       -   array[0..N-1]  Weights  corresponding to function  values.
#                 Each summand in square  sum  of  approximation  deviations
#                 from  given  values  is  multiplied  by  the   square   of
#                 corresponding weight.
#     FMatrix -   a table of basis functions values, array[0..N-1, 0..M-1].
#                 FMatrix[I, J] - value of J-th basis function in I-th point.
#     N       -   number of points used. N&gt;=1.
#     M       -   number of basis functions, M&gt;=1.
# 
# OUTPUT PARAMETERS:
#     Info    -   error code:
#                 * -4    internal SVD decomposition subroutine failed (very
#                         rare and for degenerate systems only)
#                 * -1    incorrect N/M were specified
#                 *  1    task is solved
#     C       -   decomposition coefficients, array[0..M-1]
#     Rep     -   fitting report. Following fields are set:
#                 * Rep.TaskRCond     reciprocal of condition number
#                 * RMSError          rms error on the (X,Y).
#                 * AvgError          average error on the (X,Y).
#                 * AvgRelError       average relative error on the non-zero Y
#                 * MaxError          maximum error
#                                     NON-WEIGHTED ERRORS ARE CALCULATED
# 
#   -- ALGLIB --
#      Copyright 17.08.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: info, c, rep = xalglib.lsfitlinearw(y, w, fmatrix, n, m)
SYNTAX: info, c, rep = xalglib.lsfitlinearw(y, w, fmatrix)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_lsfit_d_lin' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_lsfitlinearwc'></a><h3 class=pageheader><code>lsfitlinearwc</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Weighted constained linear least squares fitting.
# 
# This  is  variation  of LSFitLinearW(), which searchs for min|A*x=b| given
# that  K  additional  constaints  C*x=bc are satisfied. It reduces original
# task to modified one: min|B*y-d| WITHOUT constraints,  then LSFitLinearW()
# is called.
# 
# INPUT PARAMETERS:
#     Y       -   array[0..N-1] Function values in  N  points.
#     W       -   array[0..N-1]  Weights  corresponding to function  values.
#                 Each summand in square  sum  of  approximation  deviations
#                 from  given  values  is  multiplied  by  the   square   of
#                 corresponding weight.
#     FMatrix -   a table of basis functions values, array[0..N-1, 0..M-1].
#                 FMatrix[I,J] - value of J-th basis function in I-th point.
#     CMatrix -   a table of constaints, array[0..K-1,0..M].
#                 I-th row of CMatrix corresponds to I-th linear constraint:
#                 CMatrix[I,0]*C[0] + ... + CMatrix[I,M-1]*C[M-1] = CMatrix[I,M]
#     N       -   number of points used. N&gt;=1.
#     M       -   number of basis functions, M&gt;=1.
#     K       -   number of constraints, 0 &lt;= K &lt; M
#                 K=0 corresponds to absence of constraints.
# 
# OUTPUT PARAMETERS:
#     Info    -   error code:
#                 * -4    internal SVD decomposition subroutine failed (very
#                         rare and for degenerate systems only)
#                 * -3    either   too   many  constraints  (M   or   more),
#                         degenerate  constraints   (some   constraints  are
#                         repetead twice) or inconsistent  constraints  were
#                         specified.
#                 *  1    task is solved
#     C       -   decomposition coefficients, array[0..M-1]
#     Rep     -   fitting report. Following fields are set:
#                 * RMSError          rms error on the (X,Y).
#                 * AvgError          average error on the (X,Y).
#                 * AvgRelError       average relative error on the non-zero Y
#                 * MaxError          maximum error
#                                     NON-WEIGHTED ERRORS ARE CALCULATED
# 
# IMPORTANT:
#     this subroitine doesn't calculate task's condition number for K&lt;&gt;0.
# 
#   -- ALGLIB --
#      Copyright 07.09.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: info, c, rep = xalglib.lsfitlinearwc(y, w, fmatrix, cmatrix, n, m, k)
SYNTAX: info, c, rep = xalglib.lsfitlinearwc(y, w, fmatrix, cmatrix)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_lsfit_d_linc' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_lsfitresults'></a><h3 class=pageheader><code>lsfitresults</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Nonlinear least squares fitting results.
# 
# Called after return from LSFitFit().
# 
# INPUT PARAMETERS:
#     State   -   algorithm state
# 
# OUTPUT PARAMETERS:
#     Info    -   completetion code:
#                     *  1    relative function improvement is no more than
#                             EpsF.
#                     *  2    relative step is no more than EpsX.
#                     *  4    gradient norm is no more than EpsG
#                     *  5    MaxIts steps was taken
#                     *  7    stopping conditions are too stringent,
#                             further improvement is impossible
#     C       -   array[0..K-1], solution
#     Rep     -   optimization report. Following fields are set:
#                 * Rep.TerminationType completetion code:
#                 * RMSError          rms error on the (X,Y).
#                 * AvgError          average error on the (X,Y).
#                 * AvgRelError       average relative error on the non-zero Y
#                 * MaxError          maximum error
#                                     NON-WEIGHTED ERRORS ARE CALCULATED
# 
# 
#   -- ALGLIB --
#      Copyright 17.08.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: info, c, rep = xalglib.lsfitresults(state)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_lsfit_d_f' class=nav>[1]</a>&nbsp;&nbsp;<a href='#example_lsfit_d_fg' class=nav>[2]</a>&nbsp;&nbsp;<a href='#example_lsfit_d_fgh' class=nav>[3]</a>&nbsp;&nbsp;</p>
<a name='sub_lsfitsetcond'></a><h3 class=pageheader><code>lsfitsetcond</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Stopping conditions for nonlinear least squares fitting.
# 
# INPUT PARAMETERS:
#     State   -   structure which stores algorithm state
#     EpsF    -   stopping criterion. Algorithm stops if
#                 |F(k+1)-F(k)| &lt;= EpsF*max{|F(k)|, |F(k+1)|, 1}
#     EpsX    -   stopping criterion. Algorithm stops if
#                 |X(k+1)-X(k)| &lt;= EpsX*(1+|X(k)|)
#     MaxIts  -   stopping criterion. Algorithm stops after MaxIts iterations.
#                 MaxIts=0 means no stopping criterion.
# 
# NOTE
# 
# Passing EpsF=0, EpsX=0 and MaxIts=0 (simultaneously) will lead to automatic
# stopping criterion selection (according to the scheme used by MINLM unit).
# 
# 
#   -- ALGLIB --
#      Copyright 17.08.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: xalglib.lsfitsetcond(state, epsf, epsx, maxits)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_lsfit_d_f' class=nav>[1]</a>&nbsp;&nbsp;<a href='#example_lsfit_d_fg' class=nav>[2]</a>&nbsp;&nbsp;<a href='#example_lsfit_d_fgh' class=nav>[3]</a>&nbsp;&nbsp;</p>
<a name='sub_lsfitsetstpmax'></a><h3 class=pageheader><code>lsfitsetstpmax</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# This function sets maximum step length
# 
# INPUT PARAMETERS:
#     State   -   structure which stores algorithm state
#     StpMax  -   maximum step length, &gt;=0. Set StpMax to 0.0,  if you don't
#                 want to limit step length.
# 
# Use this subroutine when you optimize target function which contains exp()
# or  other  fast  growing  functions,  and optimization algorithm makes too
# large  steps  which  leads  to overflow. This function allows us to reject
# steps  that  are  too  large  (and  therefore  expose  us  to the possible
# overflow) without actually calculating function value at the x+stp*d.
# 
# NOTE: non-zero StpMax leads to moderate  performance  degradation  because
# intermediate  step  of  preconditioned L-BFGS optimization is incompatible
# with limits on step size.
# 
#   -- ALGLIB --
#      Copyright 02.04.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: xalglib.lsfitsetstpmax(state, stpmax)

</div></pre>
<a name='sub_lsfitsetxrep'></a><h3 class=pageheader><code>lsfitsetxrep</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# This function turns on/off reporting.
# 
# INPUT PARAMETERS:
#     State   -   structure which stores algorithm state
#     NeedXRep-   whether iteration reports are needed or not
# 
# When reports are needed, State.C (current parameters) and State.F (current
# value of fitting function) are reported.
# 
# 
#   -- ALGLIB --
#      Copyright 15.08.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: xalglib.lsfitsetxrep(state, needxrep)

</div></pre>
<a name='sub_polynomialfit'></a><h3 class=pageheader><code>polynomialfit</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Fitting by polynomials in barycentric form. This function provides  simple
# unterface for unconstrained unweighted fitting. See  PolynomialFitWC()  if
# you need constrained fitting.
# 
# Task is linear, so linear least squares solver is used. Complexity of this
# computational scheme is O(N*M^2), mostly dominated by least squares solver
# 
# SEE ALSO:
#     PolynomialFitWC()
# 
# INPUT PARAMETERS:
#     X   -   points, array[0..N-1].
#     Y   -   function values, array[0..N-1].
#     N   -   number of points, N&gt;0
#             * if given, only leading N elements of X/Y are used
#             * if not given, automatically determined from sizes of X/Y
#     M   -   number of basis functions (= polynomial_degree + 1), M&gt;=1
# 
# OUTPUT PARAMETERS:
#     Info-   same format as in LSFitLinearW() subroutine:
#             * Info&gt;0    task is solved
#             * Info&lt;=0   an error occured:
#                         -4 means inconvergence of internal SVD
#     P   -   interpolant in barycentric form.
#     Rep -   report, same format as in LSFitLinearW() subroutine.
#             Following fields are set:
#             * RMSError      rms error on the (X,Y).
#             * AvgError      average error on the (X,Y).
#             * AvgRelError   average relative error on the non-zero Y
#             * MaxError      maximum error
#                             NON-WEIGHTED ERRORS ARE CALCULATED
# 
# NOTES:
#     you can convert P from barycentric form  to  the  power  or  Chebyshev
#     basis with PolynomialBar2Pow() or PolynomialBar2Cheb() functions  from
#     POLINT subpackage.
# 
#   -- ALGLIB PROJECT --
#      Copyright 10.12.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: info, p, rep = xalglib.polynomialfit(x, y, n, m)
SYNTAX: info, p, rep = xalglib.polynomialfit(x, y, m)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_lsfit_d_pol' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_polynomialfitwc'></a><h3 class=pageheader><code>polynomialfitwc</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Weighted  fitting by polynomials in barycentric form, with constraints  on
# function values or first derivatives.
# 
# Small regularizing term is used when solving constrained tasks (to improve
# stability).
# 
# Task is linear, so linear least squares solver is used. Complexity of this
# computational scheme is O(N*M^2), mostly dominated by least squares solver
# 
# SEE ALSO:
#     PolynomialFit()
# 
# INPUT PARAMETERS:
#     X   -   points, array[0..N-1].
#     Y   -   function values, array[0..N-1].
#     W   -   weights, array[0..N-1]
#             Each summand in square  sum  of  approximation deviations from
#             given  values  is  multiplied  by  the square of corresponding
#             weight. Fill it by 1's if you don't  want  to  solve  weighted
#             task.
#     N   -   number of points, N&gt;0.
#             * if given, only leading N elements of X/Y/W are used
#             * if not given, automatically determined from sizes of X/Y/W
#     XC  -   points where polynomial values/derivatives are constrained,
#             array[0..K-1].
#     YC  -   values of constraints, array[0..K-1]
#     DC  -   array[0..K-1], types of constraints:
#             * DC[i]=0   means that P(XC[i])=YC[i]
#             * DC[i]=1   means that P'(XC[i])=YC[i]
#             SEE BELOW FOR IMPORTANT INFORMATION ON CONSTRAINTS
#     K   -   number of constraints, 0&lt;=K&lt;M.
#             K=0 means no constraints (XC/YC/DC are not used in such cases)
#     M   -   number of basis functions (= polynomial_degree + 1), M&gt;=1
# 
# OUTPUT PARAMETERS:
#     Info-   same format as in LSFitLinearW() subroutine:
#             * Info&gt;0    task is solved
#             * Info&lt;=0   an error occured:
#                         -4 means inconvergence of internal SVD
#                         -3 means inconsistent constraints
#     P   -   interpolant in barycentric form.
#     Rep -   report, same format as in LSFitLinearW() subroutine.
#             Following fields are set:
#             * RMSError      rms error on the (X,Y).
#             * AvgError      average error on the (X,Y).
#             * AvgRelError   average relative error on the non-zero Y
#             * MaxError      maximum error
#                             NON-WEIGHTED ERRORS ARE CALCULATED
# 
# IMPORTANT:
#     this subroitine doesn't calculate task's condition number for K&lt;&gt;0.
# 
# NOTES:
#     you can convert P from barycentric form  to  the  power  or  Chebyshev
#     basis with PolynomialBar2Pow() or PolynomialBar2Cheb() functions  from
#     POLINT subpackage.
# 
# SETTING CONSTRAINTS - DANGERS AND OPPORTUNITIES:
# 
# Setting constraints can lead  to undesired  results,  like ill-conditioned
# behavior, or inconsistency being detected. From the other side,  it allows
# us to improve quality of the fit. Here we summarize  our  experience  with
# constrained regression splines:
# * even simple constraints can be inconsistent, see  Wikipedia  article  on
#   this subject: http://en.wikipedia.org/wiki/Birkhoff_interpolation
# * the  greater  is  M (given  fixed  constraints),  the  more chances that
#   constraints will be consistent
# * in the general case, consistency of constraints is NOT GUARANTEED.
# * in the one special cases, however, we can  guarantee  consistency.  This
#   case  is:  M&gt;1  and constraints on the function values (NOT DERIVATIVES)
# 
# Our final recommendation is to use constraints  WHEN  AND  ONLY  when  you
# can't solve your task without them. Anything beyond  special  cases  given
# above is not guaranteed and may result in inconsistency.
# 
#   -- ALGLIB PROJECT --
#      Copyright 10.12.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: info, p, rep = xalglib.polynomialfitwc(x, y, w, n, xc, yc, dc, k, m)
SYNTAX: info, p, rep = xalglib.polynomialfitwc(x, y, w, xc, yc, dc, m)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_lsfit_d_polc' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_spline1dfitcubic'></a><h3 class=pageheader><code>spline1dfitcubic</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Least squares fitting by cubic spline.
# 
# This subroutine is &quot;lightweight&quot; alternative for more complex and feature-
# rich Spline1DFitCubicWC().  See  Spline1DFitCubicWC() for more information
# about subroutine parameters (we don't duplicate it here because of length)
# 
#   -- ALGLIB PROJECT --
#      Copyright 18.08.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: info, s, rep = xalglib.spline1dfitcubic(x, y, n, m)
SYNTAX: info, s, rep = xalglib.spline1dfitcubic(x, y, m)

</div></pre>
<a name='sub_spline1dfitcubicwc'></a><h3 class=pageheader><code>spline1dfitcubicwc</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Weighted fitting by cubic  spline,  with constraints on function values or
# derivatives.
# 
# Equidistant grid with M-2 nodes on [min(x,xc),max(x,xc)] is  used to build
# basis functions. Basis functions are cubic splines with continuous  second
# derivatives  and  non-fixed first  derivatives  at  interval  ends.  Small
# regularizing term is used  when  solving  constrained  tasks  (to  improve
# stability).
# 
# Task is linear, so linear least squares solver is used. Complexity of this
# computational scheme is O(N*M^2), mostly dominated by least squares solver
# 
# SEE ALSO
#     Spline1DFitHermiteWC()  -   fitting by Hermite splines (more flexible,
#                                 less smooth)
#     Spline1DFitCubic()      -   &quot;lightweight&quot; fitting  by  cubic  splines,
#                                 without invididual weights and constraints
# 
# INPUT PARAMETERS:
#     X   -   points, array[0..N-1].
#     Y   -   function values, array[0..N-1].
#     W   -   weights, array[0..N-1]
#             Each summand in square  sum  of  approximation deviations from
#             given  values  is  multiplied  by  the square of corresponding
#             weight. Fill it by 1's if you don't  want  to  solve  weighted
#             task.
#     N   -   number of points (optional):
#             * N&gt;0
#             * if given, only first N elements of X/Y/W are processed
#             * if not given, automatically determined from X/Y/W sizes
#     XC  -   points where spline values/derivatives are constrained,
#             array[0..K-1].
#     YC  -   values of constraints, array[0..K-1]
#     DC  -   array[0..K-1], types of constraints:
#             * DC[i]=0   means that S(XC[i])=YC[i]
#             * DC[i]=1   means that S'(XC[i])=YC[i]
#             SEE BELOW FOR IMPORTANT INFORMATION ON CONSTRAINTS
#     K   -   number of constraints (optional):
#             * 0&lt;=K&lt;M.
#             * K=0 means no constraints (XC/YC/DC are not used)
#             * if given, only first K elements of XC/YC/DC are used
#             * if not given, automatically determined from XC/YC/DC
#     M   -   number of basis functions ( = number_of_nodes+2), M&gt;=4.
# 
# OUTPUT PARAMETERS:
#     Info-   same format as in LSFitLinearWC() subroutine.
#             * Info&gt;0    task is solved
#             * Info&lt;=0   an error occured:
#                         -4 means inconvergence of internal SVD
#                         -3 means inconsistent constraints
#     S   -   spline interpolant.
#     Rep -   report, same format as in LSFitLinearWC() subroutine.
#             Following fields are set:
#             * RMSError      rms error on the (X,Y).
#             * AvgError      average error on the (X,Y).
#             * AvgRelError   average relative error on the non-zero Y
#             * MaxError      maximum error
#                             NON-WEIGHTED ERRORS ARE CALCULATED
# 
# IMPORTANT:
#     this subroitine doesn't calculate task's condition number for K&lt;&gt;0.
# 
# 
# ORDER OF POINTS
# 
# Subroutine automatically sorts points, so caller may pass unsorted array.
# 
# SETTING CONSTRAINTS - DANGERS AND OPPORTUNITIES:
# 
# Setting constraints can lead  to undesired  results,  like ill-conditioned
# behavior, or inconsistency being detected. From the other side,  it allows
# us to improve quality of the fit. Here we summarize  our  experience  with
# constrained regression splines:
# * excessive constraints can be inconsistent. Splines are  piecewise  cubic
#   functions, and it is easy to create an example, where  large  number  of
#   constraints  concentrated  in  small  area will result in inconsistency.
#   Just because spline is not flexible enough to satisfy all of  them.  And
#   same constraints spread across the  [min(x),max(x)]  will  be  perfectly
#   consistent.
# * the more evenly constraints are spread across [min(x),max(x)],  the more
#   chances that they will be consistent
# * the  greater  is  M (given  fixed  constraints),  the  more chances that
#   constraints will be consistent
# * in the general case, consistency of constraints IS NOT GUARANTEED.
# * in the several special cases, however, we CAN guarantee consistency.
# * one of this cases is constraints  on  the  function  values  AND/OR  its
#   derivatives at the interval boundaries.
# * another  special  case  is ONE constraint on the function value (OR, but
#   not AND, derivative) anywhere in the interval
# 
# Our final recommendation is to use constraints  WHEN  AND  ONLY  WHEN  you
# can't solve your task without them. Anything beyond  special  cases  given
# above is not guaranteed and may result in inconsistency.
# 
# 
#   -- ALGLIB PROJECT --
#      Copyright 18.08.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: info, s, rep = xalglib.spline1dfitcubicwc(x, y, w, n, xc, yc, dc, k, m)
SYNTAX: info, s, rep = xalglib.spline1dfitcubicwc(x, y, w, xc, yc, dc, m)

</div></pre>
<a name='sub_spline1dfithermite'></a><h3 class=pageheader><code>spline1dfithermite</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Least squares fitting by Hermite spline.
# 
# This subroutine is &quot;lightweight&quot; alternative for more complex and feature-
# rich Spline1DFitHermiteWC().  See Spline1DFitHermiteWC()  description  for
# more information about subroutine parameters (we don't duplicate  it  here
# because of length).
# 
#   -- ALGLIB PROJECT --
#      Copyright 18.08.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: info, s, rep = xalglib.spline1dfithermite(x, y, n, m)
SYNTAX: info, s, rep = xalglib.spline1dfithermite(x, y, m)

</div></pre>
<a name='sub_spline1dfithermitewc'></a><h3 class=pageheader><code>spline1dfithermitewc</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Weighted  fitting  by Hermite spline,  with constraints on function values
# or first derivatives.
# 
# Equidistant grid with M nodes on [min(x,xc),max(x,xc)] is  used  to  build
# basis functions. Basis functions are Hermite splines.  Small  regularizing
# term is used when solving constrained tasks (to improve stability).
# 
# Task is linear, so linear least squares solver is used. Complexity of this
# computational scheme is O(N*M^2), mostly dominated by least squares solver
# 
# SEE ALSO
#     Spline1DFitCubicWC()    -   fitting by Cubic splines (less flexible,
#                                 more smooth)
#     Spline1DFitHermite()    -   &quot;lightweight&quot; Hermite fitting, without
#                                 invididual weights and constraints
# 
# INPUT PARAMETERS:
#     X   -   points, array[0..N-1].
#     Y   -   function values, array[0..N-1].
#     W   -   weights, array[0..N-1]
#             Each summand in square  sum  of  approximation deviations from
#             given  values  is  multiplied  by  the square of corresponding
#             weight. Fill it by 1's if you don't  want  to  solve  weighted
#             task.
#     N   -   number of points (optional):
#             * N&gt;0
#             * if given, only first N elements of X/Y/W are processed
#             * if not given, automatically determined from X/Y/W sizes
#     XC  -   points where spline values/derivatives are constrained,
#             array[0..K-1].
#     YC  -   values of constraints, array[0..K-1]
#     DC  -   array[0..K-1], types of constraints:
#             * DC[i]=0   means that S(XC[i])=YC[i]
#             * DC[i]=1   means that S'(XC[i])=YC[i]
#             SEE BELOW FOR IMPORTANT INFORMATION ON CONSTRAINTS
#     K   -   number of constraints (optional):
#             * 0&lt;=K&lt;M.
#             * K=0 means no constraints (XC/YC/DC are not used)
#             * if given, only first K elements of XC/YC/DC are used
#             * if not given, automatically determined from XC/YC/DC
#     M   -   number of basis functions (= 2 * number of nodes),
#             M&gt;=4,
#             M IS EVEN!
# 
# OUTPUT PARAMETERS:
#     Info-   same format as in LSFitLinearW() subroutine:
#             * Info&gt;0    task is solved
#             * Info&lt;=0   an error occured:
#                         -4 means inconvergence of internal SVD
#                         -3 means inconsistent constraints
#                         -2 means odd M was passed (which is not supported)
#                         -1 means another errors in parameters passed
#                            (N&lt;=0, for example)
#     S   -   spline interpolant.
#     Rep -   report, same format as in LSFitLinearW() subroutine.
#             Following fields are set:
#             * RMSError      rms error on the (X,Y).
#             * AvgError      average error on the (X,Y).
#             * AvgRelError   average relative error on the non-zero Y
#             * MaxError      maximum error
#                             NON-WEIGHTED ERRORS ARE CALCULATED
# 
# IMPORTANT:
#     this subroitine doesn't calculate task's condition number for K&lt;&gt;0.
# 
# IMPORTANT:
#     this subroitine supports only even M's
# 
# 
# ORDER OF POINTS
# 
# Subroutine automatically sorts points, so caller may pass unsorted array.
# 
# SETTING CONSTRAINTS - DANGERS AND OPPORTUNITIES:
# 
# Setting constraints can lead  to undesired  results,  like ill-conditioned
# behavior, or inconsistency being detected. From the other side,  it allows
# us to improve quality of the fit. Here we summarize  our  experience  with
# constrained regression splines:
# * excessive constraints can be inconsistent. Splines are  piecewise  cubic
#   functions, and it is easy to create an example, where  large  number  of
#   constraints  concentrated  in  small  area will result in inconsistency.
#   Just because spline is not flexible enough to satisfy all of  them.  And
#   same constraints spread across the  [min(x),max(x)]  will  be  perfectly
#   consistent.
# * the more evenly constraints are spread across [min(x),max(x)],  the more
#   chances that they will be consistent
# * the  greater  is  M (given  fixed  constraints),  the  more chances that
#   constraints will be consistent
# * in the general case, consistency of constraints is NOT GUARANTEED.
# * in the several special cases, however, we can guarantee consistency.
# * one of this cases is  M&gt;=4  and   constraints  on   the  function  value
#   (AND/OR its derivative) at the interval boundaries.
# * another special case is M&gt;=4  and  ONE  constraint on the function value
#   (OR, BUT NOT AND, derivative) anywhere in [min(x),max(x)]
# 
# Our final recommendation is to use constraints  WHEN  AND  ONLY  when  you
# can't solve your task without them. Anything beyond  special  cases  given
# above is not guaranteed and may result in inconsistency.
# 
#   -- ALGLIB PROJECT --
#      Copyright 18.08.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: info, s, rep = xalglib.spline1dfithermitewc(x, y, w, n, xc, yc, dc, k, m)
SYNTAX: info, s, rep = xalglib.spline1dfithermitewc(x, y, w, xc, yc, dc, m)

</div></pre>
<a name='sub_spline1dfitpenalized'></a><h3 class=pageheader><code>spline1dfitpenalized</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Rational least squares fitting using  Floater-Hormann  rational  functions
# with optimal D chosen from [0,9].
# 
# Equidistant  grid  with M node on [min(x),max(x)]  is  used to build basis
# functions. Different values of D are tried, optimal  D  (least  root  mean
# square error) is chosen.  Task  is  linear, so linear least squares solver
# is used. Complexity  of  this  computational  scheme is  O(N*M^2)  (mostly
# dominated by the least squares solver).
# 
# INPUT PARAMETERS:
#     X   -   points, array[0..N-1].
#     Y   -   function values, array[0..N-1].
#     N   -   number of points, N&gt;0.
#     M   -   number of basis functions ( = number_of_nodes), M&gt;=2.
# 
# OUTPUT PARAMETERS:
#     Info-   same format as in LSFitLinearWC() subroutine.
#             * Info&gt;0    task is solved
#             * Info&lt;=0   an error occured:
#                         -4 means inconvergence of internal SVD
#                         -3 means inconsistent constraints
#     B   -   barycentric interpolant.
#     Rep -   report, same format as in LSFitLinearWC() subroutine.
#             Following fields are set:
#             * DBest         best value of the D parameter
#             * RMSError      rms error on the (X,Y).
#             * AvgError      average error on the (X,Y).
#             * AvgRelError   average relative error on the non-zero Y
#             * MaxError      maximum error
#                             NON-WEIGHTED ERRORS ARE CALCULATED
# 
#   -- ALGLIB PROJECT --
#      Copyright 18.08.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: info, s, rep = xalglib.spline1dfitpenalized(x, y, n, m, rho)
SYNTAX: info, s, rep = xalglib.spline1dfitpenalized(x, y, m, rho)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_lsfit_d_spline' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_spline1dfitpenalizedw'></a><h3 class=pageheader><code>spline1dfitpenalizedw</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Weighted fitting by penalized cubic spline.
# 
# Equidistant grid with M nodes on [min(x,xc),max(x,xc)] is  used  to  build
# basis functions. Basis functions are cubic splines with  natural  boundary
# conditions. Problem is regularized by  adding non-linearity penalty to the
# usual least squares penalty function:
# 
#     S(x) = arg min { LS + P }, where
#     LS   = SUM { w[i]^2*(y[i] - S(x[i]))^2 } - least squares penalty
#     P    = C*10^rho*integral{ S''(x)^2*dx } - non-linearity penalty
#     rho  - tunable constant given by user
#     C    - automatically determined scale parameter,
#            makes penalty invariant with respect to scaling of X, Y, W.
# 
# INPUT PARAMETERS:
#     X   -   points, array[0..N-1].
#     Y   -   function values, array[0..N-1].
#     W   -   weights, array[0..N-1]
#             Each summand in square  sum  of  approximation deviations from
#             given  values  is  multiplied  by  the square of corresponding
#             weight. Fill it by 1's if you don't  want  to  solve  weighted
#             problem.
#     N   -   number of points (optional):
#             * N&gt;0
#             * if given, only first N elements of X/Y/W are processed
#             * if not given, automatically determined from X/Y/W sizes
#     M   -   number of basis functions ( = number_of_nodes), M&gt;=4.
#     Rho -   regularization  constant  passed   by   user.   It   penalizes
#             nonlinearity in the regression spline. It  is  logarithmically
#             scaled,  i.e.  actual  value  of  regularization  constant  is
#             calculated as 10^Rho. It is automatically scaled so that:
#             * Rho=2.0 corresponds to moderate amount of nonlinearity
#             * generally, it should be somewhere in the [-8.0,+8.0]
#             If you do not want to penalize nonlineary,
#             pass small Rho. Values as low as -15 should work.
# 
# OUTPUT PARAMETERS:
#     Info-   same format as in LSFitLinearWC() subroutine.
#             * Info&gt;0    task is solved
#             * Info&lt;=0   an error occured:
#                         -4 means inconvergence of internal SVD or
#                            Cholesky decomposition; problem may be
#                            too ill-conditioned (very rare)
#     S   -   spline interpolant.
#     Rep -   Following fields are set:
#             * RMSError      rms error on the (X,Y).
#             * AvgError      average error on the (X,Y).
#             * AvgRelError   average relative error on the non-zero Y
#             * MaxError      maximum error
#                             NON-WEIGHTED ERRORS ARE CALCULATED
# 
# IMPORTANT:
#     this subroitine doesn't calculate task's condition number for K&lt;&gt;0.
# 
# NOTE 1: additional nodes are added to the spline outside  of  the  fitting
# interval to force linearity when x&lt;min(x,xc) or x&gt;max(x,xc).  It  is  done
# for consistency - we penalize non-linearity  at [min(x,xc),max(x,xc)],  so
# it is natural to force linearity outside of this interval.
# 
# NOTE 2: function automatically sorts points,  so  caller may pass unsorted
# array.
# 
#   -- ALGLIB PROJECT --
#      Copyright 19.10.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: info, s, rep = xalglib.spline1dfitpenalizedw(x, y, w, n, m, rho)
SYNTAX: info, s, rep = xalglib.spline1dfitpenalizedw(x, y, w, m, rho)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_lsfit_d_spline' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='example_lsfit_d_f'></a><h3 class=pageheader>lsfit_d_f example</h3>
<pre class=source>
import xalglib

<b>def</b> function_cx_1_func(c, x, param):
    <font color=darkcyan>#</font>
    <font color=darkcyan># this callback calculates f(c,x)=exp(-c0*sqr(x0))</font>
    <font color=darkcyan># where x is a position on X-axis and c is adjustable parameter</font>
    <font color=darkcyan>#</font>
    <b>return</b> math.exp(-c[0]*(x[0])**2)

<font color=darkcyan>#</font>
<font color=darkcyan># In this example we demonstrate exponential fitting</font>
<font color=darkcyan># by f(x) = exp(-c*x^2)</font>
<font color=darkcyan># using function value only.</font>
<font color=darkcyan>#</font>
<font color=darkcyan># Gradient is estimated using combination of numerical differences</font>
<font color=darkcyan># and secant updates. diffstep variable stores differentiation step </font>
<font color=darkcyan># (we have to tell algorithm what step to use).</font>
<font color=darkcyan>#</font>
x = [[-1],[-0.8],[-0.6],[-0.4],[-0.2],[0],[0.2],[0.4],[0.6],[0.8],[1.0]]
y = [0.223130, 0.382893, 0.582748, 0.786628, 0.941765, 1.000000, 0.941765, 0.786628, 0.582748, 0.382893, 0.223130]
c = [0.3]
epsf = 0
epsx = 0.000001
maxits = 0
diffstep = 0.0001

<font color=darkcyan>#</font>
<font color=darkcyan># Fitting without weights</font>
<font color=darkcyan>#</font>
state = xalglib.lsfitcreatef(x, y, c, diffstep)
xalglib.lsfitsetcond(state, epsf, epsx, maxits)
xalglib.lsfitfit_f(state, function_cx_1_func)
info, c, rep = xalglib.lsfitresults(state)
print(info) <font color=darkcyan># expected 2</font>
print(c) <font color=darkcyan># expected [1.5]</font>

<font color=darkcyan>#</font>
<font color=darkcyan># Fitting with weights</font>
<font color=darkcyan># (you can change weights and see how it changes result)</font>
<font color=darkcyan>#</font>
w = [1,1,1,1,1,1,1,1,1,1,1]
state = xalglib.lsfitcreatewf(x, y, w, c, diffstep)
xalglib.lsfitsetcond(state, epsf, epsx, maxits)
xalglib.lsfitfit_f(state, function_cx_1_func)
info, c, rep = xalglib.lsfitresults(state)
print(info) <font color=darkcyan># expected 2</font>
print(c) <font color=darkcyan># expected [1.5]</font>


</pre><a name='example_lsfit_d_fg'></a><h3 class=pageheader>lsfit_d_fg example</h3>
<pre class=source>
import xalglib

<b>def</b> function_cx_1_func(c, x, param):
    <font color=darkcyan>#</font>
    <font color=darkcyan># this callback calculates f(c,x)=exp(-c0*sqr(x0))</font>
    <font color=darkcyan># where x is a position on X-axis and c is adjustable parameter</font>
    <font color=darkcyan>#</font>
    <b>return</b> math.exp(-c[0]*(x[0])**2)

<b>def</b> function_cx_1_grad(c, x, grad, param):
    <font color=darkcyan>#</font>
    <font color=darkcyan># this callback calculates f(c,x)=exp(-c0*sqr(x0)) and gradient G={df/dc[i]}</font>
    <font color=darkcyan># where x is a position on X-axis and c is adjustable parameter.</font>
    <font color=darkcyan># IMPORTANT: gradient is calculated with respect to C, not to X</font>
    <font color=darkcyan>#</font>
    func = math.exp(-c[0]*(x[0])**2)
    grad[0] = -((x[0])**2)*func
    <b>return</b> func

<font color=darkcyan>#</font>
<font color=darkcyan># In this example we demonstrate exponential fitting</font>
<font color=darkcyan># by f(x) = exp(-c*x^2)</font>
<font color=darkcyan># using function value and gradient (with respect to c).</font>
<font color=darkcyan>#</font>
x = [[-1],[-0.8],[-0.6],[-0.4],[-0.2],[0],[0.2],[0.4],[0.6],[0.8],[1.0]]
y = [0.223130, 0.382893, 0.582748, 0.786628, 0.941765, 1.000000, 0.941765, 0.786628, 0.582748, 0.382893, 0.223130]
c = [0.3]
epsf = 0
epsx = 0.000001
maxits = 0

<font color=darkcyan>#</font>
<font color=darkcyan># Fitting without weights</font>
<font color=darkcyan>#</font>
state = xalglib.lsfitcreatefg(x, y, c, True)
xalglib.lsfitsetcond(state, epsf, epsx, maxits)
xalglib.lsfitfit_fg(state, function_cx_1_func, function_cx_1_grad)
info, c, rep = xalglib.lsfitresults(state)
print(info) <font color=darkcyan># expected 2</font>
print(c) <font color=darkcyan># expected [1.5]</font>

<font color=darkcyan>#</font>
<font color=darkcyan># Fitting with weights</font>
<font color=darkcyan># (you can change weights and see how it changes result)</font>
<font color=darkcyan>#</font>
w = [1,1,1,1,1,1,1,1,1,1,1]
state = xalglib.lsfitcreatewfg(x, y, w, c, True)
xalglib.lsfitsetcond(state, epsf, epsx, maxits)
xalglib.lsfitfit_fg(state, function_cx_1_func, function_cx_1_grad)
info, c, rep = xalglib.lsfitresults(state)
print(info) <font color=darkcyan># expected 2</font>
print(c) <font color=darkcyan># expected [1.5]</font>


</pre><a name='example_lsfit_d_fgh'></a><h3 class=pageheader>lsfit_d_fgh example</h3>
<pre class=source>
import xalglib

<b>def</b> function_cx_1_func(c, x, param):
    <font color=darkcyan>#</font>
    <font color=darkcyan># this callback calculates f(c,x)=exp(-c0*sqr(x0))</font>
    <font color=darkcyan># where x is a position on X-axis and c is adjustable parameter</font>
    <font color=darkcyan>#</font>
    <b>return</b> math.exp(-c[0]*(x[0])**2)

<b>def</b> function_cx_1_grad(c, x, grad, param):
    <font color=darkcyan>#</font>
    <font color=darkcyan># this callback calculates f(c,x)=exp(-c0*sqr(x0)) and gradient G={df/dc[i]}</font>
    <font color=darkcyan># where x is a position on X-axis and c is adjustable parameter.</font>
    <font color=darkcyan># IMPORTANT: gradient is calculated with respect to C, not to X</font>
    <font color=darkcyan>#</font>
    func = math.exp(-c[0]*(x[0])**2)
    grad[0] = -((x[0])**2)*func
    <b>return</b> func

<b>def</b> function_cx_1_hess(c, x, grad, hess, param):
    <font color=darkcyan>#</font>
    <font color=darkcyan># this callback calculates f(c,x)=exp(-c0*sqr(x0)), gradient G={df/dc[i]} and Hessian H={d2f/(dc[i]*dc[j])}</font>
    <font color=darkcyan># where x is a position on X-axis and c is adjustable parameter.</font>
    <font color=darkcyan># IMPORTANT: gradient/Hessian are calculated with respect to C, not to X</font>
    <font color=darkcyan>#</font>
    func = math.exp(-c[0]*(x[0])**2)
    grad[0] = -((x[0])**2)*func
    hess[0][0] = ((x[0])**4)*func
    <b>return</b> func

<font color=darkcyan>#</font>
<font color=darkcyan># In this example we demonstrate exponential fitting</font>
<font color=darkcyan># by f(x) = exp(-c*x^2)</font>
<font color=darkcyan># using function value, gradient and Hessian (with respect to c)</font>
<font color=darkcyan>#</font>
x = [[-1],[-0.8],[-0.6],[-0.4],[-0.2],[0],[0.2],[0.4],[0.6],[0.8],[1.0]]
y = [0.223130, 0.382893, 0.582748, 0.786628, 0.941765, 1.000000, 0.941765, 0.786628, 0.582748, 0.382893, 0.223130]
c = [0.3]
epsf = 0
epsx = 0.000001
maxits = 0

<font color=darkcyan>#</font>
<font color=darkcyan># Fitting without weights</font>
<font color=darkcyan>#</font>
state = xalglib.lsfitcreatefgh(x, y, c)
xalglib.lsfitsetcond(state, epsf, epsx, maxits)
xalglib.lsfitfit_fgh(state, function_cx_1_func, function_cx_1_grad, function_cx_1_hess)
info, c, rep = xalglib.lsfitresults(state)
print(info) <font color=darkcyan># expected 2</font>
print(c) <font color=darkcyan># expected [1.5]</font>

<font color=darkcyan>#</font>
<font color=darkcyan># Fitting with weights</font>
<font color=darkcyan># (you can change weights and see how it changes result)</font>
<font color=darkcyan>#</font>
w = [1,1,1,1,1,1,1,1,1,1,1]
state = xalglib.lsfitcreatewfgh(x, y, w, c)
xalglib.lsfitsetcond(state, epsf, epsx, maxits)
xalglib.lsfitfit_fgh(state, function_cx_1_func, function_cx_1_grad, function_cx_1_hess)
info, c, rep = xalglib.lsfitresults(state)
print(info) <font color=darkcyan># expected 2</font>
print(c) <font color=darkcyan># expected [1.5]</font>


</pre><a name='example_lsfit_d_lin'></a><h3 class=pageheader>lsfit_d_lin example</h3>
<pre class=source>
import xalglib



<font color=darkcyan>#</font>
<font color=darkcyan># In this example we demonstrate linear fitting by f(x|a) = a*exp(0.5*x).</font>
<font color=darkcyan>#</font>
<font color=darkcyan># We have:</font>
<font color=darkcyan># * y - vector of experimental data</font>
<font color=darkcyan># * fmatrix -  matrix of basis functions calculated at sample points</font>
<font color=darkcyan>#              Actually, we have only one basis function F0 = exp(0.5*x).</font>
<font color=darkcyan>#</font>
fmatrix = [[0.606531],[0.670320],[0.740818],[0.818731],[0.904837],[1.000000],[1.105171],[1.221403],[1.349859],[1.491825],[1.648721]]
y = [1.133719, 1.306522, 1.504604, 1.554663, 1.884638, 2.072436, 2.257285, 2.534068, 2.622017, 2.897713, 3.219371]

<font color=darkcyan>#</font>
<font color=darkcyan># Linear fitting without weights</font>
<font color=darkcyan>#</font>
info, c, rep = xalglib.lsfitlinear(y, fmatrix)
print(info) <font color=darkcyan># expected 1</font>
print(c) <font color=darkcyan># expected [1.98650]</font>

<font color=darkcyan>#</font>
<font color=darkcyan># Linear fitting with individual weights.</font>
<font color=darkcyan># Slightly different result is returned.</font>
<font color=darkcyan>#</font>
w = [1.414213, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
info, c, rep = xalglib.lsfitlinearw(y, w, fmatrix)
print(info) <font color=darkcyan># expected 1</font>
print(c) <font color=darkcyan># expected [1.983354]</font>


</pre><a name='example_lsfit_d_linc'></a><h3 class=pageheader>lsfit_d_linc example</h3>
<pre class=source>
import xalglib



<font color=darkcyan>#</font>
<font color=darkcyan># In this example we demonstrate linear fitting by f(x|a,b) = a*x+b</font>
<font color=darkcyan># with simple constraint f(0)=0.</font>
<font color=darkcyan>#</font>
<font color=darkcyan># We have:</font>
<font color=darkcyan># * y - vector of experimental data</font>
<font color=darkcyan># * fmatrix -  matrix of basis functions sampled at [0,1] with step 0.2:</font>
<font color=darkcyan>#                  [ 1.0   0.0 ]</font>
<font color=darkcyan>#                  [ 1.0   0.2 ]</font>
<font color=darkcyan>#                  [ 1.0   0.4 ]</font>
<font color=darkcyan>#                  [ 1.0   0.6 ]</font>
<font color=darkcyan>#                  [ 1.0   0.8 ]</font>
<font color=darkcyan>#                  [ 1.0   1.0 ]</font>
<font color=darkcyan>#              first column contains value of first basis function (constant term)</font>
<font color=darkcyan>#              second column contains second basis function (linear term)</font>
<font color=darkcyan># * cmatrix -  matrix of linear constraints:</font>
<font color=darkcyan>#                  [ 1.0  0.0  0.0 ]</font>
<font color=darkcyan>#              first two columns contain coefficients before basis functions,</font>
<font color=darkcyan>#              last column contains desired value of their sum.</font>
<font color=darkcyan>#              So [1,0,0] means <font color=blue><b>&quot;1*constant_term + 0*linear_term = 0&quot;</b></font> </font>
<font color=darkcyan>#</font>
y = [0.072436,0.246944,0.491263,0.522300,0.714064,0.921929]
fmatrix = [[1,0.0],[1,0.2],[1,0.4],[1,0.6],[1,0.8],[1,1.0]]
cmatrix = [[1,0,0]]

<font color=darkcyan>#</font>
<font color=darkcyan># Constrained fitting without weights</font>
<font color=darkcyan>#</font>
info, c, rep = xalglib.lsfitlinearc(y, fmatrix, cmatrix)
print(info) <font color=darkcyan># expected 1</font>
print(c) <font color=darkcyan># expected [0,0.932933]</font>

<font color=darkcyan>#</font>
<font color=darkcyan># Constrained fitting with individual weights</font>
<font color=darkcyan>#</font>
w = [1, 1.414213, 1, 1, 1, 1]
info, c, rep = xalglib.lsfitlinearwc(y, w, fmatrix, cmatrix)
print(info) <font color=darkcyan># expected 1</font>
print(c) <font color=darkcyan># expected [0,0.938322]</font>


</pre><a name='example_lsfit_d_pol'></a><h3 class=pageheader>lsfit_d_pol example</h3>
<pre class=source>
import xalglib



<font color=darkcyan>#</font>
<font color=darkcyan># This example demonstrates polynomial fitting.</font>
<font color=darkcyan>#</font>
<font color=darkcyan># Fitting is done by two (M=2) functions from polynomial basis:</font>
<font color=darkcyan>#     f0 = 1</font>
<font color=darkcyan>#     f1 = x</font>
<font color=darkcyan># Basically, it just a linear fit; more complex polynomials may be used</font>
<font color=darkcyan># (e.g. parabolas with M=3, cubic with M=4), but even such simple fit allows</font>
<font color=darkcyan># us to demonstrate polynomialfit() function in action.</font>
<font color=darkcyan>#</font>
<font color=darkcyan># We have:</font>
<font color=darkcyan># * x      set of abscissas</font>
<font color=darkcyan># * y      experimental data</font>
<font color=darkcyan>#</font>
<font color=darkcyan># Additionally we demonstrate weighted fitting, where second point has</font>
<font color=darkcyan># more weight than other ones.</font>
<font color=darkcyan>#</font>
x = [0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.0]
y = [0.00,0.05,0.26,0.32,0.33,0.43,0.60,0.60,0.77,0.98,1.02]
m = 2
t = 2

<font color=darkcyan>#</font>
<font color=darkcyan># Fitting without individual weights</font>
<font color=darkcyan>#</font>
<font color=darkcyan># NOTE: result is returned as barycentricinterpolant structure.</font>
<font color=darkcyan>#       <b>if</b> you want to get representation in the power basis,</font>
<font color=darkcyan>#       you can use barycentricbar2pow() function to convert</font>
<font color=darkcyan>#       from barycentric to power representation (see docs <b>for</b> </font>
<font color=darkcyan>#       POLINT subpackage <b>for</b> more info).</font>
<font color=darkcyan>#</font>
info, p, rep = xalglib.polynomialfit(x, y, m)
v = xalglib.barycentriccalc(p, t)
print(v) <font color=darkcyan># expected 2.011</font>

<font color=darkcyan>#</font>
<font color=darkcyan># Fitting with individual weights</font>
<font color=darkcyan>#</font>
<font color=darkcyan># NOTE: slightly different result is returned</font>
<font color=darkcyan>#</font>
w = [1,1.414213562,1,1,1,1,1,1,1,1,1]
xc = []
yc = []
dc = []
info, p, rep = xalglib.polynomialfitwc(x, y, w, xc, yc, dc, m)
v = xalglib.barycentriccalc(p, t)
print(v) <font color=darkcyan># expected 2.023</font>


</pre><a name='example_lsfit_d_polc'></a><h3 class=pageheader>lsfit_d_polc example</h3>
<pre class=source>
import xalglib



<font color=darkcyan>#</font>
<font color=darkcyan># This example demonstrates polynomial fitting.</font>
<font color=darkcyan>#</font>
<font color=darkcyan># Fitting is done by two (M=2) functions from polynomial basis:</font>
<font color=darkcyan>#     f0 = 1</font>
<font color=darkcyan>#     f1 = x</font>
<font color=darkcyan># with simple constraint on function value</font>
<font color=darkcyan>#     f(0) = 0</font>
<font color=darkcyan># Basically, it just a linear fit; more complex polynomials may be used</font>
<font color=darkcyan># (e.g. parabolas with M=3, cubic with M=4), but even such simple fit allows</font>
<font color=darkcyan># us to demonstrate polynomialfit() function in action.</font>
<font color=darkcyan>#</font>
<font color=darkcyan># We have:</font>
<font color=darkcyan># * x      set of abscissas</font>
<font color=darkcyan># * y      experimental data</font>
<font color=darkcyan># * xc     points where constraints are placed</font>
<font color=darkcyan># * yc     constraints on derivatives</font>
<font color=darkcyan># * dc     derivative indices</font>
<font color=darkcyan>#          (0 means function itself, 1 means first derivative)</font>
<font color=darkcyan>#</font>
x = [1.0,1.0]
y = [0.9,1.1]
w = [1,1]
xc = [0]
yc = [0]
dc = [0]
t = 2
m = 2

info, p, rep = xalglib.polynomialfitwc(x, y, w, xc, yc, dc, m)
v = xalglib.barycentriccalc(p, t)
print(v) <font color=darkcyan># expected 2.000</font>


</pre><a name='example_lsfit_d_spline'></a><h3 class=pageheader>lsfit_d_spline example</h3>
<pre class=source>
import xalglib



<font color=darkcyan>#</font>
<font color=darkcyan># In this example we demonstrate penalized spline fitting of noisy data</font>
<font color=darkcyan>#</font>
<font color=darkcyan># We have:</font>
<font color=darkcyan># * x - abscissas</font>
<font color=darkcyan># * y - vector of experimental data, straight line with small noise</font>
<font color=darkcyan>#</font>
x = [0.00,0.10,0.20,0.30,0.40,0.50,0.60,0.70,0.80,0.90]
y = [0.10,0.00,0.30,0.40,0.30,0.40,0.62,0.68,0.75,0.95]

<font color=darkcyan>#</font>
<font color=darkcyan># Fit with VERY small amount of smoothing (rho = -5.0)</font>
<font color=darkcyan># and large number of basis functions (M=50).</font>
<font color=darkcyan>#</font>
<font color=darkcyan># With such small regularization penalized spline almost fully reproduces function values</font>
<font color=darkcyan>#</font>
rho = -5.0
info, s, rep = xalglib.spline1dfitpenalized(x, y, 50, rho)
print(info) <font color=darkcyan># expected 1</font>
v = xalglib.spline1dcalc(s, 0.0)
print(v) <font color=darkcyan># expected 0.10</font>

<font color=darkcyan>#</font>
<font color=darkcyan># Fit with VERY large amount of smoothing (rho = 10.0)</font>
<font color=darkcyan># and large number of basis functions (M=50).</font>
<font color=darkcyan>#</font>
<font color=darkcyan># With such regularization our spline should become close to the straight line fit.</font>
<font color=darkcyan># We will compare its value in x=1.0 with results obtained from such fit.</font>
<font color=darkcyan>#</font>
rho = +10.0
info, s, rep = xalglib.spline1dfitpenalized(x, y, 50, rho)
print(info) <font color=darkcyan># expected 1</font>
v = xalglib.spline1dcalc(s, 1.0)
print(v) <font color=darkcyan># expected 0.969</font>

<font color=darkcyan>#</font>
<font color=darkcyan># In real life applications you may need some moderate degree of fitting,</font>
<font color=darkcyan># so we try to fit once more with rho=3.0.</font>
<font color=darkcyan>#</font>
rho = +3.0
info, s, rep = xalglib.spline1dfitpenalized(x, y, 50, rho)
print(info) <font color=darkcyan># expected 1</font>


</pre><a name=unit_mannwhitneyu></a><h2 class=pageheader><code>mannwhitneyu</code> module</h2>
<div class=pagecontent>
<h3 class=pageheader>Functions</h3>
<a href='#sub_mannwhitneyutest' class=toc>mannwhitneyutest</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='sub_mannwhitneyutest'></a><h3 class=pageheader><code>mannwhitneyutest</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Mann-Whitney U-test
# 
# This test checks hypotheses about whether X  and  Y  are  samples  of  two
# continuous distributions of the same shape  and  same  median  or  whether
# their medians are different.
# 
# The following tests are performed:
#     * two-tailed test (null hypothesis - the medians are equal)
#     * left-tailed test (null hypothesis - the median of the  first  sample
#       is greater than or equal to the median of the second sample)
#     * right-tailed test (null hypothesis - the median of the first  sample
#       is less than or equal to the median of the second sample).
# 
# Requirements:
#     * the samples are independent
#     * X and Y are continuous distributions (or discrete distributions well-
#       approximating continuous distributions)
#     * distributions of X and Y have the  same  shape.  The  only  possible
#       difference is their position (i.e. the value of the median)
#     * the number of elements in each sample is not less than 5
#     * the scale of measurement should be ordinal, interval or ratio  (i.e.
#       the test could not be applied to nominal variables).
# 
# The test is non-parametric and doesn't require distributions to be normal.
# 
# Input parameters:
#     X   -   sample 1. Array whose index goes from 0 to N-1.
#     N   -   size of the sample. N&gt;=5
#     Y   -   sample 2. Array whose index goes from 0 to M-1.
#     M   -   size of the sample. M&gt;=5
# 
# Output parameters:
#     BothTails   -   p-value for two-tailed test.
#                     If BothTails is less than the given significance level
#                     the null hypothesis is rejected.
#     LeftTail    -   p-value for left-tailed test.
#                     If LeftTail is less than the given significance level,
#                     the null hypothesis is rejected.
#     RightTail   -   p-value for right-tailed test.
#                     If RightTail is less than the given significance level
#                     the null hypothesis is rejected.
# 
# To calculate p-values, special approximation is used. This method lets  us
# calculate p-values with satisfactory  accuracy  in  interval  [0.0001, 1].
# There is no approximation outside the [0.0001, 1] interval. Therefore,  if
# the significance level outlies this interval, the test returns 0.0001.
# 
# Relative precision of approximation of p-value:
# 
# N          M          Max.err.   Rms.err.
# 5..10      N..10      1.4e-02    6.0e-04
# 5..10      N..100     2.2e-02    5.3e-06
# 10..15     N..15      1.0e-02    3.2e-04
# 10..15     N..100     1.0e-02    2.2e-05
# 15..100    N..100     6.1e-03    2.7e-06
# 
# For N,M&gt;100 accuracy checks weren't put into  practice,  but  taking  into
# account characteristics of asymptotic approximation used, precision should
# not be sharply different from the values for interval [5, 100].
# 
#   -- ALGLIB --
#      Copyright 09.04.2007 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: bothtails, lefttail, righttail = xalglib.mannwhitneyutest(x, n, y, m)

</div></pre>
<a name=unit_matdet></a><h2 class=pageheader><code>matdet</code> module</h2>
<div class=pagecontent>
<h3 class=pageheader>Functions</h3>
<a href='#sub_cmatrixdet' class=toc>cmatrixdet</a><br>
<a href='#sub_cmatrixludet' class=toc>cmatrixludet</a><br>
<a href='#sub_rmatrixdet' class=toc>rmatrixdet</a><br>
<a href='#sub_rmatrixludet' class=toc>rmatrixludet</a><br>
<a href='#sub_spdmatrixcholeskydet' class=toc>spdmatrixcholeskydet</a><br>
<a href='#sub_spdmatrixdet' class=toc>spdmatrixdet</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
<tr align=left valign=top><td><a href='#example_matdet_d_1' class=toc>matdet_d_1</a></td><td width=15>&nbsp;</td><td>Determinant calculation, real matrix, short form</td></tr>
<tr align=left valign=top><td><a href='#example_matdet_d_2' class=toc>matdet_d_2</a></td><td width=15>&nbsp;</td><td>Determinant calculation, real matrix, full form</td></tr>
<tr align=left valign=top><td><a href='#example_matdet_d_3' class=toc>matdet_d_3</a></td><td width=15>&nbsp;</td><td>Determinant calculation, complex matrix, short form</td></tr>
<tr align=left valign=top><td><a href='#example_matdet_d_4' class=toc>matdet_d_4</a></td><td width=15>&nbsp;</td><td>Determinant calculation, complex matrix, full form</td></tr>
<tr align=left valign=top><td><a href='#example_matdet_d_5' class=toc>matdet_d_5</a></td><td width=15>&nbsp;</td><td>Determinant calculation, complex matrix with zero imaginary part, short form</td></tr>
</table></div>
<a name='sub_cmatrixdet'></a><h3 class=pageheader><code>cmatrixdet</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Calculation of the determinant of a general matrix
# 
# Input parameters:
#     A       -   matrix, array[0..N-1, 0..N-1]
#     N       -   (optional) size of matrix A:
#                 * if given, only principal NxN submatrix is processed and
#                   overwritten. other elements are unchanged.
#                 * if not given, automatically determined from matrix size
#                   (A must be square matrix)
# 
# Result: determinant of matrix A.
# 
#   -- ALGLIB --
#      Copyright 2005 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.cmatrixdet(a, n)
SYNTAX: result = xalglib.cmatrixdet(a)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_matdet_d_3' class=nav>[1]</a>&nbsp;&nbsp;<a href='#example_matdet_d_4' class=nav>[2]</a>&nbsp;&nbsp;<a href='#example_matdet_d_5' class=nav>[3]</a>&nbsp;&nbsp;</p>
<a name='sub_cmatrixludet'></a><h3 class=pageheader><code>cmatrixludet</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Determinant calculation of the matrix given by its LU decomposition.
# 
# Input parameters:
#     A       -   LU decomposition of the matrix (output of
#                 RMatrixLU subroutine).
#     Pivots  -   table of permutations which were made during
#                 the LU decomposition.
#                 Output of RMatrixLU subroutine.
#     N       -   (optional) size of matrix A:
#                 * if given, only principal NxN submatrix is processed and
#                   overwritten. other elements are unchanged.
#                 * if not given, automatically determined from matrix size
#                   (A must be square matrix)
# 
# Result: matrix determinant.
# 
#   -- ALGLIB --
#      Copyright 2005 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.cmatrixludet(a, pivots, n)
SYNTAX: result = xalglib.cmatrixludet(a, pivots)

</div></pre>
<a name='sub_rmatrixdet'></a><h3 class=pageheader><code>rmatrixdet</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Calculation of the determinant of a general matrix
# 
# Input parameters:
#     A       -   matrix, array[0..N-1, 0..N-1]
#     N       -   (optional) size of matrix A:
#                 * if given, only principal NxN submatrix is processed and
#                   overwritten. other elements are unchanged.
#                 * if not given, automatically determined from matrix size
#                   (A must be square matrix)
# 
# Result: determinant of matrix A.
# 
#   -- ALGLIB --
#      Copyright 2005 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.rmatrixdet(a, n)
SYNTAX: result = xalglib.rmatrixdet(a)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_matdet_d_1' class=nav>[1]</a>&nbsp;&nbsp;<a href='#example_matdet_d_2' class=nav>[2]</a>&nbsp;&nbsp;</p>
<a name='sub_rmatrixludet'></a><h3 class=pageheader><code>rmatrixludet</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Determinant calculation of the matrix given by its LU decomposition.
# 
# Input parameters:
#     A       -   LU decomposition of the matrix (output of
#                 RMatrixLU subroutine).
#     Pivots  -   table of permutations which were made during
#                 the LU decomposition.
#                 Output of RMatrixLU subroutine.
#     N       -   (optional) size of matrix A:
#                 * if given, only principal NxN submatrix is processed and
#                   overwritten. other elements are unchanged.
#                 * if not given, automatically determined from matrix size
#                   (A must be square matrix)
# 
# Result: matrix determinant.
# 
#   -- ALGLIB --
#      Copyright 2005 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.rmatrixludet(a, pivots, n)
SYNTAX: result = xalglib.rmatrixludet(a, pivots)

</div></pre>
<a name='sub_spdmatrixcholeskydet'></a><h3 class=pageheader><code>spdmatrixcholeskydet</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Determinant calculation of the matrix given by the Cholesky decomposition.
# 
# Input parameters:
#     A       -   Cholesky decomposition,
#                 output of SMatrixCholesky subroutine.
#     N       -   (optional) size of matrix A:
#                 * if given, only principal NxN submatrix is processed and
#                   overwritten. other elements are unchanged.
#                 * if not given, automatically determined from matrix size
#                   (A must be square matrix)
# 
# As the determinant is equal to the product of squares of diagonal elements,
# its not necessary to specify which triangle - lower or upper - the matrix
# is stored in.
# 
# Result:
#     matrix determinant.
# 
#   -- ALGLIB --
#      Copyright 2005-2008 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.spdmatrixcholeskydet(a, n)
SYNTAX: result = xalglib.spdmatrixcholeskydet(a)

</div></pre>
<a name='sub_spdmatrixdet'></a><h3 class=pageheader><code>spdmatrixdet</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Determinant calculation of the symmetric positive definite matrix.
# 
# Input parameters:
#     A       -   matrix. Array with elements [0..N-1, 0..N-1].
#     N       -   (optional) size of matrix A:
#                 * if given, only principal NxN submatrix is processed and
#                   overwritten. other elements are unchanged.
#                 * if not given, automatically determined from matrix size
#                   (A must be square matrix)
#     IsUpper -   (optional) storage type:
#                 * if True, symmetric matrix  A  is  given  by  its  upper
#                   triangle, and the lower triangle isnt used/changed  by
#                   function
#                 * if False, symmetric matrix  A  is  given  by  its lower
#                   triangle, and the upper triangle isnt used/changed  by
#                   function
#                 * if not given, both lower and upper  triangles  must  be
#                   filled.
# 
# Result:
#     determinant of matrix A.
#     If matrix A is not positive definite, exception is thrown.
# 
#   -- ALGLIB --
#      Copyright 2005-2008 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.spdmatrixdet(a, n, isupper)
SYNTAX: result = xalglib.spdmatrixdet(a)

</div></pre>
<a name='example_matdet_d_1'></a><h3 class=pageheader>matdet_d_1 example</h3>
<pre class=source>
import xalglib



b = [[1,2],[2,1]]
a = xalglib.rmatrixdet(b)
print(a) <font color=darkcyan># expected -3</font>


</pre><a name='example_matdet_d_2'></a><h3 class=pageheader>matdet_d_2 example</h3>
<pre class=source>
import xalglib



b = [[5,4],[4,5]]
a = xalglib.rmatrixdet(b, 2)
print(a) <font color=darkcyan># expected 9</font>


</pre><a name='example_matdet_d_3'></a><h3 class=pageheader>matdet_d_3 example</h3>
<pre class=source>
import xalglib



b = [[1+1j,2],[2,1-1j]]
a = xalglib.cmatrixdet(b)
print(a) <font color=darkcyan># expected -2</font>


</pre><a name='example_matdet_d_4'></a><h3 class=pageheader>matdet_d_4 example</h3>
<pre class=source>
import xalglib



b = [[5j,4],[4j,5]]
a = xalglib.cmatrixdet(b, 2)
print(a) <font color=darkcyan># expected 9j</font>


</pre><a name='example_matdet_d_5'></a><h3 class=pageheader>matdet_d_5 example</h3>
<pre class=source>
import xalglib



b = [[9,1],[2,1]]
a = xalglib.cmatrixdet(b)
print(a) <font color=darkcyan># expected 7</font>


</pre><a name=unit_matgen></a><h2 class=pageheader><code>matgen</code> module</h2>
<div class=pagecontent>
<h3 class=pageheader>Functions</h3>
<a href='#sub_cmatrixrndcond' class=toc>cmatrixrndcond</a><br>
<a href='#sub_cmatrixrndorthogonal' class=toc>cmatrixrndorthogonal</a><br>
<a href='#sub_cmatrixrndorthogonalfromtheleft' class=toc>cmatrixrndorthogonalfromtheleft</a><br>
<a href='#sub_cmatrixrndorthogonalfromtheright' class=toc>cmatrixrndorthogonalfromtheright</a><br>
<a href='#sub_hmatrixrndcond' class=toc>hmatrixrndcond</a><br>
<a href='#sub_hmatrixrndmultiply' class=toc>hmatrixrndmultiply</a><br>
<a href='#sub_hpdmatrixrndcond' class=toc>hpdmatrixrndcond</a><br>
<a href='#sub_rmatrixrndcond' class=toc>rmatrixrndcond</a><br>
<a href='#sub_rmatrixrndorthogonal' class=toc>rmatrixrndorthogonal</a><br>
<a href='#sub_rmatrixrndorthogonalfromtheleft' class=toc>rmatrixrndorthogonalfromtheleft</a><br>
<a href='#sub_rmatrixrndorthogonalfromtheright' class=toc>rmatrixrndorthogonalfromtheright</a><br>
<a href='#sub_smatrixrndcond' class=toc>smatrixrndcond</a><br>
<a href='#sub_smatrixrndmultiply' class=toc>smatrixrndmultiply</a><br>
<a href='#sub_spdmatrixrndcond' class=toc>spdmatrixrndcond</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='sub_cmatrixrndcond'></a><h3 class=pageheader><code>cmatrixrndcond</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Generation of random NxN complex matrix with given condition number C and
# norm2(A)=1
# 
# INPUT PARAMETERS:
#     N   -   matrix size
#     C   -   condition number (in 2-norm)
# 
# OUTPUT PARAMETERS:
#     A   -   random matrix with norm2(A)=1 and cond(A)=C
# 
#   -- ALGLIB routine --
#      04.12.2009
#      Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: a = xalglib.cmatrixrndcond(n, c)

</div></pre>
<a name='sub_cmatrixrndorthogonal'></a><h3 class=pageheader><code>cmatrixrndorthogonal</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Generation of a random Haar distributed orthogonal complex matrix
# 
# INPUT PARAMETERS:
#     N   -   matrix size, N&gt;=1
# 
# OUTPUT PARAMETERS:
#     A   -   orthogonal NxN matrix, array[0..N-1,0..N-1]
# 
#   -- ALGLIB routine --
#      04.12.2009
#      Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: a = xalglib.cmatrixrndorthogonal(n)

</div></pre>
<a name='sub_cmatrixrndorthogonalfromtheleft'></a><h3 class=pageheader><code>cmatrixrndorthogonalfromtheleft</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Multiplication of MxN complex matrix by MxM random Haar distributed
# complex orthogonal matrix
# 
# INPUT PARAMETERS:
#     A   -   matrix, array[0..M-1, 0..N-1]
#     M, N-   matrix size
# 
# OUTPUT PARAMETERS:
#     A   -   Q*A, where Q is random MxM orthogonal matrix
# 
#   -- ALGLIB routine --
#      04.12.2009
#      Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: a = xalglib.cmatrixrndorthogonalfromtheleft(a, m, n)

</div></pre>
<a name='sub_cmatrixrndorthogonalfromtheright'></a><h3 class=pageheader><code>cmatrixrndorthogonalfromtheright</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Multiplication of MxN complex matrix by NxN random Haar distributed
# complex orthogonal matrix
# 
# INPUT PARAMETERS:
#     A   -   matrix, array[0..M-1, 0..N-1]
#     M, N-   matrix size
# 
# OUTPUT PARAMETERS:
#     A   -   A*Q, where Q is random NxN orthogonal matrix
# 
#   -- ALGLIB routine --
#      04.12.2009
#      Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: a = xalglib.cmatrixrndorthogonalfromtheright(a, m, n)

</div></pre>
<a name='sub_hmatrixrndcond'></a><h3 class=pageheader><code>hmatrixrndcond</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Generation of random NxN Hermitian matrix with given condition number  and
# norm2(A)=1
# 
# INPUT PARAMETERS:
#     N   -   matrix size
#     C   -   condition number (in 2-norm)
# 
# OUTPUT PARAMETERS:
#     A   -   random matrix with norm2(A)=1 and cond(A)=C
# 
#   -- ALGLIB routine --
#      04.12.2009
#      Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: a = xalglib.hmatrixrndcond(n, c)

</div></pre>
<a name='sub_hmatrixrndmultiply'></a><h3 class=pageheader><code>hmatrixrndmultiply</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Hermitian multiplication of NxN matrix by random Haar distributed
# complex orthogonal matrix
# 
# INPUT PARAMETERS:
#     A   -   matrix, array[0..N-1, 0..N-1]
#     N   -   matrix size
# 
# OUTPUT PARAMETERS:
#     A   -   Q^H*A*Q, where Q is random NxN orthogonal matrix
# 
#   -- ALGLIB routine --
#      04.12.2009
#      Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: a = xalglib.hmatrixrndmultiply(a, n)

</div></pre>
<a name='sub_hpdmatrixrndcond'></a><h3 class=pageheader><code>hpdmatrixrndcond</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Generation of random NxN Hermitian positive definite matrix with given
# condition number and norm2(A)=1
# 
# INPUT PARAMETERS:
#     N   -   matrix size
#     C   -   condition number (in 2-norm)
# 
# OUTPUT PARAMETERS:
#     A   -   random HPD matrix with norm2(A)=1 and cond(A)=C
# 
#   -- ALGLIB routine --
#      04.12.2009
#      Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: a = xalglib.hpdmatrixrndcond(n, c)

</div></pre>
<a name='sub_rmatrixrndcond'></a><h3 class=pageheader><code>rmatrixrndcond</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Generation of random NxN matrix with given condition number and norm2(A)=1
# 
# INPUT PARAMETERS:
#     N   -   matrix size
#     C   -   condition number (in 2-norm)
# 
# OUTPUT PARAMETERS:
#     A   -   random matrix with norm2(A)=1 and cond(A)=C
# 
#   -- ALGLIB routine --
#      04.12.2009
#      Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: a = xalglib.rmatrixrndcond(n, c)

</div></pre>
<a name='sub_rmatrixrndorthogonal'></a><h3 class=pageheader><code>rmatrixrndorthogonal</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Generation of a random uniformly distributed (Haar) orthogonal matrix
# 
# INPUT PARAMETERS:
#     N   -   matrix size, N&gt;=1
# 
# OUTPUT PARAMETERS:
#     A   -   orthogonal NxN matrix, array[0..N-1,0..N-1]
# 
#   -- ALGLIB routine --
#      04.12.2009
#      Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: a = xalglib.rmatrixrndorthogonal(n)

</div></pre>
<a name='sub_rmatrixrndorthogonalfromtheleft'></a><h3 class=pageheader><code>rmatrixrndorthogonalfromtheleft</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Multiplication of MxN matrix by MxM random Haar distributed orthogonal matrix
# 
# INPUT PARAMETERS:
#     A   -   matrix, array[0..M-1, 0..N-1]
#     M, N-   matrix size
# 
# OUTPUT PARAMETERS:
#     A   -   Q*A, where Q is random MxM orthogonal matrix
# 
#   -- ALGLIB routine --
#      04.12.2009
#      Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: a = xalglib.rmatrixrndorthogonalfromtheleft(a, m, n)

</div></pre>
<a name='sub_rmatrixrndorthogonalfromtheright'></a><h3 class=pageheader><code>rmatrixrndorthogonalfromtheright</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Multiplication of MxN matrix by NxN random Haar distributed orthogonal matrix
# 
# INPUT PARAMETERS:
#     A   -   matrix, array[0..M-1, 0..N-1]
#     M, N-   matrix size
# 
# OUTPUT PARAMETERS:
#     A   -   A*Q, where Q is random NxN orthogonal matrix
# 
#   -- ALGLIB routine --
#      04.12.2009
#      Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: a = xalglib.rmatrixrndorthogonalfromtheright(a, m, n)

</div></pre>
<a name='sub_smatrixrndcond'></a><h3 class=pageheader><code>smatrixrndcond</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Generation of random NxN symmetric matrix with given condition number  and
# norm2(A)=1
# 
# INPUT PARAMETERS:
#     N   -   matrix size
#     C   -   condition number (in 2-norm)
# 
# OUTPUT PARAMETERS:
#     A   -   random matrix with norm2(A)=1 and cond(A)=C
# 
#   -- ALGLIB routine --
#      04.12.2009
#      Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: a = xalglib.smatrixrndcond(n, c)

</div></pre>
<a name='sub_smatrixrndmultiply'></a><h3 class=pageheader><code>smatrixrndmultiply</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Symmetric multiplication of NxN matrix by random Haar distributed
# orthogonal  matrix
# 
# INPUT PARAMETERS:
#     A   -   matrix, array[0..N-1, 0..N-1]
#     N   -   matrix size
# 
# OUTPUT PARAMETERS:
#     A   -   Q'*A*Q, where Q is random NxN orthogonal matrix
# 
#   -- ALGLIB routine --
#      04.12.2009
#      Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: a = xalglib.smatrixrndmultiply(a, n)

</div></pre>
<a name='sub_spdmatrixrndcond'></a><h3 class=pageheader><code>spdmatrixrndcond</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Generation of random NxN symmetric positive definite matrix with given
# condition number and norm2(A)=1
# 
# INPUT PARAMETERS:
#     N   -   matrix size
#     C   -   condition number (in 2-norm)
# 
# OUTPUT PARAMETERS:
#     A   -   random SPD matrix with norm2(A)=1 and cond(A)=C
# 
#   -- ALGLIB routine --
#      04.12.2009
#      Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: a = xalglib.spdmatrixrndcond(n, c)

</div></pre>
<a name=unit_matinv></a><h2 class=pageheader><code>matinv</code> module</h2>
<div class=pagecontent>
<h3 class=pageheader>Classes</h3>
<a href='#struct_matinvreport' class=toc>matinvreport</a><br>
<h3 class=pageheader>Functions</h3>
<a href='#sub_cmatrixinverse' class=toc>cmatrixinverse</a><br>
<a href='#sub_cmatrixluinverse' class=toc>cmatrixluinverse</a><br>
<a href='#sub_cmatrixtrinverse' class=toc>cmatrixtrinverse</a><br>
<a href='#sub_hpdmatrixcholeskyinverse' class=toc>hpdmatrixcholeskyinverse</a><br>
<a href='#sub_hpdmatrixinverse' class=toc>hpdmatrixinverse</a><br>
<a href='#sub_rmatrixinverse' class=toc>rmatrixinverse</a><br>
<a href='#sub_rmatrixluinverse' class=toc>rmatrixluinverse</a><br>
<a href='#sub_rmatrixtrinverse' class=toc>rmatrixtrinverse</a><br>
<a href='#sub_spdmatrixcholeskyinverse' class=toc>spdmatrixcholeskyinverse</a><br>
<a href='#sub_spdmatrixinverse' class=toc>spdmatrixinverse</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
<tr align=left valign=top><td><a href='#example_matinv_d_c1' class=toc>matinv_d_c1</a></td><td width=15>&nbsp;</td><td>Complex matrix inverse</td></tr>
<tr align=left valign=top><td><a href='#example_matinv_d_hpd1' class=toc>matinv_d_hpd1</a></td><td width=15>&nbsp;</td><td>HPD matrix inverse</td></tr>
<tr align=left valign=top><td><a href='#example_matinv_d_r1' class=toc>matinv_d_r1</a></td><td width=15>&nbsp;</td><td>Real matrix inverse</td></tr>
<tr align=left valign=top><td><a href='#example_matinv_d_spd1' class=toc>matinv_d_spd1</a></td><td width=15>&nbsp;</td><td>SPD matrix inverse</td></tr>
</table></div>
<a name='struct_matinvreport'></a><h3 class=pageheader><code>matinvreport</code> class</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Matrix inverse report:
# * R1    reciprocal of condition number in 1-norm
# * RInf  reciprocal of condition number in inf-norm
#

</div><div style='margin-top: 0; margin-bottom: 0;'><span style='font-weight: bold; color: green;'>class</span> matinvreport(object):
    ...

</div></pre>
<a name='sub_cmatrixinverse'></a><h3 class=pageheader><code>cmatrixinverse</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Inversion of a general matrix.
# 
# Input parameters:
#     A       -   matrix
#     N       -   size of matrix A (optional) :
#                 * if given, only principal NxN submatrix is processed  and
#                   overwritten. other elements are unchanged.
#                 * if not given,  size  is  automatically  determined  from
#                   matrix size (A must be square matrix)
# 
# Output parameters:
#     Info    -   return code, same as in RMatrixLUInverse
#     Rep     -   solver report, same as in RMatrixLUInverse
#     A       -   inverse of matrix A, same as in RMatrixLUInverse
# 
#   -- ALGLIB --
#      Copyright 2005 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: a, info, rep = xalglib.cmatrixinverse(a, n)
SYNTAX: a, info, rep = xalglib.cmatrixinverse(a)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_matinv_d_c1' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_cmatrixluinverse'></a><h3 class=pageheader><code>cmatrixluinverse</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Inversion of a matrix given by its LU decomposition.
# 
# INPUT PARAMETERS:
#     A       -   LU decomposition of the matrix
#                 (output of CMatrixLU subroutine).
#     Pivots  -   table of permutations
#                 (the output of CMatrixLU subroutine).
#     N       -   size of matrix A (optional) :
#                 * if given, only principal NxN submatrix is processed  and
#                   overwritten. other elements are unchanged.
#                 * if not given,  size  is  automatically  determined  from
#                   matrix size (A must be square matrix)
# 
# OUTPUT PARAMETERS:
#     Info    -   return code, same as in RMatrixLUInverse
#     Rep     -   solver report, same as in RMatrixLUInverse
#     A       -   inverse of matrix A, same as in RMatrixLUInverse
# 
#   -- ALGLIB routine --
#      05.02.2010
#      Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: a, info, rep = xalglib.cmatrixluinverse(a, pivots, n)
SYNTAX: a, info, rep = xalglib.cmatrixluinverse(a, pivots)

</div></pre>
<a name='sub_cmatrixtrinverse'></a><h3 class=pageheader><code>cmatrixtrinverse</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Triangular matrix inverse (complex)
# 
# The subroutine inverts the following types of matrices:
#     * upper triangular
#     * upper triangular with unit diagonal
#     * lower triangular
#     * lower triangular with unit diagonal
# 
# In case of an upper (lower) triangular matrix,  the  inverse  matrix  will
# also be upper (lower) triangular, and after the end of the algorithm,  the
# inverse matrix replaces the source matrix. The elements  below (above) the
# main diagonal are not changed by the algorithm.
# 
# If  the matrix  has a unit diagonal, the inverse matrix also  has  a  unit
# diagonal, and the diagonal elements are not passed to the algorithm.
# 
# Input parameters:
#     A       -   matrix, array[0..N-1, 0..N-1].
#     N       -   size of matrix A (optional) :
#                 * if given, only principal NxN submatrix is processed  and
#                   overwritten. other elements are unchanged.
#                 * if not given,  size  is  automatically  determined  from
#                   matrix size (A must be square matrix)
#     IsUpper -   True, if the matrix is upper triangular.
#     IsUnit  -   diagonal type (optional):
#                 * if True, matrix has unit diagonal (a[i,i] are NOT used)
#                 * if False, matrix diagonal is arbitrary
#                 * if not given, False is assumed
# 
# Output parameters:
#     Info    -   same as for RMatrixLUInverse
#     Rep     -   same as for RMatrixLUInverse
#     A       -   same as for RMatrixLUInverse.
# 
#   -- ALGLIB --
#      Copyright 05.02.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: a, info, rep = xalglib.cmatrixtrinverse(a, n, isupper, isunit)
SYNTAX: a, info, rep = xalglib.cmatrixtrinverse(a, isupper)

</div></pre>
<a name='sub_hpdmatrixcholeskyinverse'></a><h3 class=pageheader><code>hpdmatrixcholeskyinverse</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Inversion of a Hermitian positive definite matrix which is given
# by Cholesky decomposition.
# 
# Input parameters:
#     A       -   Cholesky decomposition of the matrix to be inverted:
#                 A=U*U or A = L*L'.
#                 Output of  HPDMatrixCholesky subroutine.
#     N       -   size of matrix A (optional) :
#                 * if given, only principal NxN submatrix is processed  and
#                   overwritten. other elements are unchanged.
#                 * if not given,  size  is  automatically  determined  from
#                   matrix size (A must be square matrix)
#     IsUpper -   storage type (optional):
#                 * if True, symmetric  matrix  A  is  given  by  its  upper
#                   triangle, and the lower triangle isnt  used/changed  by
#                   function
#                 * if False,  symmetric matrix  A  is  given  by  its lower
#                   triangle, and the  upper triangle isnt used/changed  by
#                   function
#                 * if not given, lower half is used.
# 
# Output parameters:
#     Info    -   return code, same as in RMatrixLUInverse
#     Rep     -   solver report, same as in RMatrixLUInverse
#     A       -   inverse of matrix A, same as in RMatrixLUInverse
# 
#   -- ALGLIB routine --
#      10.02.2010
#      Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: a, info, rep = xalglib.hpdmatrixcholeskyinverse(a, n, isupper)
SYNTAX: a, info, rep = xalglib.hpdmatrixcholeskyinverse(a)

</div></pre>
<a name='sub_hpdmatrixinverse'></a><h3 class=pageheader><code>hpdmatrixinverse</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Inversion of a Hermitian positive definite matrix.
# 
# Given an upper or lower triangle of a Hermitian positive definite matrix,
# the algorithm generates matrix A^-1 and saves the upper or lower triangle
# depending on the input.
# 
# Input parameters:
#     A       -   matrix to be inverted (upper or lower triangle).
#                 Array with elements [0..N-1,0..N-1].
#     N       -   size of matrix A (optional) :
#                 * if given, only principal NxN submatrix is processed  and
#                   overwritten. other elements are unchanged.
#                 * if not given,  size  is  automatically  determined  from
#                   matrix size (A must be square matrix)
#     IsUpper -   storage type (optional):
#                 * if True, symmetric  matrix  A  is  given  by  its  upper
#                   triangle, and the lower triangle isnt  used/changed  by
#                   function
#                 * if False,  symmetric matrix  A  is  given  by  its lower
#                   triangle, and the  upper triangle isnt used/changed  by
#                   function
#                 * if not given,  both lower and upper  triangles  must  be
#                   filled.
# 
# Output parameters:
#     Info    -   return code, same as in RMatrixLUInverse
#     Rep     -   solver report, same as in RMatrixLUInverse
#     A       -   inverse of matrix A, same as in RMatrixLUInverse
# 
#   -- ALGLIB routine --
#      10.02.2010
#      Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: a, info, rep = xalglib.hpdmatrixinverse(a, n, isupper)
SYNTAX: a, info, rep = xalglib.hpdmatrixinverse(a)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_matinv_d_hpd1' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_rmatrixinverse'></a><h3 class=pageheader><code>rmatrixinverse</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Inversion of a general matrix.
# 
# Input parameters:
#     A       -   matrix.
#     N       -   size of matrix A (optional) :
#                 * if given, only principal NxN submatrix is processed  and
#                   overwritten. other elements are unchanged.
#                 * if not given,  size  is  automatically  determined  from
#                   matrix size (A must be square matrix)
# 
# Output parameters:
#     Info    -   return code, same as in RMatrixLUInverse
#     Rep     -   solver report, same as in RMatrixLUInverse
#     A       -   inverse of matrix A, same as in RMatrixLUInverse
# 
# Result:
#     True, if the matrix is not singular.
#     False, if the matrix is singular.
# 
#   -- ALGLIB --
#      Copyright 2005-2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: a, info, rep = xalglib.rmatrixinverse(a, n)
SYNTAX: a, info, rep = xalglib.rmatrixinverse(a)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_matinv_d_r1' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_rmatrixluinverse'></a><h3 class=pageheader><code>rmatrixluinverse</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Inversion of a matrix given by its LU decomposition.
# 
# INPUT PARAMETERS:
#     A       -   LU decomposition of the matrix
#                 (output of RMatrixLU subroutine).
#     Pivots  -   table of permutations
#                 (the output of RMatrixLU subroutine).
#     N       -   size of matrix A (optional) :
#                 * if given, only principal NxN submatrix is processed  and
#                   overwritten. other elements are unchanged.
#                 * if not given,  size  is  automatically  determined  from
#                   matrix size (A must be square matrix)
# 
# OUTPUT PARAMETERS:
#     Info    -   return code:
#                 * -3    A is singular, or VERY close to singular.
#                         it is filled by zeros in such cases.
#                 *  1    task is solved (but matrix A may be ill-conditioned,
#                         check R1/RInf parameters for condition numbers).
#     Rep     -   solver report, see below for more info
#     A       -   inverse of matrix A.
#                 Array whose indexes range within [0..N-1, 0..N-1].
# 
# SOLVER REPORT
# 
# Subroutine sets following fields of the Rep structure:
# * R1        reciprocal of condition number: 1/cond(A), 1-norm.
# * RInf      reciprocal of condition number: 1/cond(A), inf-norm.
# 
#   -- ALGLIB routine --
#      05.02.2010
#      Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: a, info, rep = xalglib.rmatrixluinverse(a, pivots, n)
SYNTAX: a, info, rep = xalglib.rmatrixluinverse(a, pivots)

</div></pre>
<a name='sub_rmatrixtrinverse'></a><h3 class=pageheader><code>rmatrixtrinverse</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Triangular matrix inverse (real)
# 
# The subroutine inverts the following types of matrices:
#     * upper triangular
#     * upper triangular with unit diagonal
#     * lower triangular
#     * lower triangular with unit diagonal
# 
# In case of an upper (lower) triangular matrix,  the  inverse  matrix  will
# also be upper (lower) triangular, and after the end of the algorithm,  the
# inverse matrix replaces the source matrix. The elements  below (above) the
# main diagonal are not changed by the algorithm.
# 
# If  the matrix  has a unit diagonal, the inverse matrix also  has  a  unit
# diagonal, and the diagonal elements are not passed to the algorithm.
# 
# Input parameters:
#     A       -   matrix, array[0..N-1, 0..N-1].
#     N       -   size of matrix A (optional) :
#                 * if given, only principal NxN submatrix is processed  and
#                   overwritten. other elements are unchanged.
#                 * if not given,  size  is  automatically  determined  from
#                   matrix size (A must be square matrix)
#     IsUpper -   True, if the matrix is upper triangular.
#     IsUnit  -   diagonal type (optional):
#                 * if True, matrix has unit diagonal (a[i,i] are NOT used)
#                 * if False, matrix diagonal is arbitrary
#                 * if not given, False is assumed
# 
# Output parameters:
#     Info    -   same as for RMatrixLUInverse
#     Rep     -   same as for RMatrixLUInverse
#     A       -   same as for RMatrixLUInverse.
# 
#   -- ALGLIB --
#      Copyright 05.02.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: a, info, rep = xalglib.rmatrixtrinverse(a, n, isupper, isunit)
SYNTAX: a, info, rep = xalglib.rmatrixtrinverse(a, isupper)

</div></pre>
<a name='sub_spdmatrixcholeskyinverse'></a><h3 class=pageheader><code>spdmatrixcholeskyinverse</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Inversion of a symmetric positive definite matrix which is given
# by Cholesky decomposition.
# 
# Input parameters:
#     A       -   Cholesky decomposition of the matrix to be inverted:
#                 A=U*U or A = L*L'.
#                 Output of  SPDMatrixCholesky subroutine.
#     N       -   size of matrix A (optional) :
#                 * if given, only principal NxN submatrix is processed  and
#                   overwritten. other elements are unchanged.
#                 * if not given,  size  is  automatically  determined  from
#                   matrix size (A must be square matrix)
#     IsUpper -   storage type (optional):
#                 * if True, symmetric  matrix  A  is  given  by  its  upper
#                   triangle, and the lower triangle isnt  used/changed  by
#                   function
#                 * if False,  symmetric matrix  A  is  given  by  its lower
#                   triangle, and the  upper triangle isnt used/changed  by
#                   function
#                 * if not given, lower half is used.
# 
# Output parameters:
#     Info    -   return code, same as in RMatrixLUInverse
#     Rep     -   solver report, same as in RMatrixLUInverse
#     A       -   inverse of matrix A, same as in RMatrixLUInverse
# 
#   -- ALGLIB routine --
#      10.02.2010
#      Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: a, info, rep = xalglib.spdmatrixcholeskyinverse(a, n, isupper)
SYNTAX: a, info, rep = xalglib.spdmatrixcholeskyinverse(a)

</div></pre>
<a name='sub_spdmatrixinverse'></a><h3 class=pageheader><code>spdmatrixinverse</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Inversion of a symmetric positive definite matrix.
# 
# Given an upper or lower triangle of a symmetric positive definite matrix,
# the algorithm generates matrix A^-1 and saves the upper or lower triangle
# depending on the input.
# 
# Input parameters:
#     A       -   matrix to be inverted (upper or lower triangle).
#                 Array with elements [0..N-1,0..N-1].
#     N       -   size of matrix A (optional) :
#                 * if given, only principal NxN submatrix is processed  and
#                   overwritten. other elements are unchanged.
#                 * if not given,  size  is  automatically  determined  from
#                   matrix size (A must be square matrix)
#     IsUpper -   storage type (optional):
#                 * if True, symmetric  matrix  A  is  given  by  its  upper
#                   triangle, and the lower triangle isnt  used/changed  by
#                   function
#                 * if False,  symmetric matrix  A  is  given  by  its lower
#                   triangle, and the  upper triangle isnt used/changed  by
#                   function
#                 * if not given,  both lower and upper  triangles  must  be
#                   filled.
# 
# Output parameters:
#     Info    -   return code, same as in RMatrixLUInverse
#     Rep     -   solver report, same as in RMatrixLUInverse
#     A       -   inverse of matrix A, same as in RMatrixLUInverse
# 
#   -- ALGLIB routine --
#      10.02.2010
#      Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: a, info, rep = xalglib.spdmatrixinverse(a, n, isupper)
SYNTAX: a, info, rep = xalglib.spdmatrixinverse(a)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_matinv_d_spd1' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='example_matinv_d_c1'></a><h3 class=pageheader>matinv_d_c1 example</h3>
<pre class=source>
import xalglib



a = [[1j,-1],[1j,1]]
a, info, rep = xalglib.cmatrixinverse(a)
print(info) <font color=darkcyan># expected 1</font>
print(a) <font color=darkcyan># expected [[-0.5j,-0.5j],[-0.5,0.5]]</font>
print(rep.r1) <font color=darkcyan># expected 0.5</font>
print(rep.rinf) <font color=darkcyan># expected 0.5</font>


</pre><a name='example_matinv_d_hpd1'></a><h3 class=pageheader>matinv_d_hpd1 example</h3>
<pre class=source>
import xalglib



a = [[2,1],[1,2]]
a, info, rep = xalglib.hpdmatrixinverse(a)
print(info) <font color=darkcyan># expected 1</font>
print(a) <font color=darkcyan># expected [[0.666666,-0.333333],[-0.333333,0.666666]]</font>


</pre><a name='example_matinv_d_r1'></a><h3 class=pageheader>matinv_d_r1 example</h3>
<pre class=source>
import xalglib



a = [[1,-1],[1,1]]
a, info, rep = xalglib.rmatrixinverse(a)
print(info) <font color=darkcyan># expected 1</font>
print(a) <font color=darkcyan># expected [[0.5,0.5],[-0.5,0.5]]</font>
print(rep.r1) <font color=darkcyan># expected 0.5</font>
print(rep.rinf) <font color=darkcyan># expected 0.5</font>


</pre><a name='example_matinv_d_spd1'></a><h3 class=pageheader>matinv_d_spd1 example</h3>
<pre class=source>
import xalglib



a = [[2,1],[1,2]]
a, info, rep = xalglib.spdmatrixinverse(a)
print(info) <font color=darkcyan># expected 1</font>
print(a) <font color=darkcyan># expected [[0.666666,-0.333333],[-0.333333,0.666666]]</font>


</pre><a name=unit_minasa></a><h2 class=pageheader><code>minasa</code> module</h2>
<div class=pagecontent>
<h3 class=pageheader>Classes</h3>
<a href='#struct_minasareport' class=toc>minasareport</a><br>
<a href='#struct_minasastate' class=toc>minasastate</a><br>
<h3 class=pageheader>Functions</h3>
<a href='#sub_minasacreate' class=toc>minasacreate</a><br>
<a href='#sub_minasaoptimize' class=toc>minasaoptimize</a><br>
<a href='#sub_minasarestartfrom' class=toc>minasarestartfrom</a><br>
<a href='#sub_minasaresults' class=toc>minasaresults</a><br>
<a href='#sub_minasaresultsbuf' class=toc>minasaresultsbuf</a><br>
<a href='#sub_minasasetalgorithm' class=toc>minasasetalgorithm</a><br>
<a href='#sub_minasasetcond' class=toc>minasasetcond</a><br>
<a href='#sub_minasasetstpmax' class=toc>minasasetstpmax</a><br>
<a href='#sub_minasasetxrep' class=toc>minasasetxrep</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
<tr align=left valign=top><td><a href='#example_minasa_d_1' class=toc>minasa_d_1</a></td><td width=15>&nbsp;</td><td>Nonlinear optimization with bound constraints</td></tr>
</table></div>
<a name='struct_minasareport'></a><h3 class=pageheader><code>minasareport</code> class</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# 
#

</div><div style='margin-top: 0; margin-bottom: 0;'><span style='font-weight: bold; color: green;'>class</span> minasareport(object):
    ...

</div></pre>
<a name='struct_minasastate'></a><h3 class=pageheader><code>minasastate</code> class</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# 
#

</div><div style='margin-top: 0; margin-bottom: 0;'><span style='font-weight: bold; color: green;'>class</span> minasastate(object):
    ...

</div></pre>
<a name='sub_minasacreate'></a><h3 class=pageheader><code>minasacreate</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
#               NONLINEAR BOUND CONSTRAINED OPTIMIZATION USING
#                       MODIFIED ACTIVE SET ALGORITHM
#                    WILLIAM W. HAGER AND HONGCHAO ZHANG
# 
# DESCRIPTION:
# The  subroutine  minimizes  function  F(x)  of  N  arguments  with   bound
# constraints: BndL[i] &lt;= x[i] &lt;= BndU[i]
# 
# This method is  globally  convergent  as  long  as  grad(f)  is  Lipschitz
# continuous on a level set: L = { x : f(x)&lt;=f(x0) }.
# 
# 
# REQUIREMENTS:
# Algorithm will request following information during its operation:
# * function value F and its gradient G (simultaneously) at given point X
# 
# 
# USAGE:
# 1. User initializes algorithm state with MinASACreate() call
# 2. User tunes solver parameters with MinASASetCond() MinASASetStpMax() and
#    other functions
# 3. User calls MinASAOptimize() function which takes algorithm  state   and
#    pointer (delegate, etc.) to callback function which calculates F/G.
# 4. User calls MinASAResults() to get solution
# 5. Optionally, user may call MinASARestartFrom() to solve another  problem
#    with same N but another starting point and/or another function.
#    MinASARestartFrom() allows to reuse already initialized structure.
# 
# 
# INPUT PARAMETERS:
#     N       -   problem dimension, N&gt;0:
#                 * if given, only leading N elements of X are used
#                 * if not given, automatically determined from sizes of
#                   X/BndL/BndU.
#     X       -   starting point, array[0..N-1].
#     BndL    -   lower bounds, array[0..N-1].
#                 all elements MUST be specified,  i.e.  all  variables  are
#                 bounded. However, if some (all) variables  are  unbounded,
#                 you may specify very small number as bound: -1000,  -1.0E6
#                 or -1.0E300, or something like that.
#     BndU    -   upper bounds, array[0..N-1].
#                 all elements MUST be specified,  i.e.  all  variables  are
#                 bounded. However, if some (all) variables  are  unbounded,
#                 you may specify very large number as bound: +1000,  +1.0E6
#                 or +1.0E300, or something like that.
# 
# OUTPUT PARAMETERS:
#     State   -   structure stores algorithm state
# 
# NOTES:
# 
# 1. you may tune stopping conditions with MinASASetCond() function
# 2. if target function contains exp() or other fast growing functions,  and
#    optimization algorithm makes too large steps which leads  to  overflow,
#    use MinASASetStpMax() function to bound algorithm's steps.
# 3. this function does NOT support infinite/NaN values in X, BndL, BndU.
# 
#   -- ALGLIB --
#      Copyright 25.03.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: state = xalglib.minasacreate(n, x, bndl, bndu)
SYNTAX: state = xalglib.minasacreate(x, bndl, bndu)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_minasa_d_1' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_minasaoptimize'></a><h3 class=pageheader><code>minasaoptimize</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# This family of functions is used to launcn iterations of nonlinear optimizer
# 
# These functions accept following parameters:
#     state   -   algorithm state
#     grad    -   callback which calculates function (or merit function)
#                 value func and gradient grad at given point x
#     rep     -   optional callback which is called after each iteration
#                 can be NULL
#     ptr     -   optional pointer which is passed to func/grad/hess/jac/rep
#                 can be NULL
# 
# 
#   -- ALGLIB --
#      Copyright 20.03.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: xalglib.minasaoptimize_g(state, grad, rep = None, param = None)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_minasa_d_1' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_minasarestartfrom'></a><h3 class=pageheader><code>minasarestartfrom</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# This  subroutine  restarts  CG  algorithm from new point. All optimization
# parameters are left unchanged.
# 
# This  function  allows  to  solve multiple  optimization  problems  (which
# must have same number of dimensions) without object reallocation penalty.
# 
# INPUT PARAMETERS:
#     State   -   structure previously allocated with MinCGCreate call.
#     X       -   new starting point.
#     BndL    -   new lower bounds
#     BndU    -   new upper bounds
# 
#   -- ALGLIB --
#      Copyright 30.07.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: xalglib.minasarestartfrom(state, x, bndl, bndu)

</div></pre>
<a name='sub_minasaresults'></a><h3 class=pageheader><code>minasaresults</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# ASA results
# 
# INPUT PARAMETERS:
#     State   -   algorithm state
# 
# OUTPUT PARAMETERS:
#     X       -   array[0..N-1], solution
#     Rep     -   optimization report:
#                 * Rep.TerminationType completetion code:
#                     * -2    rounding errors prevent further improvement.
#                             X contains best point found.
#                     * -1    incorrect parameters were specified
#                     *  1    relative function improvement is no more than
#                             EpsF.
#                     *  2    relative step is no more than EpsX.
#                     *  4    gradient norm is no more than EpsG
#                     *  5    MaxIts steps was taken
#                     *  7    stopping conditions are too stringent,
#                             further improvement is impossible
#                 * Rep.IterationsCount contains iterations count
#                 * NFEV countains number of function calculations
#                 * ActiveConstraints contains number of active constraints
# 
#   -- ALGLIB --
#      Copyright 20.03.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: x, rep = xalglib.minasaresults(state)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_minasa_d_1' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_minasaresultsbuf'></a><h3 class=pageheader><code>minasaresultsbuf</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# ASA results
# 
# Buffered implementation of MinASAResults() which uses pre-allocated buffer
# to store X[]. If buffer size is  too  small,  it  resizes  buffer.  It  is
# intended to be used in the inner cycles of performance critical algorithms
# where array reallocation penalty is too large to be ignored.
# 
#   -- ALGLIB --
#      Copyright 20.03.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: x, rep = xalglib.minasaresultsbuf(state, x, rep)

</div></pre>
<a name='sub_minasasetalgorithm'></a><h3 class=pageheader><code>minasasetalgorithm</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# This function sets optimization algorithm.
# 
# INPUT PARAMETERS:
#     State   -   structure which stores algorithm stat
#     UAType  -   algorithm type:
#                 * -1    automatic selection of the best algorithm
#                 * 0     DY (Dai and Yuan) algorithm
#                 * 1     Hybrid DY-HS algorithm
# 
#   -- ALGLIB --
#      Copyright 02.04.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: xalglib.minasasetalgorithm(state, algotype)

</div></pre>
<a name='sub_minasasetcond'></a><h3 class=pageheader><code>minasasetcond</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# This function sets stopping conditions for the ASA optimization algorithm.
# 
# INPUT PARAMETERS:
#     State   -   structure which stores algorithm state
#     EpsG    -   &gt;=0
#                 The  subroutine  finishes  its  work   if   the  condition
#                 ||G||&lt;EpsG is satisfied, where ||.|| means Euclidian norm,
#                 G - gradient.
#     EpsF    -   &gt;=0
#                 The  subroutine  finishes  its work if on k+1-th iteration
#                 the  condition  |F(k+1)-F(k)|&lt;=EpsF*max{|F(k)|,|F(k+1)|,1}
#                 is satisfied.
#     EpsX    -   &gt;=0
#                 The subroutine finishes its work if  on  k+1-th  iteration
#                 the condition |X(k+1)-X(k)| &lt;= EpsX is fulfilled.
#     MaxIts  -   maximum number of iterations. If MaxIts=0, the  number  of
#                 iterations is unlimited.
# 
# Passing EpsG=0, EpsF=0, EpsX=0 and MaxIts=0 (simultaneously) will lead to
# automatic stopping criterion selection (small EpsX).
# 
#   -- ALGLIB --
#      Copyright 02.04.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: xalglib.minasasetcond(state, epsg, epsf, epsx, maxits)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_minasa_d_1' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_minasasetstpmax'></a><h3 class=pageheader><code>minasasetstpmax</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# This function sets maximum step length
# 
# INPUT PARAMETERS:
#     State   -   structure which stores algorithm state
#     StpMax  -   maximum step length, &gt;=0. Set StpMax to 0.0,  if you don't
#                 want to limit step length (zero by default).
# 
# Use this subroutine when you optimize target function which contains exp()
# or  other  fast  growing  functions,  and optimization algorithm makes too
# large  steps  which  leads  to overflow. This function allows us to reject
# steps  that  are  too  large  (and  therefore  expose  us  to the possible
# overflow) without actually calculating function value at the x+stp*d.
# 
#   -- ALGLIB --
#      Copyright 02.04.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: xalglib.minasasetstpmax(state, stpmax)

</div></pre>
<a name='sub_minasasetxrep'></a><h3 class=pageheader><code>minasasetxrep</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# This function turns on/off reporting.
# 
# INPUT PARAMETERS:
#     State   -   structure which stores algorithm state
#     NeedXRep-   whether iteration reports are needed or not
# 
# If NeedXRep is True, algorithm will call rep() callback function if  it is
# provided to MinASAOptimize().
# 
#   -- ALGLIB --
#      Copyright 02.04.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: xalglib.minasasetxrep(state, needxrep)

</div></pre>
<a name='example_minasa_d_1'></a><h3 class=pageheader>minasa_d_1 example</h3>
<pre class=source>
import xalglib

<b>def</b> function1_grad(x, grad, param):
    <font color=darkcyan>#</font>
    <font color=darkcyan># this callback calculates f(x0,x1) = 100*(x0+3)^4 + (x1-3)^4</font>
    <font color=darkcyan># and its derivatives df/d0 and df/dx1</font>
    <font color=darkcyan>#</font>
    func = 100*(x[0]+3)**4 + (x[1]-3)**4
    grad[0] = 400*(x[0]+3)**3
    grad[1] = 4*(x[1]-3)**3
    <b>return</b> func

<font color=darkcyan>#</font>
<font color=darkcyan># This example demonstrates minimization of f(x,y) = 100*(x+3)^4+(y-3)^4</font>
<font color=darkcyan># subject to bound constraints -1&lt;=x0&lt;=+1, -1&lt;=x1&lt;=+1, using ASA.</font>
<font color=darkcyan>#</font>
x = [0,0]
bndl = [-1,-1]
bndu = [+1,+1]
epsg = 0.0000000001
epsf = 0
epsx = 0
maxits = 0

state = xalglib.minasacreate(x, bndl, bndu)
xalglib.minasasetcond(state, epsg, epsf, epsx, maxits)
xalglib.minasaoptimize_g(state, function1_grad)
x, rep = xalglib.minasaresults(state)

print(rep.terminationtype) <font color=darkcyan># expected 4</font>
print(x) <font color=darkcyan># expected [-1,1]</font>


</pre><a name=unit_minbleic></a><h2 class=pageheader><code>minbleic</code> module</h2>
<div class=pagecontent>
<h3 class=pageheader>Classes</h3>
<a href='#struct_minbleicreport' class=toc>minbleicreport</a><br>
<a href='#struct_minbleicstate' class=toc>minbleicstate</a><br>
<h3 class=pageheader>Functions</h3>
<a href='#sub_minbleiccreate' class=toc>minbleiccreate</a><br>
<a href='#sub_minbleicoptimize' class=toc>minbleicoptimize</a><br>
<a href='#sub_minbleicrestartfrom' class=toc>minbleicrestartfrom</a><br>
<a href='#sub_minbleicresults' class=toc>minbleicresults</a><br>
<a href='#sub_minbleicresultsbuf' class=toc>minbleicresultsbuf</a><br>
<a href='#sub_minbleicsetbarrierdecay' class=toc>minbleicsetbarrierdecay</a><br>
<a href='#sub_minbleicsetbarrierwidth' class=toc>minbleicsetbarrierwidth</a><br>
<a href='#sub_minbleicsetbc' class=toc>minbleicsetbc</a><br>
<a href='#sub_minbleicsetinnercond' class=toc>minbleicsetinnercond</a><br>
<a href='#sub_minbleicsetlc' class=toc>minbleicsetlc</a><br>
<a href='#sub_minbleicsetmaxits' class=toc>minbleicsetmaxits</a><br>
<a href='#sub_minbleicsetoutercond' class=toc>minbleicsetoutercond</a><br>
<a href='#sub_minbleicsetstpmax' class=toc>minbleicsetstpmax</a><br>
<a href='#sub_minbleicsetxrep' class=toc>minbleicsetxrep</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
<tr align=left valign=top><td><a href='#example_minbleic_d_1' class=toc>minbleic_d_1</a></td><td width=15>&nbsp;</td><td>Nonlinear optimization with bound constraints</td></tr>
<tr align=left valign=top><td><a href='#example_minbleic_d_2' class=toc>minbleic_d_2</a></td><td width=15>&nbsp;</td><td>Nonlinear optimization with linear inequality constraints</td></tr>
</table></div>
<a name='struct_minbleicreport'></a><h3 class=pageheader><code>minbleicreport</code> class</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# This structure stores optimization report:
# * InnerIterationsCount      number of inner iterations
# * OuterIterationsCount      number of outer iterations
# * NFEV                      number of gradient evaluations
# 
# There are additional fields which can be used for debugging:
# * DebugEqErr                error in the equality constraints (2-norm)
# * DebugFS                   f, calculated at projection of initial point
#                             to the feasible set
# * DebugFF                   f, calculated at the final point
# * DebugDX                   |X_start-X_final|
#

</div><div style='margin-top: 0; margin-bottom: 0;'><span style='font-weight: bold; color: green;'>class</span> minbleicreport(object):
    ...

</div></pre>
<a name='struct_minbleicstate'></a><h3 class=pageheader><code>minbleicstate</code> class</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# This object stores nonlinear optimizer state.
# You should use functions provided by MinBLEIC subpackage to work with this
# object
#

</div><div style='margin-top: 0; margin-bottom: 0;'><span style='font-weight: bold; color: green;'>class</span> minbleicstate(object):
    ...

</div></pre>
<a name='sub_minbleiccreate'></a><h3 class=pageheader><code>minbleiccreate</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
#                      BOUND CONSTRAINED OPTIMIZATION
#        WITH ADDITIONAL LINEAR EQUALITY AND INEQUALITY CONSTRAINTS
# 
# DESCRIPTION:
# The  subroutine  minimizes  function   F(x)  of N arguments subject to any
# combination of:
# * bound constraints
# * linear inequality constraints
# * linear equality constraints
# 
# REQUIREMENTS:
# * function value and gradient
# * grad(f) must be Lipschitz continuous on a level set: L = { x : f(x)&lt;=f(x0) }
# * function must be defined even in the infeasible points (algorithm make take
#   steps in the infeasible area before converging to the feasible point)
# * starting point X0 must be feasible or not too far away from the feasible set
# * problem must satisfy strict complementary conditions
# 
# USAGE:
# 
# Constrained optimization if far more complex than the unconstrained one.
# Here we give very brief outline of the BLEIC optimizer. We strongly recommend
# you to read examples in the ALGLIB Reference Manual and to read ALGLIB User Guide
# on optimization, which is available at http://www.alglib.net/optimization/
# 
# 1. User initializes algorithm state with MinBLEICCreate() call
# 
# 2. USer adds boundary and/or linear constraints by calling
#    MinBLEICSetBC() and MinBLEICSetLC() functions.
# 
# 3. User sets stopping conditions for underlying unconstrained solver
#    with MinBLEICSetInnerCond() call.
#    This function controls accuracy of underlying optimization algorithm.
# 
# 4. User sets stopping conditions for outer iteration by calling
#    MinBLEICSetOuterCond() function.
#    This function controls handling of boundary and inequality constraints.
# 
# 5. User tunes barrier parameters:
#    * barrier width with MinBLEICSetBarrierWidth() call
#    * (optionally) dynamics of the barrier width with MinBLEICSetBarrierDecay() call
#    These functions control handling of boundary and inequality constraints.
# 
# 6. Additionally, user may set limit on number of internal iterations
#    by MinBLEICSetMaxIts() call.
#    This function allows to prevent algorithm from looping forever.
# 
# 7. User calls MinBLEICOptimize() function which takes algorithm  state and
#    pointer (delegate, etc.) to callback function which calculates F/G.
# 
# 8. User calls MinBLEICResults() to get solution
# 
# 9. Optionally user may call MinBLEICRestartFrom() to solve another problem
#    with same N but another starting point.
#    MinBLEICRestartFrom() allows to reuse already initialized structure.
# 
# 
# INPUT PARAMETERS:
#     N       -   problem dimension, N&gt;0:
#                 * if given, only leading N elements of X are used
#                 * if not given, automatically determined from size ofX
#     X       -   starting point, array[N]:
#                 * it is better to set X to a feasible point
#                 * but X can be infeasible, in which case algorithm will try
#                   to find feasible point first, using X as initial
#                   approximation.
# 
# OUTPUT PARAMETERS:
#     State   -   structure stores algorithm state
# 
#   -- ALGLIB --
#      Copyright 28.11.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: state = xalglib.minbleiccreate(n, x)
SYNTAX: state = xalglib.minbleiccreate(x)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_minbleic_d_1' class=nav>[1]</a>&nbsp;&nbsp;<a href='#example_minbleic_d_2' class=nav>[2]</a>&nbsp;&nbsp;</p>
<a name='sub_minbleicoptimize'></a><h3 class=pageheader><code>minbleicoptimize</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# This family of functions is used to launcn iterations of nonlinear optimizer
# 
# These functions accept following parameters:
#     state   -   algorithm state
#     grad    -   callback which calculates function (or merit function)
#                 value func and gradient grad at given point x
#     rep     -   optional callback which is called after each iteration
#                 can be NULL
#     ptr     -   optional pointer which is passed to func/grad/hess/jac/rep
#                 can be NULL
# 
# 
#   -- ALGLIB --
#      Copyright 28.11.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: xalglib.minbleicoptimize_g(state, grad, rep = None, param = None)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_minbleic_d_1' class=nav>[1]</a>&nbsp;&nbsp;<a href='#example_minbleic_d_2' class=nav>[2]</a>&nbsp;&nbsp;</p>
<a name='sub_minbleicrestartfrom'></a><h3 class=pageheader><code>minbleicrestartfrom</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# This subroutine restarts algorithm from new point.
# All optimization parameters (including constraints) are left unchanged.
# 
# This  function  allows  to  solve multiple  optimization  problems  (which
# must have  same number of dimensions) without object reallocation penalty.
# 
# INPUT PARAMETERS:
#     State   -   structure previously allocated with MinBLEICCreate call.
#     X       -   new starting point.
# 
#   -- ALGLIB --
#      Copyright 28.11.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: xalglib.minbleicrestartfrom(state, x)

</div></pre>
<a name='sub_minbleicresults'></a><h3 class=pageheader><code>minbleicresults</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# BLEIC results
# 
# INPUT PARAMETERS:
#     State   -   algorithm state
# 
# OUTPUT PARAMETERS:
#     X       -   array[0..N-1], solution
#     Rep     -   optimization report:
#                 * Rep.TerminationType completetion code:
#                     * -3    inconsistent constraints. Feasible point is
#                             either nonexistent or too hard to find. Try to
#                             restart optimizer with better initial
#                             approximation
#                     * -2    rounding errors prevent further improvement.
#                             X contains best point found.
#                     *  4    conditions on constraints are fulfilled
#                             with error less than or equal to EpsC
#                     *  5    MaxIts steps was taken
#                     *  7    stopping conditions are too stringent,
#                             further improvement is impossible,
#                             X contains best point found so far.
#                 * Rep.IterationsCount contains iterations count
#                 * NFEV countains number of function calculations
# 
#   -- ALGLIB --
#      Copyright 28.11.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: x, rep = xalglib.minbleicresults(state)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_minbleic_d_1' class=nav>[1]</a>&nbsp;&nbsp;<a href='#example_minbleic_d_2' class=nav>[2]</a>&nbsp;&nbsp;</p>
<a name='sub_minbleicresultsbuf'></a><h3 class=pageheader><code>minbleicresultsbuf</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# BLEIC results
# 
# Buffered implementation of MinBLEICResults() which uses pre-allocated buffer
# to store X[]. If buffer size is  too  small,  it  resizes  buffer.  It  is
# intended to be used in the inner cycles of performance critical algorithms
# where array reallocation penalty is too large to be ignored.
# 
#   -- ALGLIB --
#      Copyright 28.11.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: x, rep = xalglib.minbleicresultsbuf(state, x, rep)

</div></pre>
<a name='sub_minbleicsetbarrierdecay'></a><h3 class=pageheader><code>minbleicsetbarrierdecay</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# This function sets decay coefficient for barrier width.
# 
# By default, no barrier decay is used (Decay=1.0).
# 
# BLEIC optimizer uses  modified  barrier  functions  to  handle  inequality
# constraints. These functions are almost constant in the inner parts of the
# feasible  area,  but  grow rapidly to the infinity OUTSIDE of the feasible
# area. Barrier width is a distance from feasible area to  the  point  where
# modified barrier function becomes infinite. Decay coefficient allows us to
# decrease  barrier  width  from  the  initial  (suboptimial)  value   until
# optimal value will be met.
# 
# We recommend you either to set MuDecay=1.0 (no decay) or use some moderate
# value like 0.5-0.7
# 
# INPUT PARAMETERS:
#     State   -   structure which stores algorithm state
#     MuDecay -   0&lt;MuDecay&lt;=1, decay coefficient
# 
#   -- ALGLIB --
#      Copyright 28.11.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: xalglib.minbleicsetbarrierdecay(state, mudecay)

</div></pre>
<a name='sub_minbleicsetbarrierwidth'></a><h3 class=pageheader><code>minbleicsetbarrierwidth</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# This function sets initial barrier width.
# 
# BLEIC optimizer uses  modified  barrier  functions  to  handle  inequality
# constraints. These functions are almost constant in the inner parts of the
# feasible  area,  but  grow rapidly to the infinity OUTSIDE of the feasible
# area. Barrier width is a distance from feasible area to  the  point  where
# modified barrier function becomes infinite.
# 
# Barrier width must be:
# * small enough (below some problem-dependent value) in order for algorithm
#   to  converge.  Necessary  condition  is that the target function must be
#   well described by linear model in the areas as small as barrier width.
# * not VERY small (in order to avoid  difficulties  associated  with  rapid
#   changes in the modified function, ill-conditioning, round-off issues).
# 
# Choosing  appropriate  barrier  width  is  very  important  for  efficient
# optimization, and it often requires error  and  trial.  You  can  use  two
# strategies when choosing barrier width:
# * set barrier width with MinBLEICSetBarrierWidth() call. In this case  you
#   should try different barrier widths and examine results.
# * set decreasing barrier width by combining  MinBLEICSetBarrierWidth() and
#   MinBLEICSetBarrierDecay()  calls.  In  this case algorithm will decrease
#   barrier  width  after  each  outer iteration until it encounters optimal
#   barrier width.
# 
# INPUT PARAMETERS:
#     State   -   structure which stores algorithm state
#     Mu      -   &gt;0, initial barrier width
# 
#   -- ALGLIB --
#      Copyright 28.11.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: xalglib.minbleicsetbarrierwidth(state, mu)

</div></pre>
<a name='sub_minbleicsetbc'></a><h3 class=pageheader><code>minbleicsetbc</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# This function sets boundary constraints for BLEIC optimizer.
# 
# Boundary constraints are inactive by default (after initial creation).
# They are preserved after algorithm restart with MinBLEICRestartFrom().
# 
# INPUT PARAMETERS:
#     State   -   structure stores algorithm state
#     BndL    -   lower bounds, array[N].
#                 If some (all) variables are unbounded, you may specify
#                 very small number or -INF.
#     BndU    -   upper bounds, array[N].
#                 If some (all) variables are unbounded, you may specify
#                 very large number or +INF.
# 
#   -- ALGLIB --
#      Copyright 28.11.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: xalglib.minbleicsetbc(state, bndl, bndu)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_minbleic_d_1' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_minbleicsetinnercond'></a><h3 class=pageheader><code>minbleicsetinnercond</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# This function sets stopping conditions for the underlying nonlinear CG
# optimizer. It controls overall accuracy of solution. These conditions
# should be strict enough in order for algorithm to converge.
# 
# INPUT PARAMETERS:
#     State   -   structure which stores algorithm state
#     EpsG    -   &gt;=0
#                 Algorithm finishes its work if 2-norm of the Lagrangian
#                 gradient is less than or equal to EpsG.
#     EpsF    -   &gt;=0
#                 The  subroutine  finishes  its work if on k+1-th iteration
#                 the  condition  |F(k+1)-F(k)|&lt;=EpsF*max{|F(k)|,|F(k+1)|,1}
#                 is satisfied.
#     EpsX    -   &gt;=0
#                 The subroutine finishes its work if  on  k+1-th  iteration
#                 the condition |X(k+1)-X(k)| &lt;= EpsX is fulfilled.
# 
# Passing EpsG=0, EpsF=0 and EpsX=0 (simultaneously) will lead to
# automatic stopping criterion selection.
# 
# These conditions are used to terminate inner iterations. However, you
# need to tune termination conditions for outer iterations too.
# 
#   -- ALGLIB --
#      Copyright 28.11.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: xalglib.minbleicsetinnercond(state, epsg, epsf, epsx)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_minbleic_d_1' class=nav>[1]</a>&nbsp;&nbsp;<a href='#example_minbleic_d_2' class=nav>[2]</a>&nbsp;&nbsp;</p>
<a name='sub_minbleicsetlc'></a><h3 class=pageheader><code>minbleicsetlc</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# This function sets linear constraints for BLEIC optimizer.
# 
# Linear constraints are inactive by default (after initial creation).
# They are preserved after algorithm restart with MinBLEICRestartFrom().
# 
# INPUT PARAMETERS:
#     State   -   structure previously allocated with MinBLEICCreate call.
#     C       -   linear constraints, array[K,N+1].
#                 Each row of C represents one constraint, either equality
#                 or inequality (see below):
#                 * first N elements correspond to coefficients,
#                 * last element corresponds to the right part.
#                 All elements of C (including right part) must be finite.
#     CT      -   type of constraints, array[K]:
#                 * if CT[i]&gt;0, then I-th constraint is C[i,*]*x &gt;= C[i,n+1]
#                 * if CT[i]=0, then I-th constraint is C[i,*]*x  = C[i,n+1]
#                 * if CT[i]&lt;0, then I-th constraint is C[i,*]*x &lt;= C[i,n+1]
#     K       -   number of equality/inequality constraints, K&gt;=0:
#                 * if given, only leading K elements of C/CT are used
#                 * if not given, automatically determined from sizes of C/CT
# 
#   -- ALGLIB --
#      Copyright 28.11.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: xalglib.minbleicsetlc(state, c, ct, k)
SYNTAX: xalglib.minbleicsetlc(state, c, ct)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_minbleic_d_2' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_minbleicsetmaxits'></a><h3 class=pageheader><code>minbleicsetmaxits</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# This function allows to stop algorithm after specified number of inner
# iterations.
# 
# INPUT PARAMETERS:
#     State   -   structure which stores algorithm state
#     MaxIts  -   maximum number of inner iterations.
#                 If MaxIts=0, the number of iterations is unlimited.
# 
#   -- ALGLIB --
#      Copyright 28.11.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: xalglib.minbleicsetmaxits(state, maxits)

</div></pre>
<a name='sub_minbleicsetoutercond'></a><h3 class=pageheader><code>minbleicsetoutercond</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# This function sets stopping conditions for outer iteration of BLEIC algo.
# 
# These conditions control accuracy of constraint handling and amount of
# infeasibility allowed in the solution.
# 
# INPUT PARAMETERS:
#     State   -   structure which stores algorithm state
#     EpsX    -   &gt;0, stopping condition on outer iteration step length
#     EpsI    -   &gt;0, stopping condition on infeasibility
# 
# Both EpsX and EpsI must be non-zero.
# 
# MEANING OF EpsX
# 
# EpsX  is  a  stopping  condition for outer iterations. Algorithm will stop
# when  solution  of  the  current  modified  subproblem will be within EpsX
# (using 2-norm) of the previous solution.
# 
# MEANING OF EpsI
# 
# EpsI controls feasibility properties -  algorithm  won't  stop  until  all
# inequality constraints will be satisfied with error (distance from current
# point to the feasible area) at most EpsI.
# 
#   -- ALGLIB --
#      Copyright 28.11.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: xalglib.minbleicsetoutercond(state, epsx, epsi)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_minbleic_d_1' class=nav>[1]</a>&nbsp;&nbsp;<a href='#example_minbleic_d_2' class=nav>[2]</a>&nbsp;&nbsp;</p>
<a name='sub_minbleicsetstpmax'></a><h3 class=pageheader><code>minbleicsetstpmax</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# This function sets maximum step length
# 
# INPUT PARAMETERS:
#     State   -   structure which stores algorithm state
#     StpMax  -   maximum step length, &gt;=0. Set StpMax to 0.0,  if you don't
#                 want to limit step length.
# 
# Use this subroutine when you optimize target function which contains exp()
# or  other  fast  growing  functions,  and optimization algorithm makes too
# large  steps  which  lead   to overflow. This function allows us to reject
# steps  that  are  too  large  (and  therefore  expose  us  to the possible
# overflow) without actually calculating function value at the x+stp*d.
# 
#   -- ALGLIB --
#      Copyright 02.04.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: xalglib.minbleicsetstpmax(state, stpmax)

</div></pre>
<a name='sub_minbleicsetxrep'></a><h3 class=pageheader><code>minbleicsetxrep</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# This function turns on/off reporting.
# 
# INPUT PARAMETERS:
#     State   -   structure which stores algorithm state
#     NeedXRep-   whether iteration reports are needed or not
# 
# If NeedXRep is True, algorithm will call rep() callback function if  it is
# provided to MinBLEICOptimize().
# 
#   -- ALGLIB --
#      Copyright 28.11.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: xalglib.minbleicsetxrep(state, needxrep)

</div></pre>
<a name='example_minbleic_d_1'></a><h3 class=pageheader>minbleic_d_1 example</h3>
<pre class=source>
import xalglib

<b>def</b> function1_grad(x, grad, param):
    <font color=darkcyan>#</font>
    <font color=darkcyan># this callback calculates f(x0,x1) = 100*(x0+3)^4 + (x1-3)^4</font>
    <font color=darkcyan># and its derivatives df/d0 and df/dx1</font>
    <font color=darkcyan>#</font>
    func = 100*(x[0]+3)**4 + (x[1]-3)**4
    grad[0] = 400*(x[0]+3)**3
    grad[1] = 4*(x[1]-3)**3
    <b>return</b> func

<font color=darkcyan>#</font>
<font color=darkcyan># This example demonstrates minimization of f(x,y) = 100*(x+3)^4+(y-3)^4</font>
<font color=darkcyan># subject to bound constraints -1&lt;=x&lt;=+1, -1&lt;=y&lt;=+1, using BLEIC optimizer.</font>
<font color=darkcyan>#</font>
x = [0,0]
bndl = [-1,-1]
bndu = [+1,+1]

<font color=darkcyan>#</font>
<font color=darkcyan># These variables define stopping conditions <b>for</b> the underlying CG algorithm.</font>
<font color=darkcyan># They should be stringent enough in order to guarantee overall stability</font>
<font color=darkcyan># of the outer iterations.</font>
<font color=darkcyan>#</font>
<font color=darkcyan># We use very simple condition - |g|&lt;=epsg</font>
<font color=darkcyan>#</font>
epsg = 0.000001
epsf = 0
epsx = 0

<font color=darkcyan>#</font>
<font color=darkcyan># These variables define stopping conditions <b>for</b> the outer iterations:</font>
<font color=darkcyan># * epso controls convergence of outer iterations; algorithm will stop</font>
<font color=darkcyan>#   when difference between solutions of subsequent unconstrained problems</font>
<font color=darkcyan>#   will be less than 0.0001</font>
<font color=darkcyan># * epsi controls amount of infeasibility allowed in the final solution;</font>
<font color=darkcyan>#   algorithm will stop when infeasibility of the solution will be</font>
<font color=darkcyan>#   less than 0.0001</font>
<font color=darkcyan>#</font>
epso = 0.00001
epsi = 0.00001

<font color=darkcyan>#</font>
<font color=darkcyan># This variable defines barrier width.</font>
<font color=darkcyan># </font>
<font color=darkcyan># Barrier width must be:</font>
<font color=darkcyan># * small enough (below some problem-dependent value) in order <b>for</b> algorithm</font>
<font color=darkcyan>#   to  converge.  Necessary  condition  is that the target function must be</font>
<font color=darkcyan>#   well described by linear model in the areas as small as barrier width.</font>
<font color=darkcyan># * not VERY small (in order to avoid  difficulties  associated  with  rapid</font>
<font color=darkcyan>#   changes in the modified function, ill-conditioning, round-off issues).</font>
<font color=darkcyan>#</font>
<font color=darkcyan># Here we try small constant barrier width in the hope that this value will</font>
<font color=darkcyan># be good enough. Another strategy (monotonically decreasing width) is possible,</font>
<font color=darkcyan># and described in the other examples.</font>
<font color=darkcyan>#</font>
mu = 0.0001

<font color=darkcyan>#</font>
<font color=darkcyan># Now we are ready to actually optimize something:</font>
<font color=darkcyan># * first we create optimizer</font>
<font color=darkcyan># * we add boundary constraints</font>
<font color=darkcyan># * we tune stopping conditions and barrier width</font>
<font color=darkcyan># * and, finally, optimize and obtain results...</font>
<font color=darkcyan>#</font>
state = xalglib.minbleiccreate(x)
xalglib.minbleicsetbc(state, bndl, bndu)
xalglib.minbleicsetinnercond(state, epsg, epsf, epsx)
xalglib.minbleicsetoutercond(state, epso, epsi)
xalglib.minbleicsetbarrierwidth(state, mu)
xalglib.minbleicoptimize_g(state, function1_grad)
x, rep = xalglib.minbleicresults(state)

<font color=darkcyan>#</font>
<font color=darkcyan># ...and evaluate these results</font>
<font color=darkcyan>#</font>
print(rep.terminationtype) <font color=darkcyan># expected 4</font>
print(x) <font color=darkcyan># expected [-1,1]</font>


</pre><a name='example_minbleic_d_2'></a><h3 class=pageheader>minbleic_d_2 example</h3>
<pre class=source>
import xalglib

<b>def</b> function1_grad(x, grad, param):
    <font color=darkcyan>#</font>
    <font color=darkcyan># this callback calculates f(x0,x1) = 100*(x0+3)^4 + (x1-3)^4</font>
    <font color=darkcyan># and its derivatives df/d0 and df/dx1</font>
    <font color=darkcyan>#</font>
    func = 100*(x[0]+3)**4 + (x[1]-3)**4
    grad[0] = 400*(x[0]+3)**3
    grad[1] = 4*(x[1]-3)**3
    <b>return</b> func

<font color=darkcyan>#</font>
<font color=darkcyan># This example demonstrates minimization of f(x,y) = 100*(x+3)^4+(y-3)^4</font>
<font color=darkcyan># subject to inequality constraints:</font>
<font color=darkcyan># * x&gt;=2 (posed as general linear constraint),</font>
<font color=darkcyan># * x+y&gt;=6</font>
<font color=darkcyan># using BLEIC optimizer.</font>
<font color=darkcyan>#</font>
x = [5,5]
c = [[1,0,2],[1,1,6]]
ct = [1,1]

<font color=darkcyan>#</font>
<font color=darkcyan># These variables define stopping conditions <b>for</b> the underlying CG algorithm.</font>
<font color=darkcyan># They should be stringent enough in order to guarantee overall stability</font>
<font color=darkcyan># of the outer iterations.</font>
<font color=darkcyan>#</font>
<font color=darkcyan># We use very simple condition - |g|&lt;=epsg</font>
<font color=darkcyan>#</font>
epsg = 0.000001
epsf = 0
epsx = 0

<font color=darkcyan>#</font>
<font color=darkcyan># These variables define stopping conditions <b>for</b> the outer iterations:</font>
<font color=darkcyan># * epso controls convergence of outer iterations; algorithm will stop</font>
<font color=darkcyan>#   when difference between solutions of subsequent unconstrained problems</font>
<font color=darkcyan>#   will be less than 0.0001</font>
<font color=darkcyan># * epsi controls amount of infeasibility allowed in the final solution;</font>
<font color=darkcyan>#   algorithm will stop when infeasibility of the solution will be</font>
<font color=darkcyan>#   less than 0.0001</font>
<font color=darkcyan>#</font>
epso = 0.00001
epsi = 0.00001

<font color=darkcyan>#</font>
<font color=darkcyan># This variable defines barrier width.</font>
<font color=darkcyan># </font>
<font color=darkcyan># Barrier width must be:</font>
<font color=darkcyan># * small enough (below some problem-dependent value) in order <b>for</b> algorithm</font>
<font color=darkcyan>#   to  converge.  Necessary  condition  is that the target function must be</font>
<font color=darkcyan>#   well described by linear model in the areas as small as barrier width.</font>
<font color=darkcyan># * not VERY small (in order to avoid  difficulties  associated  with  rapid</font>
<font color=darkcyan>#   changes in the modified function, ill-conditioning, round-off issues).</font>
<font color=darkcyan>#</font>
<font color=darkcyan># Here we try small constant barrier width in the hope that this value will</font>
<font color=darkcyan># be good enough. Another strategy (monotonically decreasing width) is possible,</font>
<font color=darkcyan># and described in the other examples.</font>
<font color=darkcyan>#</font>
mu = 0.0001

<font color=darkcyan>#</font>
<font color=darkcyan># Now we are ready to actually optimize something:</font>
<font color=darkcyan># * first we create optimizer</font>
<font color=darkcyan># * we add linear constraints</font>
<font color=darkcyan># * we tune stopping conditions</font>
<font color=darkcyan># * and, finally, optimize and obtain results...</font>
<font color=darkcyan>#</font>
state = xalglib.minbleiccreate(x)
xalglib.minbleicsetlc(state, c, ct)
xalglib.minbleicsetinnercond(state, epsg, epsf, epsx)
xalglib.minbleicsetoutercond(state, epso, epsi)
xalglib.minbleicsetbarrierwidth(state, mu)
xalglib.minbleicoptimize_g(state, function1_grad)
x, rep = xalglib.minbleicresults(state)

<font color=darkcyan>#</font>
<font color=darkcyan># ...and evaluate these results</font>
<font color=darkcyan>#</font>
print(rep.terminationtype) <font color=darkcyan># expected 4</font>
print(x) <font color=darkcyan># expected [2,4]</font>


</pre><a name=unit_mincg></a><h2 class=pageheader><code>mincg</code> module</h2>
<div class=pagecontent>
<h3 class=pageheader>Classes</h3>
<a href='#struct_mincgreport' class=toc>mincgreport</a><br>
<a href='#struct_mincgstate' class=toc>mincgstate</a><br>
<h3 class=pageheader>Functions</h3>
<a href='#sub_mincgcreate' class=toc>mincgcreate</a><br>
<a href='#sub_mincgoptimize' class=toc>mincgoptimize</a><br>
<a href='#sub_mincgrestartfrom' class=toc>mincgrestartfrom</a><br>
<a href='#sub_mincgresults' class=toc>mincgresults</a><br>
<a href='#sub_mincgresultsbuf' class=toc>mincgresultsbuf</a><br>
<a href='#sub_mincgsetcgtype' class=toc>mincgsetcgtype</a><br>
<a href='#sub_mincgsetcond' class=toc>mincgsetcond</a><br>
<a href='#sub_mincgsetstpmax' class=toc>mincgsetstpmax</a><br>
<a href='#sub_mincgsetxrep' class=toc>mincgsetxrep</a><br>
<a href='#sub_mincgsuggeststep' class=toc>mincgsuggeststep</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
<tr align=left valign=top><td><a href='#example_mincg_d_1' class=toc>mincg_d_1</a></td><td width=15>&nbsp;</td><td>Nonlinear optimization by CG</td></tr>
<tr align=left valign=top><td><a href='#example_mincg_d_2' class=toc>mincg_d_2</a></td><td width=15>&nbsp;</td><td>Nonlinear optimization with additional settings and restarts</td></tr>
</table></div>
<a name='struct_mincgreport'></a><h3 class=pageheader><code>mincgreport</code> class</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# 
#

</div><div style='margin-top: 0; margin-bottom: 0;'><span style='font-weight: bold; color: green;'>class</span> mincgreport(object):
    ...

</div></pre>
<a name='struct_mincgstate'></a><h3 class=pageheader><code>mincgstate</code> class</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# This object stores state of the nonlinear CG optimizer.
# 
# You should use ALGLIB functions to work with this object.
#

</div><div style='margin-top: 0; margin-bottom: 0;'><span style='font-weight: bold; color: green;'>class</span> mincgstate(object):
    ...

</div></pre>
<a name='sub_mincgcreate'></a><h3 class=pageheader><code>mincgcreate</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
#         NONLINEAR CONJUGATE GRADIENT METHOD
# 
# DESCRIPTION:
# The subroutine minimizes function F(x) of N arguments by using one of  the
# nonlinear conjugate gradient methods.
# 
# These CG methods are globally convergent (even on non-convex functions) as
# long as grad(f) is Lipschitz continuous in  a  some  neighborhood  of  the
# L = { x : f(x)&lt;=f(x0) }.
# 
# 
# REQUIREMENTS:
# Algorithm will request following information during its operation:
# * function value F and its gradient G (simultaneously) at given point X
# 
# 
# USAGE:
# 1. User initializes algorithm state with MinCGCreate() call
# 2. User tunes solver parameters with MinCGSetCond(), MinCGSetStpMax() and
#    other functions
# 3. User calls MinCGOptimize() function which takes algorithm  state   and
#    pointer (delegate, etc.) to callback function which calculates F/G.
# 4. User calls MinCGResults() to get solution
# 5. Optionally, user may call MinCGRestartFrom() to solve another  problem
#    with same N but another starting point and/or another function.
#    MinCGRestartFrom() allows to reuse already initialized structure.
# 
# 
# INPUT PARAMETERS:
#     N       -   problem dimension, N&gt;0:
#                 * if given, only leading N elements of X are used
#                 * if not given, automatically determined from size of X
#     X       -   starting point, array[0..N-1].
# 
# OUTPUT PARAMETERS:
#     State   -   structure which stores algorithm state
# 
#   -- ALGLIB --
#      Copyright 25.03.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: state = xalglib.mincgcreate(n, x)
SYNTAX: state = xalglib.mincgcreate(x)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_mincg_d_1' class=nav>[1]</a>&nbsp;&nbsp;<a href='#example_mincg_d_2' class=nav>[2]</a>&nbsp;&nbsp;</p>
<a name='sub_mincgoptimize'></a><h3 class=pageheader><code>mincgoptimize</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# This family of functions is used to launcn iterations of nonlinear optimizer
# 
# These functions accept following parameters:
#     state   -   algorithm state
#     grad    -   callback which calculates function (or merit function)
#                 value func and gradient grad at given point x
#     rep     -   optional callback which is called after each iteration
#                 can be NULL
#     ptr     -   optional pointer which is passed to func/grad/hess/jac/rep
#                 can be NULL
# 
# 
#   -- ALGLIB --
#      Copyright 20.04.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: xalglib.mincgoptimize_g(state, grad, rep = None, param = None)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_mincg_d_1' class=nav>[1]</a>&nbsp;&nbsp;<a href='#example_mincg_d_2' class=nav>[2]</a>&nbsp;&nbsp;</p>
<a name='sub_mincgrestartfrom'></a><h3 class=pageheader><code>mincgrestartfrom</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# This  subroutine  restarts  CG  algorithm from new point. All optimization
# parameters are left unchanged.
# 
# This  function  allows  to  solve multiple  optimization  problems  (which
# must have same number of dimensions) without object reallocation penalty.
# 
# INPUT PARAMETERS:
#     State   -   structure used to store algorithm state.
#     X       -   new starting point.
# 
#   -- ALGLIB --
#      Copyright 30.07.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: xalglib.mincgrestartfrom(state, x)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_mincg_d_2' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_mincgresults'></a><h3 class=pageheader><code>mincgresults</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Conjugate gradient results
# 
# INPUT PARAMETERS:
#     State   -   algorithm state
# 
# OUTPUT PARAMETERS:
#     X       -   array[0..N-1], solution
#     Rep     -   optimization report:
#                 * Rep.TerminationType completetion code:
#                     *  1    relative function improvement is no more than
#                             EpsF.
#                     *  2    relative step is no more than EpsX.
#                     *  4    gradient norm is no more than EpsG
#                     *  5    MaxIts steps was taken
#                     *  7    stopping conditions are too stringent,
#                             further improvement is impossible,
#                             we return best X found so far
#                 * Rep.IterationsCount contains iterations count
#                 * NFEV countains number of function calculations
# 
#   -- ALGLIB --
#      Copyright 20.04.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: x, rep = xalglib.mincgresults(state)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_mincg_d_1' class=nav>[1]</a>&nbsp;&nbsp;<a href='#example_mincg_d_2' class=nav>[2]</a>&nbsp;&nbsp;</p>
<a name='sub_mincgresultsbuf'></a><h3 class=pageheader><code>mincgresultsbuf</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Conjugate gradient results
# 
# Buffered implementation of MinCGResults(), which uses pre-allocated buffer
# to store X[]. If buffer size is  too  small,  it  resizes  buffer.  It  is
# intended to be used in the inner cycles of performance critical algorithms
# where array reallocation penalty is too large to be ignored.
# 
#   -- ALGLIB --
#      Copyright 20.04.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: x, rep = xalglib.mincgresultsbuf(state, x, rep)

</div></pre>
<a name='sub_mincgsetcgtype'></a><h3 class=pageheader><code>mincgsetcgtype</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# This function sets CG algorithm.
# 
# INPUT PARAMETERS:
#     State   -   structure which stores algorithm state
#     CGType  -   algorithm type:
#                 * -1    automatic selection of the best algorithm
#                 * 0     DY (Dai and Yuan) algorithm
#                 * 1     Hybrid DY-HS algorithm
# 
#   -- ALGLIB --
#      Copyright 02.04.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: xalglib.mincgsetcgtype(state, cgtype)

</div></pre>
<a name='sub_mincgsetcond'></a><h3 class=pageheader><code>mincgsetcond</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# This function sets stopping conditions for CG optimization algorithm.
# 
# INPUT PARAMETERS:
#     State   -   structure which stores algorithm state
#     EpsG    -   &gt;=0
#                 The  subroutine  finishes  its  work   if   the  condition
#                 ||G||&lt;EpsG is satisfied, where ||.|| means Euclidian norm,
#                 G - gradient.
#     EpsF    -   &gt;=0
#                 The  subroutine  finishes  its work if on k+1-th iteration
#                 the  condition  |F(k+1)-F(k)|&lt;=EpsF*max{|F(k)|,|F(k+1)|,1}
#                 is satisfied.
#     EpsX    -   &gt;=0
#                 The subroutine finishes its work if  on  k+1-th  iteration
#                 the condition |X(k+1)-X(k)| &lt;= EpsX is fulfilled.
#     MaxIts  -   maximum number of iterations. If MaxIts=0, the  number  of
#                 iterations is unlimited.
# 
# Passing EpsG=0, EpsF=0, EpsX=0 and MaxIts=0 (simultaneously) will lead to
# automatic stopping criterion selection (small EpsX).
# 
#   -- ALGLIB --
#      Copyright 02.04.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: xalglib.mincgsetcond(state, epsg, epsf, epsx, maxits)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_mincg_d_1' class=nav>[1]</a>&nbsp;&nbsp;<a href='#example_mincg_d_2' class=nav>[2]</a>&nbsp;&nbsp;</p>
<a name='sub_mincgsetstpmax'></a><h3 class=pageheader><code>mincgsetstpmax</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# This function sets maximum step length
# 
# INPUT PARAMETERS:
#     State   -   structure which stores algorithm state
#     StpMax  -   maximum step length, &gt;=0. Set StpMax to 0.0,  if you don't
#                 want to limit step length.
# 
# Use this subroutine when you optimize target function which contains exp()
# or  other  fast  growing  functions,  and optimization algorithm makes too
# large  steps  which  leads  to overflow. This function allows us to reject
# steps  that  are  too  large  (and  therefore  expose  us  to the possible
# overflow) without actually calculating function value at the x+stp*d.
# 
#   -- ALGLIB --
#      Copyright 02.04.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: xalglib.mincgsetstpmax(state, stpmax)

</div></pre>
<a name='sub_mincgsetxrep'></a><h3 class=pageheader><code>mincgsetxrep</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# This function turns on/off reporting.
# 
# INPUT PARAMETERS:
#     State   -   structure which stores algorithm state
#     NeedXRep-   whether iteration reports are needed or not
# 
# If NeedXRep is True, algorithm will call rep() callback function if  it is
# provided to MinCGOptimize().
# 
#   -- ALGLIB --
#      Copyright 02.04.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: xalglib.mincgsetxrep(state, needxrep)

</div></pre>
<a name='sub_mincgsuggeststep'></a><h3 class=pageheader><code>mincgsuggeststep</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# This function allows to suggest initial step length to the CG algorithm.
# 
# Suggested  step  length  is used as starting point for the line search. It
# can be useful when you have  badly  scaled  problem,  i.e.  when  ||grad||
# (which is used as initial estimate for the first step) is many  orders  of
# magnitude different from the desired step.
# 
# Line search  may  fail  on  such problems without good estimate of initial
# step length. Imagine, for example, problem with ||grad||=10^50 and desired
# step equal to 0.1 Line  search function will use 10^50  as  initial  step,
# then  it  will  decrease step length by 2 (up to 20 attempts) and will get
# 10^44, which is still too large.
# 
# This function allows us to tell than line search should  be  started  from
# some moderate step length, like 1.0, so algorithm will be able  to  detect
# desired step length in a several searches.
# 
# This function influences only first iteration of algorithm. It  should  be
# called between MinCGCreate/MinCGRestartFrom() call and MinCGOptimize call.
# 
# INPUT PARAMETERS:
#     State   -   structure used to store algorithm state.
#     Stp     -   initial estimate of the step length.
#                 Can be zero (no estimate).
# 
#   -- ALGLIB --
#      Copyright 30.07.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: xalglib.mincgsuggeststep(state, stp)

</div></pre>
<a name='example_mincg_d_1'></a><h3 class=pageheader>mincg_d_1 example</h3>
<pre class=source>
import xalglib

<b>def</b> function1_grad(x, grad, param):
    <font color=darkcyan>#</font>
    <font color=darkcyan># this callback calculates f(x0,x1) = 100*(x0+3)^4 + (x1-3)^4</font>
    <font color=darkcyan># and its derivatives df/d0 and df/dx1</font>
    <font color=darkcyan>#</font>
    func = 100*(x[0]+3)**4 + (x[1]-3)**4
    grad[0] = 400*(x[0]+3)**3
    grad[1] = 4*(x[1]-3)**3
    <b>return</b> func

<font color=darkcyan>#</font>
<font color=darkcyan># This example demonstrates minimization of f(x,y) = 100*(x+3)^4+(y-3)^4</font>
<font color=darkcyan># with nonlinear conjugate gradient method.</font>
<font color=darkcyan>#</font>
x = [0,0]
epsg = 0.0000000001
epsf = 0
epsx = 0
maxits = 0

state = xalglib.mincgcreate(x)
xalglib.mincgsetcond(state, epsg, epsf, epsx, maxits)
xalglib.mincgoptimize_g(state, function1_grad)
x, rep = xalglib.mincgresults(state)

print(rep.terminationtype) <font color=darkcyan># expected 4</font>
print(x) <font color=darkcyan># expected [-3,3]</font>


</pre><a name='example_mincg_d_2'></a><h3 class=pageheader>mincg_d_2 example</h3>
<pre class=source>
import xalglib

<b>def</b> function1_grad(x, grad, param):
    <font color=darkcyan>#</font>
    <font color=darkcyan># this callback calculates f(x0,x1) = 100*(x0+3)^4 + (x1-3)^4</font>
    <font color=darkcyan># and its derivatives df/d0 and df/dx1</font>
    <font color=darkcyan>#</font>
    func = 100*(x[0]+3)**4 + (x[1]-3)**4
    grad[0] = 400*(x[0]+3)**3
    grad[1] = 4*(x[1]-3)**3
    <b>return</b> func

<font color=darkcyan>#</font>
<font color=darkcyan># This example demonstrates minimization of f(x,y) = 100*(x+3)^4+(y-3)^4</font>
<font color=darkcyan># with nonlinear conjugate gradient method.</font>
<font color=darkcyan>#</font>
<font color=darkcyan># Several advanced techniques are demonstrated:</font>
<font color=darkcyan># * upper limit on step size</font>
<font color=darkcyan># * restart from new point</font>
<font color=darkcyan>#</font>
x = [0,0]
epsg = 0.0000000001
epsf = 0
epsx = 0
stpmax = 0.1
maxits = 0

<font color=darkcyan># first run</font>
state = xalglib.mincgcreate(x)
xalglib.mincgsetcond(state, epsg, epsf, epsx, maxits)
xalglib.mincgsetstpmax(state, stpmax)
xalglib.mincgoptimize_g(state, function1_grad)
x, rep = xalglib.mincgresults(state)

print(x) <font color=darkcyan># expected [-3,3]</font>

<font color=darkcyan># second run - algorithm is restarted with mincgrestartfrom()</font>
x = [10,10]
xalglib.mincgrestartfrom(state, x)
xalglib.mincgoptimize_g(state, function1_grad)
x, rep = xalglib.mincgresults(state)

print(rep.terminationtype) <font color=darkcyan># expected 4</font>
print(x) <font color=darkcyan># expected [-3,3]</font>


</pre><a name=unit_minlbfgs></a><h2 class=pageheader><code>minlbfgs</code> module</h2>
<div class=pagecontent>
<h3 class=pageheader>Classes</h3>
<a href='#struct_minlbfgsreport' class=toc>minlbfgsreport</a><br>
<a href='#struct_minlbfgsstate' class=toc>minlbfgsstate</a><br>
<h3 class=pageheader>Functions</h3>
<a href='#sub_minlbfgscreate' class=toc>minlbfgscreate</a><br>
<a href='#sub_minlbfgsoptimize' class=toc>minlbfgsoptimize</a><br>
<a href='#sub_minlbfgsrestartfrom' class=toc>minlbfgsrestartfrom</a><br>
<a href='#sub_minlbfgsresults' class=toc>minlbfgsresults</a><br>
<a href='#sub_minlbfgsresultsbuf' class=toc>minlbfgsresultsbuf</a><br>
<a href='#sub_minlbfgssetcholeskypreconditioner' class=toc>minlbfgssetcholeskypreconditioner</a><br>
<a href='#sub_minlbfgssetcond' class=toc>minlbfgssetcond</a><br>
<a href='#sub_minlbfgssetdefaultpreconditioner' class=toc>minlbfgssetdefaultpreconditioner</a><br>
<a href='#sub_minlbfgssetstpmax' class=toc>minlbfgssetstpmax</a><br>
<a href='#sub_minlbfgssetxrep' class=toc>minlbfgssetxrep</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
<tr align=left valign=top><td><a href='#example_minlbfgs_d_1' class=toc>minlbfgs_d_1</a></td><td width=15>&nbsp;</td><td>Nonlinear optimization by L-BFGS</td></tr>
<tr align=left valign=top><td><a href='#example_minlbfgs_d_2' class=toc>minlbfgs_d_2</a></td><td width=15>&nbsp;</td><td>Nonlinear optimization with additional settings and restarts</td></tr>
</table></div>
<a name='struct_minlbfgsreport'></a><h3 class=pageheader><code>minlbfgsreport</code> class</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# 
#

</div><div style='margin-top: 0; margin-bottom: 0;'><span style='font-weight: bold; color: green;'>class</span> minlbfgsreport(object):
    ...

</div></pre>
<a name='struct_minlbfgsstate'></a><h3 class=pageheader><code>minlbfgsstate</code> class</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# 
#

</div><div style='margin-top: 0; margin-bottom: 0;'><span style='font-weight: bold; color: green;'>class</span> minlbfgsstate(object):
    ...

</div></pre>
<a name='sub_minlbfgscreate'></a><h3 class=pageheader><code>minlbfgscreate</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
#         LIMITED MEMORY BFGS METHOD FOR LARGE SCALE OPTIMIZATION
# 
# DESCRIPTION:
# The subroutine minimizes function F(x) of N arguments by  using  a  quasi-
# Newton method (LBFGS scheme) which is optimized to use  a  minimum  amount
# of memory.
# The subroutine generates the approximation of an inverse Hessian matrix by
# using information about the last M steps of the algorithm  (instead of N).
# It lessens a required amount of memory from a value  of  order  N^2  to  a
# value of order 2*N*M.
# 
# 
# REQUIREMENTS:
# Algorithm will request following information during its operation:
# * function value F and its gradient G (simultaneously) at given point X
# 
# 
# USAGE:
# 1. User initializes algorithm state with MinLBFGSCreate() call
# 2. User tunes solver parameters with MinLBFGSSetCond() MinLBFGSSetStpMax()
#    and other functions
# 3. User calls MinLBFGSOptimize() function which takes algorithm  state and
#    pointer (delegate, etc.) to callback function which calculates F/G.
# 4. User calls MinLBFGSResults() to get solution
# 5. Optionally user may call MinLBFGSRestartFrom() to solve another problem
#    with same N/M but another starting point and/or another function.
#    MinLBFGSRestartFrom() allows to reuse already initialized structure.
# 
# 
# INPUT PARAMETERS:
#     N       -   problem dimension. N&gt;0
#     M       -   number of corrections in the BFGS scheme of Hessian
#                 approximation update. Recommended value:  3&lt;=M&lt;=7. The smaller
#                 value causes worse convergence, the bigger will  not  cause  a
#                 considerably better convergence, but will cause a fall in  the
#                 performance. M&lt;=N.
#     X       -   initial solution approximation, array[0..N-1].
# 
# 
# OUTPUT PARAMETERS:
#     State   -   structure which stores algorithm state
# 
# 
# NOTES:
# 1. you may tune stopping conditions with MinLBFGSSetCond() function
# 2. if target function contains exp() or other fast growing functions,  and
#    optimization algorithm makes too large steps which leads  to  overflow,
#    use MinLBFGSSetStpMax() function to bound algorithm's  steps.  However,
#    L-BFGS rarely needs such a tuning.
# 
# 
#   -- ALGLIB --
#      Copyright 02.04.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: state = xalglib.minlbfgscreate(n, m, x)
SYNTAX: state = xalglib.minlbfgscreate(m, x)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_minlbfgs_d_1' class=nav>[1]</a>&nbsp;&nbsp;<a href='#example_minlbfgs_d_2' class=nav>[2]</a>&nbsp;&nbsp;</p>
<a name='sub_minlbfgsoptimize'></a><h3 class=pageheader><code>minlbfgsoptimize</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# This family of functions is used to launcn iterations of nonlinear optimizer
# 
# These functions accept following parameters:
#     state   -   algorithm state
#     grad    -   callback which calculates function (or merit function)
#                 value func and gradient grad at given point x
#     rep     -   optional callback which is called after each iteration
#                 can be NULL
#     ptr     -   optional pointer which is passed to func/grad/hess/jac/rep
#                 can be NULL
# 
# 
#   -- ALGLIB --
#      Copyright 20.03.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: xalglib.minlbfgsoptimize_g(state, grad, rep = None, param = None)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_minlbfgs_d_1' class=nav>[1]</a>&nbsp;&nbsp;<a href='#example_minlbfgs_d_2' class=nav>[2]</a>&nbsp;&nbsp;</p>
<a name='sub_minlbfgsrestartfrom'></a><h3 class=pageheader><code>minlbfgsrestartfrom</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# This  subroutine restarts LBFGS algorithm from new point. All optimization
# parameters are left unchanged.
# 
# This  function  allows  to  solve multiple  optimization  problems  (which
# must have same number of dimensions) without object reallocation penalty.
# 
# INPUT PARAMETERS:
#     State   -   structure used to store algorithm state
#     X       -   new starting point.
# 
#   -- ALGLIB --
#      Copyright 30.07.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: xalglib.minlbfgsrestartfrom(state, x)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_minlbfgs_d_2' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_minlbfgsresults'></a><h3 class=pageheader><code>minlbfgsresults</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# L-BFGS algorithm results
# 
# INPUT PARAMETERS:
#     State   -   algorithm state
# 
# OUTPUT PARAMETERS:
#     X       -   array[0..N-1], solution
#     Rep     -   optimization report:
#                 * Rep.TerminationType completetion code:
#                     * -2    rounding errors prevent further improvement.
#                             X contains best point found.
#                     * -1    incorrect parameters were specified
#                     *  1    relative function improvement is no more than
#                             EpsF.
#                     *  2    relative step is no more than EpsX.
#                     *  4    gradient norm is no more than EpsG
#                     *  5    MaxIts steps was taken
#                     *  7    stopping conditions are too stringent,
#                             further improvement is impossible
#                 * Rep.IterationsCount contains iterations count
#                 * NFEV countains number of function calculations
# 
#   -- ALGLIB --
#      Copyright 02.04.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: x, rep = xalglib.minlbfgsresults(state)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_minlbfgs_d_1' class=nav>[1]</a>&nbsp;&nbsp;<a href='#example_minlbfgs_d_2' class=nav>[2]</a>&nbsp;&nbsp;</p>
<a name='sub_minlbfgsresultsbuf'></a><h3 class=pageheader><code>minlbfgsresultsbuf</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# L-BFGS algorithm results
# 
# Buffered implementation of MinLBFGSResults which uses pre-allocated buffer
# to store X[]. If buffer size is  too  small,  it  resizes  buffer.  It  is
# intended to be used in the inner cycles of performance critical algorithms
# where array reallocation penalty is too large to be ignored.
# 
#   -- ALGLIB --
#      Copyright 20.08.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: x, rep = xalglib.minlbfgsresultsbuf(state, x, rep)

</div></pre>
<a name='sub_minlbfgssetcholeskypreconditioner'></a><h3 class=pageheader><code>minlbfgssetcholeskypreconditioner</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Modification of the preconditioner:
# Cholesky factorization of approximate Hessian is used.
# 
# INPUT PARAMETERS:
#     State   -   structure which stores algorithm state
#     P       -   triangular preconditioner, Cholesky factorization of
#                 the approximate Hessian. array[0..N-1,0..N-1],
#                 (if larger, only leading N elements are used).
#     IsUpper -   whether upper or lower triangle of P is given
#                 (other triangle is not referenced)
# 
# After call to this function preconditioner is changed to P  (P  is  copied
# into the internal buffer).
# 
# NOTE:  you  can  change  preconditioner  &quot;on  the  fly&quot;,  during algorithm
# iterations.
# 
# NOTE 2:  P  should  be nonsingular. Exception will be thrown otherwise. It
# also should be well conditioned, although only strict  non-singularity  is
# tested.
# 
#   -- ALGLIB --
#      Copyright 13.10.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: xalglib.minlbfgssetcholeskypreconditioner(state, p, isupper)

</div></pre>
<a name='sub_minlbfgssetcond'></a><h3 class=pageheader><code>minlbfgssetcond</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# This function sets stopping conditions for L-BFGS optimization algorithm.
# 
# INPUT PARAMETERS:
#     State   -   structure which stores algorithm state
#     EpsG    -   &gt;=0
#                 The  subroutine  finishes  its  work   if   the  condition
#                 ||G||&lt;EpsG is satisfied, where ||.|| means Euclidian norm,
#                 G - gradient.
#     EpsF    -   &gt;=0
#                 The  subroutine  finishes  its work if on k+1-th iteration
#                 the  condition  |F(k+1)-F(k)|&lt;=EpsF*max{|F(k)|,|F(k+1)|,1}
#                 is satisfied.
#     EpsX    -   &gt;=0
#                 The subroutine finishes its work if  on  k+1-th  iteration
#                 the condition |X(k+1)-X(k)| &lt;= EpsX is fulfilled.
#     MaxIts  -   maximum number of iterations. If MaxIts=0, the  number  of
#                 iterations is unlimited.
# 
# Passing EpsG=0, EpsF=0, EpsX=0 and MaxIts=0 (simultaneously) will lead to
# automatic stopping criterion selection (small EpsX).
# 
#   -- ALGLIB --
#      Copyright 02.04.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: xalglib.minlbfgssetcond(state, epsg, epsf, epsx, maxits)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_minlbfgs_d_1' class=nav>[1]</a>&nbsp;&nbsp;<a href='#example_minlbfgs_d_2' class=nav>[2]</a>&nbsp;&nbsp;</p>
<a name='sub_minlbfgssetdefaultpreconditioner'></a><h3 class=pageheader><code>minlbfgssetdefaultpreconditioner</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Modification of the preconditioner:
# default preconditioner (simple scaling) is used.
# 
# INPUT PARAMETERS:
#     State   -   structure which stores algorithm state
# 
# After call to this function preconditioner is changed to the default one.
# 
# NOTE:  you  can  change  preconditioner  &quot;on  the  fly&quot;,  during algorithm
# iterations.
# 
#   -- ALGLIB --
#      Copyright 13.10.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: xalglib.minlbfgssetdefaultpreconditioner(state)

</div></pre>
<a name='sub_minlbfgssetstpmax'></a><h3 class=pageheader><code>minlbfgssetstpmax</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# This function sets maximum step length
# 
# INPUT PARAMETERS:
#     State   -   structure which stores algorithm state
#     StpMax  -   maximum step length, &gt;=0. Set StpMax to 0.0 (default),  if
#                 you don't want to limit step length.
# 
# Use this subroutine when you optimize target function which contains exp()
# or  other  fast  growing  functions,  and optimization algorithm makes too
# large  steps  which  leads  to overflow. This function allows us to reject
# steps  that  are  too  large  (and  therefore  expose  us  to the possible
# overflow) without actually calculating function value at the x+stp*d.
# 
#   -- ALGLIB --
#      Copyright 02.04.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: xalglib.minlbfgssetstpmax(state, stpmax)

</div></pre>
<a name='sub_minlbfgssetxrep'></a><h3 class=pageheader><code>minlbfgssetxrep</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# This function turns on/off reporting.
# 
# INPUT PARAMETERS:
#     State   -   structure which stores algorithm state
#     NeedXRep-   whether iteration reports are needed or not
# 
# If NeedXRep is True, algorithm will call rep() callback function if  it is
# provided to MinLBFGSOptimize().
# 
# 
#   -- ALGLIB --
#      Copyright 02.04.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: xalglib.minlbfgssetxrep(state, needxrep)

</div></pre>
<a name='example_minlbfgs_d_1'></a><h3 class=pageheader>minlbfgs_d_1 example</h3>
<pre class=source>
import xalglib

<b>def</b> function1_grad(x, grad, param):
    <font color=darkcyan>#</font>
    <font color=darkcyan># this callback calculates f(x0,x1) = 100*(x0+3)^4 + (x1-3)^4</font>
    <font color=darkcyan># and its derivatives df/d0 and df/dx1</font>
    <font color=darkcyan>#</font>
    func = 100*(x[0]+3)**4 + (x[1]-3)**4
    grad[0] = 400*(x[0]+3)**3
    grad[1] = 4*(x[1]-3)**3
    <b>return</b> func

<font color=darkcyan>#</font>
<font color=darkcyan># This example demonstrates minimization of f(x,y) = 100*(x+3)^4+(y-3)^4</font>
<font color=darkcyan># using LBFGS method.</font>
<font color=darkcyan>#</font>
x = [0,0]
epsg = 0.0000000001
epsf = 0
epsx = 0
maxits = 0

state = xalglib.minlbfgscreate(1, x)
xalglib.minlbfgssetcond(state, epsg, epsf, epsx, maxits)
xalglib.minlbfgsoptimize_g(state, function1_grad)
x, rep = xalglib.minlbfgsresults(state)

print(rep.terminationtype) <font color=darkcyan># expected 4</font>
print(x) <font color=darkcyan># expected [-3,3]</font>


</pre><a name='example_minlbfgs_d_2'></a><h3 class=pageheader>minlbfgs_d_2 example</h3>
<pre class=source>
import xalglib

<b>def</b> function1_grad(x, grad, param):
    <font color=darkcyan>#</font>
    <font color=darkcyan># this callback calculates f(x0,x1) = 100*(x0+3)^4 + (x1-3)^4</font>
    <font color=darkcyan># and its derivatives df/d0 and df/dx1</font>
    <font color=darkcyan>#</font>
    func = 100*(x[0]+3)**4 + (x[1]-3)**4
    grad[0] = 400*(x[0]+3)**3
    grad[1] = 4*(x[1]-3)**3
    <b>return</b> func

<font color=darkcyan>#</font>
<font color=darkcyan># This example demonstrates minimization of f(x,y) = 100*(x+3)^4+(y-3)^4</font>
<font color=darkcyan># using LBFGS method.</font>
<font color=darkcyan>#</font>
<font color=darkcyan># Several advanced techniques are demonstrated:</font>
<font color=darkcyan># * upper limit on step size</font>
<font color=darkcyan># * restart from new point</font>
<font color=darkcyan>#</font>
x = [0,0]
epsg = 0.0000000001
epsf = 0
epsx = 0
stpmax = 0.1
maxits = 0

<font color=darkcyan># first run</font>
state = xalglib.minlbfgscreate(1, x)
xalglib.minlbfgssetcond(state, epsg, epsf, epsx, maxits)
xalglib.minlbfgssetstpmax(state, stpmax)
xalglib.minlbfgsoptimize_g(state, function1_grad)
x, rep = xalglib.minlbfgsresults(state)

print(x) <font color=darkcyan># expected [-3,3]</font>

<font color=darkcyan># second run - algorithm is restarted</font>
x = [10,10]
xalglib.minlbfgsrestartfrom(state, x)
xalglib.minlbfgsoptimize_g(state, function1_grad)
x, rep = xalglib.minlbfgsresults(state)

print(rep.terminationtype) <font color=darkcyan># expected 4</font>
print(x) <font color=darkcyan># expected [-3,3]</font>


</pre><a name=unit_minlm></a><h2 class=pageheader><code>minlm</code> module</h2>
<div class=pagecontent>
<h3 class=pageheader>Classes</h3>
<a href='#struct_minlmreport' class=toc>minlmreport</a><br>
<a href='#struct_minlmstate' class=toc>minlmstate</a><br>
<h3 class=pageheader>Functions</h3>
<a href='#sub_minlmcreatefgh' class=toc>minlmcreatefgh</a><br>
<a href='#sub_minlmcreatefgj' class=toc>minlmcreatefgj</a><br>
<a href='#sub_minlmcreatefj' class=toc>minlmcreatefj</a><br>
<a href='#sub_minlmcreatev' class=toc>minlmcreatev</a><br>
<a href='#sub_minlmcreatevgj' class=toc>minlmcreatevgj</a><br>
<a href='#sub_minlmcreatevj' class=toc>minlmcreatevj</a><br>
<a href='#sub_minlmoptimize' class=toc>minlmoptimize</a><br>
<a href='#sub_minlmrestartfrom' class=toc>minlmrestartfrom</a><br>
<a href='#sub_minlmresults' class=toc>minlmresults</a><br>
<a href='#sub_minlmresultsbuf' class=toc>minlmresultsbuf</a><br>
<a href='#sub_minlmsetacctype' class=toc>minlmsetacctype</a><br>
<a href='#sub_minlmsetcond' class=toc>minlmsetcond</a><br>
<a href='#sub_minlmsetstpmax' class=toc>minlmsetstpmax</a><br>
<a href='#sub_minlmsetxrep' class=toc>minlmsetxrep</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
<tr align=left valign=top><td><a href='#example_minlm_d_fgh' class=toc>minlm_d_fgh</a></td><td width=15>&nbsp;</td><td>Nonlinear Hessian-based optimization for general functions</td></tr>
<tr align=left valign=top><td><a href='#example_minlm_d_restarts' class=toc>minlm_d_restarts</a></td><td width=15>&nbsp;</td><td>Efficient restarts of LM optimizer</td></tr>
<tr align=left valign=top><td><a href='#example_minlm_d_v' class=toc>minlm_d_v</a></td><td width=15>&nbsp;</td><td>Nonlinear least squares optimization using function vector only</td></tr>
<tr align=left valign=top><td><a href='#example_minlm_d_vj' class=toc>minlm_d_vj</a></td><td width=15>&nbsp;</td><td>Nonlinear least squares optimization using function vector and Jacobian</td></tr>
</table></div>
<a name='struct_minlmreport'></a><h3 class=pageheader><code>minlmreport</code> class</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Optimization report, filled by MinLMResults() function
# 
# FIELDS:
# * TerminationType, completetion code:
#     * -9    derivative correctness check failed;
#             see Rep.WrongNum, Rep.WrongI, Rep.WrongJ for
#             more information.
#     *  1    relative function improvement is no more than
#             EpsF.
#     *  2    relative step is no more than EpsX.
#     *  4    gradient is no more than EpsG.
#     *  5    MaxIts steps was taken
#     *  7    stopping conditions are too stringent,
#             further improvement is impossible
# * IterationsCount, contains iterations count
# * NFunc, number of function calculations
# * NJac, number of Jacobi matrix calculations
# * NGrad, number of gradient calculations
# * NHess, number of Hessian calculations
# * NCholesky, number of Cholesky decomposition calculations
#

</div><div style='margin-top: 0; margin-bottom: 0;'><span style='font-weight: bold; color: green;'>class</span> minlmreport(object):
    ...

</div></pre>
<a name='struct_minlmstate'></a><h3 class=pageheader><code>minlmstate</code> class</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Levenberg-Marquardt optimizer.
# 
# This structure should be created using one of the MinLMCreate???()
# functions. You should not access its fields directly; use ALGLIB functions
# to work with it.
#

</div><div style='margin-top: 0; margin-bottom: 0;'><span style='font-weight: bold; color: green;'>class</span> minlmstate(object):
    ...

</div></pre>
<a name='sub_minlmcreatefgh'></a><h3 class=pageheader><code>minlmcreatefgh</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
#     LEVENBERG-MARQUARDT-LIKE METHOD FOR NON-LINEAR OPTIMIZATION
# 
# DESCRIPTION:
# This  function  is  used  to  find  minimum  of general form (not &quot;sum-of-
# -squares&quot;) function
#     F = F(x[0], ..., x[n-1])
# using  its  gradient  and  Hessian.  Levenberg-Marquardt modification with
# L-BFGS pre-optimization and internal pre-conditioned  L-BFGS  optimization
# after each Levenberg-Marquardt step is used.
# 
# 
# REQUIREMENTS:
# This algorithm will request following information during its operation:
# 
# * function value F at given point X
# * F and gradient G (simultaneously) at given point X
# * F, G and Hessian H (simultaneously) at given point X
# 
# There are several overloaded versions of  MinLMOptimize()  function  which
# correspond  to  different LM-like optimization algorithms provided by this
# unit. You should choose version which accepts func(),  grad()  and  hess()
# function pointers. First pointer is used to calculate F  at  given  point,
# second  one  calculates  F(x)  and  grad F(x),  third one calculates F(x),
# grad F(x), hess F(x).
# 
# You can try to initialize MinLMState structure with FGH-function and  then
# use incorrect version of MinLMOptimize() (for example, version which  does
# not provide Hessian matrix), but it will lead to  exception  being  thrown
# after first attempt to calculate Hessian.
# 
# 
# USAGE:
# 1. User initializes algorithm state with MinLMCreateFGH() call
# 2. User tunes solver parameters with MinLMSetCond(),  MinLMSetStpMax() and
#    other functions
# 3. User calls MinLMOptimize() function which  takes algorithm  state   and
#    pointers (delegates, etc.) to callback functions.
# 4. User calls MinLMResults() to get solution
# 5. Optionally, user may call MinLMRestartFrom() to solve  another  problem
#    with same N but another starting point and/or another function.
#    MinLMRestartFrom() allows to reuse already initialized structure.
# 
# 
# INPUT PARAMETERS:
#     N       -   dimension, N&gt;1
#                 * if given, only leading N elements of X are used
#                 * if not given, automatically determined from size of X
#     X       -   initial solution, array[0..N-1]
# 
# OUTPUT PARAMETERS:
#     State   -   structure which stores algorithm state
# 
# NOTES:
# 1. you may tune stopping conditions with MinLMSetCond() function
# 2. if target function contains exp() or other fast growing functions,  and
#    optimization algorithm makes too large steps which leads  to  overflow,
#    use MinLMSetStpMax() function to bound algorithm's steps.
# 
#   -- ALGLIB --
#      Copyright 30.03.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: state = xalglib.minlmcreatefgh(n, x)
SYNTAX: state = xalglib.minlmcreatefgh(x)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_minlm_d_fgh' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_minlmcreatefgj'></a><h3 class=pageheader><code>minlmcreatefgj</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
#                    LEVENBERG-MARQUARDT-LIKE METHOD FOR
#                   NON-LINEAR LEAST SQUARES OPTIMIZATION
# 
# DESCRIPTION:
# 
# This function is used to find minimum of function which is represented  as
# sum of squares:
#     F(x) = f[0]^2(x[0],...,x[n-1]) + ... + f[m-1]^2(x[0],...,x[n-1])
# using value of F(), gradient of F(), function vector f[]  and  Jacobian of
# f[].
# 
# This function is considered obsolete since ALGLIB 3.1.0 and is present for
# backward  compatibility  only.  We  recommend to use MinLMCreateVGJ, which
# provides similar, but more consistent interface.
# 
#   -- ALGLIB --
#      Copyright 30.03.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: state = xalglib.minlmcreatefgj(n, m, x)
SYNTAX: state = xalglib.minlmcreatefgj(m, x)

</div></pre>
<a name='sub_minlmcreatefj'></a><h3 class=pageheader><code>minlmcreatefj</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
#     CLASSIC LEVENBERG-MARQUARDT METHOD FOR NON-LINEAR OPTIMIZATION
# 
# DESCRIPTION:
# This function is used to find minimum of function which is represented  as
# sum of squares:
#     F(x) = f[0]^2(x[0],...,x[n-1]) + ... + f[m-1]^2(x[0],...,x[n-1])
# using  value  of  F(),  function  vector  f[] and Jacobian of f[]. Classic
# Levenberg-Marquardt method is used.
# 
# This function is considered obsolete since ALGLIB 3.1.0 and is present for
# backward  compatibility  only.  We  recommend  to use MinLMCreateVJ, which
# provides similar, but more consistent and feature-rich interface.
# 
#   -- ALGLIB --
#      Copyright 30.03.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: state = xalglib.minlmcreatefj(n, m, x)
SYNTAX: state = xalglib.minlmcreatefj(m, x)

</div></pre>
<a name='sub_minlmcreatev'></a><h3 class=pageheader><code>minlmcreatev</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
#                 IMPROVED LEVENBERG-MARQUARDT METHOD FOR
#                  NON-LINEAR LEAST SQUARES OPTIMIZATION
# 
# DESCRIPTION:
# This function is used to find minimum of function which is represented  as
# sum of squares:
#     F(x) = f[0]^2(x[0],...,x[n-1]) + ... + f[m-1]^2(x[0],...,x[n-1])
# using value of function vector f[] only. Finite differences  are  used  to
# calculate Jacobian.
# 
# 
# REQUIREMENTS:
# This algorithm will request following information during its operation:
# * function vector f[] at given point X
# 
# There are several overloaded versions of  MinLMOptimize()  function  which
# correspond  to  different LM-like optimization algorithms provided by this
# unit. You should choose version which accepts fvec() callback.
# 
# You can try to initialize MinLMState structure with VJ  function and  then
# use incorrect version  of  MinLMOptimize()  (for  example,  version  which
# works with general form function and does not accept function vector), but
# it will  lead  to  exception being thrown after first attempt to calculate
# Jacobian.
# 
# 
# USAGE:
# 1. User initializes algorithm state with MinLMCreateV() call
# 2. User tunes solver parameters with MinLMSetCond(),  MinLMSetStpMax() and
#    other functions
# 3. User calls MinLMOptimize() function which  takes algorithm  state   and
#    callback functions.
# 4. User calls MinLMResults() to get solution
# 5. Optionally, user may call MinLMRestartFrom() to solve  another  problem
#    with same N/M but another starting point and/or another function.
#    MinLMRestartFrom() allows to reuse already initialized structure.
# 
# 
# INPUT PARAMETERS:
#     N       -   dimension, N&gt;1
#                 * if given, only leading N elements of X are used
#                 * if not given, automatically determined from size of X
#     M       -   number of functions f[i]
#     X       -   initial solution, array[0..N-1]
#     DiffStep-   differentiation step, &gt;0
# 
# OUTPUT PARAMETERS:
#     State   -   structure which stores algorithm state
# 
# See also MinLMIteration, MinLMResults.
# 
# NOTES:
# 1. you may tune stopping conditions with MinLMSetCond() function
# 2. if target function contains exp() or other fast growing functions,  and
#    optimization algorithm makes too large steps which leads  to  overflow,
#    use MinLMSetStpMax() function to bound algorithm's steps.
# 
#   -- ALGLIB --
#      Copyright 30.03.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: state = xalglib.minlmcreatev(n, m, x, diffstep)
SYNTAX: state = xalglib.minlmcreatev(m, x, diffstep)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_minlm_d_v' class=nav>[1]</a>&nbsp;&nbsp;<a href='#example_minlm_d_restarts' class=nav>[2]</a>&nbsp;&nbsp;</p>
<a name='sub_minlmcreatevgj'></a><h3 class=pageheader><code>minlmcreatevgj</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
#                 IMPROVED LEVENBERG-MARQUARDT METHOD FOR
#                  NON-LINEAR LEAST SQUARES OPTIMIZATION
# 
# DESCRIPTION:
# This function is used to find minimum of function which is represented  as
# sum of squares:
#     F(x) = f[0]^2(x[0],...,x[n-1]) + ... + f[m-1]^2(x[0],...,x[n-1])
# using:
# * value of function vector f[]
# * value of Jacobian of f[]
# * gradient of merit function F(x)
# 
# This function creates optimizer which uses acceleration strategy 2.  Cheap
# gradient of merit function (which is twice the product of function  vector
# and Jacobian) is used for accelerated iterations (see User Guide for  more
# info on this subject).
# 
# REQUIREMENTS:
# This algorithm will request following information during its operation:
# 
# * function vector f[] at given point X
# * function vector f[] and Jacobian of f[] (simultaneously) at given point
# * gradient of
# 
# There are several overloaded versions of  MinLMOptimize()  function  which
# correspond  to  different LM-like optimization algorithms provided by this
# unit. You should choose version which accepts  fvec(),  jac()  and  grad()
# callbacks. First one is used to calculate f[] at given point,  second  one
# calculates f[] and Jacobian df[i]/dx[j], last one calculates  gradient  of
# merit function F(x).
# 
# You can try to initialize MinLMState structure with VJ  function and  then
# use incorrect version  of  MinLMOptimize()  (for  example,  version  which
# works  with  general  form function and does not provide Jacobian), but it
# will  lead  to  exception  being  thrown  after first attempt to calculate
# Jacobian.
# 
# 
# USAGE:
# 1. User initializes algorithm state with MinLMCreateVGJ() call
# 2. User tunes solver parameters with MinLMSetCond(),  MinLMSetStpMax() and
#    other functions
# 3. User calls MinLMOptimize() function which  takes algorithm  state   and
#    callback functions.
# 4. User calls MinLMResults() to get solution
# 5. Optionally, user may call MinLMRestartFrom() to solve  another  problem
#    with same N/M but another starting point and/or another function.
#    MinLMRestartFrom() allows to reuse already initialized structure.
# 
# 
# INPUT PARAMETERS:
#     N       -   dimension, N&gt;1
#                 * if given, only leading N elements of X are used
#                 * if not given, automatically determined from size of X
#     M       -   number of functions f[i]
#     X       -   initial solution, array[0..N-1]
# 
# OUTPUT PARAMETERS:
#     State   -   structure which stores algorithm state
# 
# NOTES:
# 1. you may tune stopping conditions with MinLMSetCond() function
# 2. if target function contains exp() or other fast growing functions,  and
#    optimization algorithm makes too large steps which leads  to  overflow,
#    use MinLMSetStpMax() function to bound algorithm's steps.
# 
#   -- ALGLIB --
#      Copyright 30.03.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: state = xalglib.minlmcreatevgj(n, m, x)
SYNTAX: state = xalglib.minlmcreatevgj(m, x)

</div></pre>
<a name='sub_minlmcreatevj'></a><h3 class=pageheader><code>minlmcreatevj</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
#                 IMPROVED LEVENBERG-MARQUARDT METHOD FOR
#                  NON-LINEAR LEAST SQUARES OPTIMIZATION
# 
# DESCRIPTION:
# This function is used to find minimum of function which is represented  as
# sum of squares:
#     F(x) = f[0]^2(x[0],...,x[n-1]) + ... + f[m-1]^2(x[0],...,x[n-1])
# using value of function vector f[] and Jacobian of f[].
# 
# 
# REQUIREMENTS:
# This algorithm will request following information during its operation:
# 
# * function vector f[] at given point X
# * function vector f[] and Jacobian of f[] (simultaneously) at given point
# 
# There are several overloaded versions of  MinLMOptimize()  function  which
# correspond  to  different LM-like optimization algorithms provided by this
# unit. You should choose version which accepts fvec()  and jac() callbacks.
# First  one  is used to calculate f[] at given point, second one calculates
# f[] and Jacobian df[i]/dx[j].
# 
# You can try to initialize MinLMState structure with VJ  function and  then
# use incorrect version  of  MinLMOptimize()  (for  example,  version  which
# works  with  general  form function and does not provide Jacobian), but it
# will  lead  to  exception  being  thrown  after first attempt to calculate
# Jacobian.
# 
# 
# USAGE:
# 1. User initializes algorithm state with MinLMCreateVJ() call
# 2. User tunes solver parameters with MinLMSetCond(),  MinLMSetStpMax() and
#    other functions
# 3. User calls MinLMOptimize() function which  takes algorithm  state   and
#    callback functions.
# 4. User calls MinLMResults() to get solution
# 5. Optionally, user may call MinLMRestartFrom() to solve  another  problem
#    with same N/M but another starting point and/or another function.
#    MinLMRestartFrom() allows to reuse already initialized structure.
# 
# 
# INPUT PARAMETERS:
#     N       -   dimension, N&gt;1
#                 * if given, only leading N elements of X are used
#                 * if not given, automatically determined from size of X
#     M       -   number of functions f[i]
#     X       -   initial solution, array[0..N-1]
# 
# OUTPUT PARAMETERS:
#     State   -   structure which stores algorithm state
# 
# NOTES:
# 1. you may tune stopping conditions with MinLMSetCond() function
# 2. if target function contains exp() or other fast growing functions,  and
#    optimization algorithm makes too large steps which leads  to  overflow,
#    use MinLMSetStpMax() function to bound algorithm's steps.
# 
#   -- ALGLIB --
#      Copyright 30.03.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: state = xalglib.minlmcreatevj(n, m, x)
SYNTAX: state = xalglib.minlmcreatevj(m, x)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_minlm_d_vj' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_minlmoptimize'></a><h3 class=pageheader><code>minlmoptimize</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# This family of functions is used to launcn iterations of nonlinear optimizer
# 
# These functions accept following parameters:
#     state   -   algorithm state
#     func    -   callback which calculates function (or merit function)
#                 value func at given point x
#     grad    -   callback which calculates function (or merit function)
#                 value func and gradient grad at given point x
#     hess    -   callback which calculates function (or merit function)
#                 value func, gradient grad and Hessian hess at given point x
#     fvec    -   callback which calculates function vector fi[]
#                 at given point x
#     jac     -   callback which calculates function vector fi[]
#                 and Jacobian jac at given point x
#     rep     -   optional callback which is called after each iteration
#                 can be NULL
#     ptr     -   optional pointer which is passed to func/grad/hess/jac/rep
#                 can be NULL
# 
# NOTES:
# 
# 1. Depending on function used to create state  structure,  this  algorithm
#    may accept Jacobian and/or Hessian and/or gradient.  According  to  the
#    said above, there ase several versions of this function,  which  accept
#    different sets of callbacks.
# 
#    This flexibility opens way to subtle errors - you may create state with
#    MinLMCreateFGH() (optimization using Hessian), but call function  which
#    does not accept Hessian. So when algorithm will request Hessian,  there
#    will be no callback to call. In this case exception will be thrown.
# 
#    Be careful to avoid such errors because there is no way to find them at
#    compile time - you can see them at runtime only.
# 
#   -- ALGLIB --
#      Copyright 10.03.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: xalglib.minlmoptimize_v(state, fvec, rep = None, param = None)
SYNTAX: xalglib.minlmoptimize_vj(state, fvec, jac, rep = None, param = None)
SYNTAX: xalglib.minlmoptimize_fgh(state, func, grad, hess, rep = None, param = None)
SYNTAX: xalglib.minlmoptimize_fj(state, func, jac, rep = None, param = None)
SYNTAX: xalglib.minlmoptimize_fgj(state, func, grad, jac, rep = None, param = None)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_minlm_d_v' class=nav>[1]</a>&nbsp;&nbsp;<a href='#example_minlm_d_vj' class=nav>[2]</a>&nbsp;&nbsp;<a href='#example_minlm_d_fgh' class=nav>[3]</a>&nbsp;&nbsp;<a href='#example_minlm_d_restarts' class=nav>[4]</a>&nbsp;&nbsp;</p>
<a name='sub_minlmrestartfrom'></a><h3 class=pageheader><code>minlmrestartfrom</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# This  subroutine  restarts  LM  algorithm from new point. All optimization
# parameters are left unchanged.
# 
# This  function  allows  to  solve multiple  optimization  problems  (which
# must have same number of dimensions) without object reallocation penalty.
# 
# INPUT PARAMETERS:
#     State   -   structure used for reverse communication previously
#                 allocated with MinLMCreateXXX call.
#     X       -   new starting point.
# 
#   -- ALGLIB --
#      Copyright 30.07.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: xalglib.minlmrestartfrom(state, x)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_minlm_d_restarts' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_minlmresults'></a><h3 class=pageheader><code>minlmresults</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Levenberg-Marquardt algorithm results
# 
# INPUT PARAMETERS:
#     State   -   algorithm state
# 
# OUTPUT PARAMETERS:
#     X       -   array[0..N-1], solution
#     Rep     -   optimization report;
#                 see comments for this structure for more info.
# 
#   -- ALGLIB --
#      Copyright 10.03.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: x, rep = xalglib.minlmresults(state)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_minlm_d_v' class=nav>[1]</a>&nbsp;&nbsp;<a href='#example_minlm_d_vj' class=nav>[2]</a>&nbsp;&nbsp;<a href='#example_minlm_d_fgh' class=nav>[3]</a>&nbsp;&nbsp;<a href='#example_minlm_d_restarts' class=nav>[4]</a>&nbsp;&nbsp;</p>
<a name='sub_minlmresultsbuf'></a><h3 class=pageheader><code>minlmresultsbuf</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Levenberg-Marquardt algorithm results
# 
# Buffered implementation of MinLMResults(), which uses pre-allocated buffer
# to store X[]. If buffer size is  too  small,  it  resizes  buffer.  It  is
# intended to be used in the inner cycles of performance critical algorithms
# where array reallocation penalty is too large to be ignored.
# 
#   -- ALGLIB --
#      Copyright 10.03.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: x, rep = xalglib.minlmresultsbuf(state, x, rep)

</div></pre>
<a name='sub_minlmsetacctype'></a><h3 class=pageheader><code>minlmsetacctype</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# This function is used to change acceleration settings
# 
# You can choose between three acceleration strategies:
# * AccType=0, no acceleration.
# * AccType=1, secant updates are used to update quadratic model after  each
#   iteration. After fixed number of iterations (or after  model  breakdown)
#   we  recalculate  quadratic  model  using  analytic  Jacobian  or  finite
#   differences. Number of secant-based iterations depends  on  optimization
#   settings: about 3 iterations - when we have analytic Jacobian, up to 2*N
#   iterations - when we use finite differences to calculate Jacobian.
# * AccType=2, after quadratic model is built and LM step is made, we use it
#   as preconditioner for several (5-10) iterations of L-BFGS algorithm.
# 
# AccType=1 is recommended when Jacobian  calculation  cost  is  prohibitive
# high (several Mx1 function vector calculations  followed  by  several  NxN
# Cholesky factorizations are faster than calculation of one M*N  Jacobian).
# It should also be used when we have no Jacobian, because finite difference
# approximation takes too much time to compute.
# 
# AccType=2 is recommended when Jacobian is cheap - much more  cheaper  than
# one  Cholesky  factorization.   We   can   reduce   number   of   Cholesky
# factorizations at the cost of increased number of  Jacobian  calculations.
# Sometimes it helps.
# 
# Table below list  optimization  protocols  (XYZ  protocol  corresponds  to
# MinLMCreateXYZ) and acceleration types they support (and use by  default).
# 
# ACCELERATION TYPES SUPPORTED BY OPTIMIZATION PROTOCOLS:
# 
# protocol    0   1   2   comment
# V           +   +
# VJ          +   +   +
# FGH         +       +
# VGJ         +   +   +   special protocol, not for widespread use
# FJ          +       +   obsolete protocol, not recommended
# FGJ         +       +   obsolete protocol, not recommended
# 
# DAFAULT VALUES:
# 
# protocol    0   1   2   comment
# V               x       without acceleration it is so slooooooooow
# VJ          x
# FGH         x
# VGJ                 x   we've implicitly turned (2) by passing gradient
# FJ          x           obsolete protocol, not recommended
# FGJ                 x   obsolete protocol, not recommended
# 
# NOTE: this  function should be called before optimization. Attempt to call
# it during algorithm iterations may result in unexpected behavior.
# 
# NOTE: attempt to call this function with unsupported protocol/acceleration
# combination will result in exception being thrown.
# 
#   -- ALGLIB --
#      Copyright 14.10.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: xalglib.minlmsetacctype(state, acctype)

</div></pre>
<a name='sub_minlmsetcond'></a><h3 class=pageheader><code>minlmsetcond</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# This function sets stopping conditions for Levenberg-Marquardt optimization
# algorithm.
# 
# INPUT PARAMETERS:
#     State   -   structure which stores algorithm state
#     EpsG    -   &gt;=0
#                 The  subroutine  finishes  its  work   if   the  condition
#                 ||G||&lt;EpsG is satisfied, where ||.|| means Euclidian norm,
#                 G - gradient.
#     EpsF    -   &gt;=0
#                 The  subroutine  finishes  its work if on k+1-th iteration
#                 the  condition  |F(k+1)-F(k)|&lt;=EpsF*max{|F(k)|,|F(k+1)|,1}
#                 is satisfied.
#     EpsX    -   &gt;=0
#                 The subroutine finishes its work if  on  k+1-th  iteration
#                 the condition |X(k+1)-X(k)| &lt;= EpsX is fulfilled.
#     MaxIts  -   maximum number of iterations. If MaxIts=0, the  number  of
#                 iterations   is    unlimited.   Only   Levenberg-Marquardt
#                 iterations  are  counted  (L-BFGS/CG  iterations  are  NOT
#                 counted because their cost is very low compared to that of
#                 LM).
# 
# Passing EpsG=0, EpsF=0, EpsX=0 and MaxIts=0 (simultaneously) will lead to
# automatic stopping criterion selection (small EpsX).
# 
#   -- ALGLIB --
#      Copyright 02.04.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: xalglib.minlmsetcond(state, epsg, epsf, epsx, maxits)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_minlm_d_v' class=nav>[1]</a>&nbsp;&nbsp;<a href='#example_minlm_d_vj' class=nav>[2]</a>&nbsp;&nbsp;<a href='#example_minlm_d_fgh' class=nav>[3]</a>&nbsp;&nbsp;<a href='#example_minlm_d_restarts' class=nav>[4]</a>&nbsp;&nbsp;</p>
<a name='sub_minlmsetstpmax'></a><h3 class=pageheader><code>minlmsetstpmax</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# This function sets maximum step length
# 
# INPUT PARAMETERS:
#     State   -   structure which stores algorithm state
#     StpMax  -   maximum step length, &gt;=0. Set StpMax to 0.0,  if you don't
#                 want to limit step length.
# 
# Use this subroutine when you optimize target function which contains exp()
# or  other  fast  growing  functions,  and optimization algorithm makes too
# large  steps  which  leads  to overflow. This function allows us to reject
# steps  that  are  too  large  (and  therefore  expose  us  to the possible
# overflow) without actually calculating function value at the x+stp*d.
# 
# NOTE: non-zero StpMax leads to moderate  performance  degradation  because
# intermediate  step  of  preconditioned L-BFGS optimization is incompatible
# with limits on step size.
# 
#   -- ALGLIB --
#      Copyright 02.04.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: xalglib.minlmsetstpmax(state, stpmax)

</div></pre>
<a name='sub_minlmsetxrep'></a><h3 class=pageheader><code>minlmsetxrep</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# This function turns on/off reporting.
# 
# INPUT PARAMETERS:
#     State   -   structure which stores algorithm state
#     NeedXRep-   whether iteration reports are needed or not
# 
# If NeedXRep is True, algorithm will call rep() callback function if  it is
# provided to MinLMOptimize(). Both Levenberg-Marquardt and internal  L-BFGS
# iterations are reported.
# 
#   -- ALGLIB --
#      Copyright 02.04.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: xalglib.minlmsetxrep(state, needxrep)

</div></pre>
<a name='example_minlm_d_fgh'></a><h3 class=pageheader>minlm_d_fgh example</h3>
<pre class=source>
import xalglib

<b>def</b> function1_func(x, param):
    <font color=darkcyan>#</font>
    <font color=darkcyan># this callback calculates f(x0,x1) = 100*(x0+3)^4 + (x1-3)^4</font>
    <font color=darkcyan>#</font>
    <b>return</b> 100*(x[0]+3)**4 + (x[1]-3)**4

<b>def</b> function1_grad(x, grad, param):
    <font color=darkcyan>#</font>
    <font color=darkcyan># this callback calculates f(x0,x1) = 100*(x0+3)^4 + (x1-3)^4</font>
    <font color=darkcyan># and its derivatives df/d0 and df/dx1</font>
    <font color=darkcyan>#</font>
    func = 100*(x[0]+3)**4 + (x[1]-3)**4
    grad[0] = 400*(x[0]+3)**3
    grad[1] = 4*(x[1]-3)**3
    <b>return</b> func

<b>def</b> function1_hess(x, grad, hess, param):
    <font color=darkcyan>#</font>
    <font color=darkcyan># this callback calculates f(x0,x1) = 100*(x0+3)^4 + (x1-3)^4</font>
    <font color=darkcyan># its derivatives df/d0 and df/dx1</font>
    <font color=darkcyan># and its Hessian.</font>
    <font color=darkcyan>#</font>
    func = 100*(x[0]+3)**4 + (x[1]-3)**4
    grad[0] = 400*(x[0]+3)**3
    grad[1] = 4*(x[1]-3)**3
    hess[0][0] = 1200*(x[0]+3)**2
    hess[0][1] = 0
    hess[1][0] = 0
    hess[1][1] = 12*(x[1]-3)**2
    <b>return</b> func

<font color=darkcyan>#</font>
<font color=darkcyan># This example demonstrates minimization of F(x0,x1) = 100*(x0+3)^4+(x1-3)^4</font>
<font color=darkcyan># using <font color=blue><b>&quot;FGH&quot;</b></font> mode of the Levenberg-Marquardt optimizer.</font>
<font color=darkcyan>#</font>
<font color=darkcyan># F is treated like a monolitic function without internal structure,</font>
<font color=darkcyan># i.e. we <b>do</b> NOT represent it as a sum of squares.</font>
<font color=darkcyan>#</font>
<font color=darkcyan># Optimization algorithm uses:</font>
<font color=darkcyan># * function value F(x0,x1)</font>
<font color=darkcyan># * gradient G={dF/dxi}</font>
<font color=darkcyan># * Hessian H={d2F/(dxi*dxj)}</font>
<font color=darkcyan>#</font>
x = [0,0]
epsg = 0.0000000001
epsf = 0
epsx = 0
maxits = 0

state = xalglib.minlmcreatefgh(x)
xalglib.minlmsetcond(state, epsg, epsf, epsx, maxits)
xalglib.minlmoptimize_fgh(state, function1_func, function1_grad, function1_hess)
x, rep = xalglib.minlmresults(state)

print(rep.terminationtype) <font color=darkcyan># expected 4</font>
print(x) <font color=darkcyan># expected [-3,+3]</font>


</pre><a name='example_minlm_d_restarts'></a><h3 class=pageheader>minlm_d_restarts example</h3>
<pre class=source>
import xalglib

<b>def</b> function1_fvec(x, fi, param):
    <font color=darkcyan>#</font>
    <font color=darkcyan># this callback calculates</font>
    <font color=darkcyan># f0(x0,x1) = 100*(x0+3)^4,</font>
    <font color=darkcyan># f1(x0,x1) = (x1-3)^4</font>
    <font color=darkcyan>#</font>
    fi[0] = 10*(x[0]+3)**2
    fi[1] = (x[1]-3)**2
    <b>return</b>

<b>def</b> function2_fvec(x, fi, param):
    <font color=darkcyan>#</font>
    <font color=darkcyan># this callback calculates</font>
    <font color=darkcyan># f0(x0,x1) = x0^2+1</font>
    <font color=darkcyan># f1(x0,x1) = x1-1</font>
    <font color=darkcyan>#</font>
    fi[0] = x[0]*x[0]+1
    fi[1] = x[1]-1
    <b>return</b>

<font color=darkcyan>#</font>
<font color=darkcyan># This example demonstrates minimization of F(x0,x1) = f0^2+f1^2, where </font>
<font color=darkcyan>#</font>
<font color=darkcyan>#     f0(x0,x1) = 10*(x0+3)^2</font>
<font color=darkcyan>#     f1(x0,x1) = (x1-3)^2</font>
<font color=darkcyan>#</font>
<font color=darkcyan># using several starting points and efficient restarts.</font>
<font color=darkcyan>#</font>
epsg = 0.0000000001
epsf = 0
epsx = 0
maxits = 0

<font color=darkcyan>#</font>
<font color=darkcyan># create optimizer using minlmcreatev()</font>
<font color=darkcyan>#</font>
x = [10,10]
state = xalglib.minlmcreatev(2, x, 0.0001)
xalglib.minlmsetcond(state, epsg, epsf, epsx, maxits)
xalglib.minlmoptimize_v(state, function1_fvec)
x, rep = xalglib.minlmresults(state)
print(x) <font color=darkcyan># expected [-3,+3]</font>

<font color=darkcyan>#</font>
<font color=darkcyan># restart optimizer using minlmrestartfrom()</font>
<font color=darkcyan>#</font>
<font color=darkcyan># we can use different starting point, different function,</font>
<font color=darkcyan># different stopping conditions, but problem size</font>
<font color=darkcyan># must remain unchanged.</font>
<font color=darkcyan>#</font>
x = [4,4]
xalglib.minlmrestartfrom(state, x)
xalglib.minlmoptimize_v(state, function2_fvec)
x, rep = xalglib.minlmresults(state)
print(x) <font color=darkcyan># expected [0,1]</font>


</pre><a name='example_minlm_d_v'></a><h3 class=pageheader>minlm_d_v example</h3>
<pre class=source>
import xalglib

<b>def</b> function1_fvec(x, fi, param):
    <font color=darkcyan>#</font>
    <font color=darkcyan># this callback calculates</font>
    <font color=darkcyan># f0(x0,x1) = 100*(x0+3)^4,</font>
    <font color=darkcyan># f1(x0,x1) = (x1-3)^4</font>
    <font color=darkcyan>#</font>
    fi[0] = 10*(x[0]+3)**2
    fi[1] = (x[1]-3)**2
    <b>return</b>

<font color=darkcyan>#</font>
<font color=darkcyan># This example demonstrates minimization of F(x0,x1) = f0^2+f1^2, where </font>
<font color=darkcyan>#</font>
<font color=darkcyan>#     f0(x0,x1) = 10*(x0+3)^2</font>
<font color=darkcyan>#     f1(x0,x1) = (x1-3)^2</font>
<font color=darkcyan>#</font>
<font color=darkcyan># using <font color=blue><b>&quot;V&quot;</b></font> mode of the Levenberg-Marquardt optimizer.</font>
<font color=darkcyan>#</font>
<font color=darkcyan># Optimization algorithm uses:</font>
<font color=darkcyan># * function vector f[] = {f1,f2}</font>
<font color=darkcyan>#</font>
<font color=darkcyan># No other information (Jacobian, gradient, etc.) is needed.</font>
<font color=darkcyan>#</font>
x = [0,0]
epsg = 0.0000000001
epsf = 0
epsx = 0
maxits = 0

state = xalglib.minlmcreatev(2, x, 0.0001)
xalglib.minlmsetcond(state, epsg, epsf, epsx, maxits)
xalglib.minlmoptimize_v(state, function1_fvec)
x, rep = xalglib.minlmresults(state)

print(rep.terminationtype) <font color=darkcyan># expected 4</font>
print(x) <font color=darkcyan># expected [-3,+3]</font>


</pre><a name='example_minlm_d_vj'></a><h3 class=pageheader>minlm_d_vj example</h3>
<pre class=source>
import xalglib

<b>def</b> function1_fvec(x, fi, param):
    <font color=darkcyan>#</font>
    <font color=darkcyan># this callback calculates</font>
    <font color=darkcyan># f0(x0,x1) = 100*(x0+3)^4,</font>
    <font color=darkcyan># f1(x0,x1) = (x1-3)^4</font>
    <font color=darkcyan>#</font>
    fi[0] = 10*(x[0]+3)**2
    fi[1] = (x[1]-3)**2
    <b>return</b>

<b>def</b> function1_jac(x, fi, jac, param):
    <font color=darkcyan>#</font>
    <font color=darkcyan># this callback calculates</font>
    <font color=darkcyan># f0(x0,x1) = 100*(x0+3)^4,</font>
    <font color=darkcyan># f1(x0,x1) = (x1-3)^4</font>
    <font color=darkcyan># and Jacobian matrix J = [dfi/dxj]</font>
    <font color=darkcyan>#</font>
    fi[0] = 10*(x[0]+3)**2
    fi[1] = (x[1]-3)**2
    jac[0][0] = 20*(x[0]+3)
    jac[0][1] = 0
    jac[1][0] = 0
    jac[1][1] = 2*(x[1]-3)
    <b>return</b>

<font color=darkcyan>#</font>
<font color=darkcyan># This example demonstrates minimization of F(x0,x1) = f0^2+f1^2, where </font>
<font color=darkcyan>#</font>
<font color=darkcyan>#     f0(x0,x1) = 10*(x0+3)^2</font>
<font color=darkcyan>#     f1(x0,x1) = (x1-3)^2</font>
<font color=darkcyan>#</font>
<font color=darkcyan># using <font color=blue><b>&quot;VJ&quot;</b></font> mode of the Levenberg-Marquardt optimizer.</font>
<font color=darkcyan>#</font>
<font color=darkcyan># Optimization algorithm uses:</font>
<font color=darkcyan># * function vector f[] = {f1,f2}</font>
<font color=darkcyan># * Jacobian matrix J = {dfi/dxj}.</font>
<font color=darkcyan>#</font>
x = [0,0]
epsg = 0.0000000001
epsf = 0
epsx = 0
maxits = 0

state = xalglib.minlmcreatevj(2, x)
xalglib.minlmsetcond(state, epsg, epsf, epsx, maxits)
xalglib.minlmoptimize_vj(state, function1_fvec, function1_jac)
x, rep = xalglib.minlmresults(state)

print(rep.terminationtype) <font color=darkcyan># expected 4</font>
print(x) <font color=darkcyan># expected [-3,+3]</font>


</pre><a name=unit_mlpbase></a><h2 class=pageheader><code>mlpbase</code> module</h2>
<div class=pagecontent>
<h3 class=pageheader>Classes</h3>
<a href='#struct_multilayerperceptron' class=toc>multilayerperceptron</a><br>
<h3 class=pageheader>Functions</h3>
<a href='#sub_mlpavgce' class=toc>mlpavgce</a><br>
<a href='#sub_mlpavgerror' class=toc>mlpavgerror</a><br>
<a href='#sub_mlpavgrelerror' class=toc>mlpavgrelerror</a><br>
<a href='#sub_mlpclserror' class=toc>mlpclserror</a><br>
<a href='#sub_mlpcreate0' class=toc>mlpcreate0</a><br>
<a href='#sub_mlpcreate1' class=toc>mlpcreate1</a><br>
<a href='#sub_mlpcreate2' class=toc>mlpcreate2</a><br>
<a href='#sub_mlpcreateb0' class=toc>mlpcreateb0</a><br>
<a href='#sub_mlpcreateb1' class=toc>mlpcreateb1</a><br>
<a href='#sub_mlpcreateb2' class=toc>mlpcreateb2</a><br>
<a href='#sub_mlpcreatec0' class=toc>mlpcreatec0</a><br>
<a href='#sub_mlpcreatec1' class=toc>mlpcreatec1</a><br>
<a href='#sub_mlpcreatec2' class=toc>mlpcreatec2</a><br>
<a href='#sub_mlpcreater0' class=toc>mlpcreater0</a><br>
<a href='#sub_mlpcreater1' class=toc>mlpcreater1</a><br>
<a href='#sub_mlpcreater2' class=toc>mlpcreater2</a><br>
<a href='#sub_mlperror' class=toc>mlperror</a><br>
<a href='#sub_mlperrorn' class=toc>mlperrorn</a><br>
<a href='#sub_mlpgrad' class=toc>mlpgrad</a><br>
<a href='#sub_mlpgradbatch' class=toc>mlpgradbatch</a><br>
<a href='#sub_mlpgradn' class=toc>mlpgradn</a><br>
<a href='#sub_mlpgradnbatch' class=toc>mlpgradnbatch</a><br>
<a href='#sub_mlphessianbatch' class=toc>mlphessianbatch</a><br>
<a href='#sub_mlphessiannbatch' class=toc>mlphessiannbatch</a><br>
<a href='#sub_mlpissoftmax' class=toc>mlpissoftmax</a><br>
<a href='#sub_mlpprocess' class=toc>mlpprocess</a><br>
<a href='#sub_mlpprocessi' class=toc>mlpprocessi</a><br>
<a href='#sub_mlpproperties' class=toc>mlpproperties</a><br>
<a href='#sub_mlprandomize' class=toc>mlprandomize</a><br>
<a href='#sub_mlprandomizefull' class=toc>mlprandomizefull</a><br>
<a href='#sub_mlprelclserror' class=toc>mlprelclserror</a><br>
<a href='#sub_mlprmserror' class=toc>mlprmserror</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='struct_multilayerperceptron'></a><h3 class=pageheader><code>multilayerperceptron</code> class</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# 
#

</div><div style='margin-top: 0; margin-bottom: 0;'><span style='font-weight: bold; color: green;'>class</span> multilayerperceptron(object):
    ...

</div></pre>
<a name='sub_mlpavgce'></a><h3 class=pageheader><code>mlpavgce</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Average cross-entropy (in bits per element) on the test set
# 
# INPUT PARAMETERS:
#     Network -   neural network
#     XY      -   test set
#     NPoints -   test set size
# 
# RESULT:
#     CrossEntropy/(NPoints*LN(2)).
#     Zero if network solves regression task.
# 
#   -- ALGLIB --
#      Copyright 08.01.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.mlpavgce(network, xy, npoints)

</div></pre>
<a name='sub_mlpavgerror'></a><h3 class=pageheader><code>mlpavgerror</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Average error on the test set
# 
# INPUT PARAMETERS:
#     Network -   neural network
#     XY      -   test set
#     NPoints -   test set size
# 
# RESULT:
#     Its meaning for regression task is obvious. As for
#     classification task, it means average error when estimating posterior
#     probabilities.
# 
#   -- ALGLIB --
#      Copyright 11.03.2008 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.mlpavgerror(network, xy, npoints)

</div></pre>
<a name='sub_mlpavgrelerror'></a><h3 class=pageheader><code>mlpavgrelerror</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Average relative error on the test set
# 
# INPUT PARAMETERS:
#     Network -   neural network
#     XY      -   test set
#     NPoints -   test set size
# 
# RESULT:
#     Its meaning for regression task is obvious. As for
#     classification task, it means average relative error when estimating
#     posterior probability of belonging to the correct class.
# 
#   -- ALGLIB --
#      Copyright 11.03.2008 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.mlpavgrelerror(network, xy, npoints)

</div></pre>
<a name='sub_mlpclserror'></a><h3 class=pageheader><code>mlpclserror</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Classification error
# 
#   -- ALGLIB --
#      Copyright 04.11.2007 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.mlpclserror(network, xy, ssize)

</div></pre>
<a name='sub_mlpcreate0'></a><h3 class=pageheader><code>mlpcreate0</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Creates  neural  network  with  NIn  inputs,  NOut outputs, without hidden
# layers, with linear output layer. Network weights are  filled  with  small
# random values.
# 
#   -- ALGLIB --
#      Copyright 04.11.2007 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: network = xalglib.mlpcreate0(nin, nout)

</div></pre>
<a name='sub_mlpcreate1'></a><h3 class=pageheader><code>mlpcreate1</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Same  as  MLPCreate0,  but  with  one  hidden  layer  (NHid  neurons) with
# non-linear activation function. Output layer is linear.
# 
#   -- ALGLIB --
#      Copyright 04.11.2007 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: network = xalglib.mlpcreate1(nin, nhid, nout)

</div></pre>
<a name='sub_mlpcreate2'></a><h3 class=pageheader><code>mlpcreate2</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Same as MLPCreate0, but with two hidden layers (NHid1 and  NHid2  neurons)
# with non-linear activation function. Output layer is linear.
#  $ALL
# 
#   -- ALGLIB --
#      Copyright 04.11.2007 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: network = xalglib.mlpcreate2(nin, nhid1, nhid2, nout)

</div></pre>
<a name='sub_mlpcreateb0'></a><h3 class=pageheader><code>mlpcreateb0</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Creates  neural  network  with  NIn  inputs,  NOut outputs, without hidden
# layers with non-linear output layer. Network weights are filled with small
# random values.
# 
# Activation function of the output layer takes values:
# 
#     (B, +INF), if D&gt;=0
# 
# or
# 
#     (-INF, B), if D&lt;0.
# 
# 
#   -- ALGLIB --
#      Copyright 30.03.2008 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: network = xalglib.mlpcreateb0(nin, nout, b, d)

</div></pre>
<a name='sub_mlpcreateb1'></a><h3 class=pageheader><code>mlpcreateb1</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Same as MLPCreateB0 but with non-linear hidden layer.
# 
#   -- ALGLIB --
#      Copyright 30.03.2008 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: network = xalglib.mlpcreateb1(nin, nhid, nout, b, d)

</div></pre>
<a name='sub_mlpcreateb2'></a><h3 class=pageheader><code>mlpcreateb2</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Same as MLPCreateB0 but with two non-linear hidden layers.
# 
#   -- ALGLIB --
#      Copyright 30.03.2008 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: network = xalglib.mlpcreateb2(nin, nhid1, nhid2, nout, b, d)

</div></pre>
<a name='sub_mlpcreatec0'></a><h3 class=pageheader><code>mlpcreatec0</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Creates classifier network with NIn  inputs  and  NOut  possible  classes.
# Network contains no hidden layers and linear output  layer  with  SOFTMAX-
# normalization  (so  outputs  sums  up  to  1.0  and  converge to posterior
# probabilities).
# 
#   -- ALGLIB --
#      Copyright 04.11.2007 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: network = xalglib.mlpcreatec0(nin, nout)

</div></pre>
<a name='sub_mlpcreatec1'></a><h3 class=pageheader><code>mlpcreatec1</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Same as MLPCreateC0, but with one non-linear hidden layer.
# 
#   -- ALGLIB --
#      Copyright 04.11.2007 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: network = xalglib.mlpcreatec1(nin, nhid, nout)

</div></pre>
<a name='sub_mlpcreatec2'></a><h3 class=pageheader><code>mlpcreatec2</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Same as MLPCreateC0, but with two non-linear hidden layers.
# 
#   -- ALGLIB --
#      Copyright 04.11.2007 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: network = xalglib.mlpcreatec2(nin, nhid1, nhid2, nout)

</div></pre>
<a name='sub_mlpcreater0'></a><h3 class=pageheader><code>mlpcreater0</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Creates  neural  network  with  NIn  inputs,  NOut outputs, without hidden
# layers with non-linear output layer. Network weights are filled with small
# random values. Activation function of the output layer takes values [A,B].
# 
#   -- ALGLIB --
#      Copyright 30.03.2008 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: network = xalglib.mlpcreater0(nin, nout, a, b)

</div></pre>
<a name='sub_mlpcreater1'></a><h3 class=pageheader><code>mlpcreater1</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Same as MLPCreateR0, but with non-linear hidden layer.
# 
#   -- ALGLIB --
#      Copyright 30.03.2008 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: network = xalglib.mlpcreater1(nin, nhid, nout, a, b)

</div></pre>
<a name='sub_mlpcreater2'></a><h3 class=pageheader><code>mlpcreater2</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Same as MLPCreateR0, but with two non-linear hidden layers.
# 
#   -- ALGLIB --
#      Copyright 30.03.2008 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: network = xalglib.mlpcreater2(nin, nhid1, nhid2, nout, a, b)

</div></pre>
<a name='sub_mlperror'></a><h3 class=pageheader><code>mlperror</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Error function for neural network, internal subroutine.
# 
#   -- ALGLIB --
#      Copyright 04.11.2007 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.mlperror(network, xy, ssize)

</div></pre>
<a name='sub_mlperrorn'></a><h3 class=pageheader><code>mlperrorn</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Natural error function for neural network, internal subroutine.
# 
#   -- ALGLIB --
#      Copyright 04.11.2007 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.mlperrorn(network, xy, ssize)

</div></pre>
<a name='sub_mlpgrad'></a><h3 class=pageheader><code>mlpgrad</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Gradient calculation
# 
# INPUT PARAMETERS:
#     Network -   network initialized with one of the network creation funcs
#     X       -   input vector, length of array must be at least NIn
#     DesiredY-   desired outputs, length of array must be at least NOut
#     Grad    -   possibly preallocated array. If size of array is smaller
#                 than WCount, it will be reallocated. It is recommended to
#                 reuse previously allocated array to reduce allocation
#                 overhead.
# 
# OUTPUT PARAMETERS:
#     E       -   error function, SUM(sqr(y[i]-desiredy[i])/2,i)
#     Grad    -   gradient of E with respect to weights of network, array[WCount]
# 
#   -- ALGLIB --
#      Copyright 04.11.2007 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: e, grad = xalglib.mlpgrad(network, x, desiredy, grad)

</div></pre>
<a name='sub_mlpgradbatch'></a><h3 class=pageheader><code>mlpgradbatch</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Batch gradient calculation for a set of inputs/outputs
# 
# INPUT PARAMETERS:
#     Network -   network initialized with one of the network creation funcs
#     XY      -   set of inputs/outputs; one sample = one row;
#                 first NIn columns contain inputs,
#                 next NOut columns - desired outputs.
#     SSize   -   number of elements in XY
#     Grad    -   possibly preallocated array. If size of array is smaller
#                 than WCount, it will be reallocated. It is recommended to
#                 reuse previously allocated array to reduce allocation
#                 overhead.
# 
# OUTPUT PARAMETERS:
#     E       -   error function, SUM(sqr(y[i]-desiredy[i])/2,i)
#     Grad    -   gradient of E with respect to weights of network, array[WCount]
# 
#   -- ALGLIB --
#      Copyright 04.11.2007 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: e, grad = xalglib.mlpgradbatch(network, xy, ssize, grad)

</div></pre>
<a name='sub_mlpgradn'></a><h3 class=pageheader><code>mlpgradn</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Gradient calculation (natural error function is used)
# 
# INPUT PARAMETERS:
#     Network -   network initialized with one of the network creation funcs
#     X       -   input vector, length of array must be at least NIn
#     DesiredY-   desired outputs, length of array must be at least NOut
#     Grad    -   possibly preallocated array. If size of array is smaller
#                 than WCount, it will be reallocated. It is recommended to
#                 reuse previously allocated array to reduce allocation
#                 overhead.
# 
# OUTPUT PARAMETERS:
#     E       -   error function, sum-of-squares for regression networks,
#                 cross-entropy for classification networks.
#     Grad    -   gradient of E with respect to weights of network, array[WCount]
# 
#   -- ALGLIB --
#      Copyright 04.11.2007 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: e, grad = xalglib.mlpgradn(network, x, desiredy, grad)

</div></pre>
<a name='sub_mlpgradnbatch'></a><h3 class=pageheader><code>mlpgradnbatch</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Batch gradient calculation for a set of inputs/outputs
# (natural error function is used)
# 
# INPUT PARAMETERS:
#     Network -   network initialized with one of the network creation funcs
#     XY      -   set of inputs/outputs; one sample = one row;
#                 first NIn columns contain inputs,
#                 next NOut columns - desired outputs.
#     SSize   -   number of elements in XY
#     Grad    -   possibly preallocated array. If size of array is smaller
#                 than WCount, it will be reallocated. It is recommended to
#                 reuse previously allocated array to reduce allocation
#                 overhead.
# 
# OUTPUT PARAMETERS:
#     E       -   error function, sum-of-squares for regression networks,
#                 cross-entropy for classification networks.
#     Grad    -   gradient of E with respect to weights of network, array[WCount]
# 
#   -- ALGLIB --
#      Copyright 04.11.2007 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: e, grad = xalglib.mlpgradnbatch(network, xy, ssize, grad)

</div></pre>
<a name='sub_mlphessianbatch'></a><h3 class=pageheader><code>mlphessianbatch</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Batch Hessian calculation using R-algorithm.
# Internal subroutine.
# 
#   -- ALGLIB --
#      Copyright 26.01.2008 by Bochkanov Sergey.
# 
#      Hessian calculation based on R-algorithm described in
#      &quot;Fast Exact Multiplication by the Hessian&quot;,
#      B. A. Pearlmutter,
#      Neural Computation, 1994.
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: e, grad, h = xalglib.mlphessianbatch(network, xy, ssize, grad, h)

</div></pre>
<a name='sub_mlphessiannbatch'></a><h3 class=pageheader><code>mlphessiannbatch</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Batch Hessian calculation (natural error function) using R-algorithm.
# Internal subroutine.
# 
#   -- ALGLIB --
#      Copyright 26.01.2008 by Bochkanov Sergey.
# 
#      Hessian calculation based on R-algorithm described in
#      &quot;Fast Exact Multiplication by the Hessian&quot;,
#      B. A. Pearlmutter,
#      Neural Computation, 1994.
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: e, grad, h = xalglib.mlphessiannbatch(network, xy, ssize, grad, h)

</div></pre>
<a name='sub_mlpissoftmax'></a><h3 class=pageheader><code>mlpissoftmax</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Tells whether network is SOFTMAX-normalized (i.e. classifier) or not.
# 
#   -- ALGLIB --
#      Copyright 04.11.2007 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.mlpissoftmax(network)

</div></pre>
<a name='sub_mlpprocess'></a><h3 class=pageheader><code>mlpprocess</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Procesing
# 
# INPUT PARAMETERS:
#     Network -   neural network
#     X       -   input vector,  array[0..NIn-1].
# 
# OUTPUT PARAMETERS:
#     Y       -   result. Regression estimate when solving regression  task,
#                 vector of posterior probabilities for classification task.
# 
# See also MLPProcessI
# 
#   -- ALGLIB --
#      Copyright 04.11.2007 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: y = xalglib.mlpprocess(network, x, y)

</div></pre>
<a name='sub_mlpprocessi'></a><h3 class=pageheader><code>mlpprocessi</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# 'interactive'  variant  of  MLPProcess  for  languages  like  Python which
# support constructs like &quot;Y = MLPProcess(NN,X)&quot; and interactive mode of the
# interpreter
# 
# This function allocates new array on each call,  so  it  is  significantly
# slower than its 'non-interactive' counterpart, but it is  more  convenient
# when you call it from command line.
# 
#   -- ALGLIB --
#      Copyright 21.09.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: y = xalglib.mlpprocessi(network, x)

</div></pre>
<a name='sub_mlpproperties'></a><h3 class=pageheader><code>mlpproperties</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Returns information about initialized network: number of inputs, outputs,
# weights.
# 
#   -- ALGLIB --
#      Copyright 04.11.2007 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: nin, nout, wcount = xalglib.mlpproperties(network)

</div></pre>
<a name='sub_mlprandomize'></a><h3 class=pageheader><code>mlprandomize</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Randomization of neural network weights
# 
#   -- ALGLIB --
#      Copyright 06.11.2007 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: xalglib.mlprandomize(network)

</div></pre>
<a name='sub_mlprandomizefull'></a><h3 class=pageheader><code>mlprandomizefull</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Randomization of neural network weights and standartisator
# 
#   -- ALGLIB --
#      Copyright 10.03.2008 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: xalglib.mlprandomizefull(network)

</div></pre>
<a name='sub_mlprelclserror'></a><h3 class=pageheader><code>mlprelclserror</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Relative classification error on the test set
# 
# INPUT PARAMETERS:
#     Network -   network
#     XY      -   test set
#     NPoints -   test set size
# 
# RESULT:
#     percent of incorrectly classified cases. Works both for
#     classifier networks and general purpose networks used as
#     classifiers.
# 
#   -- ALGLIB --
#      Copyright 25.12.2008 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.mlprelclserror(network, xy, npoints)

</div></pre>
<a name='sub_mlprmserror'></a><h3 class=pageheader><code>mlprmserror</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# RMS error on the test set
# 
# INPUT PARAMETERS:
#     Network -   neural network
#     XY      -   test set
#     NPoints -   test set size
# 
# RESULT:
#     root mean square error.
#     Its meaning for regression task is obvious. As for
#     classification task, RMS error means error when estimating posterior
#     probabilities.
# 
#   -- ALGLIB --
#      Copyright 04.11.2007 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.mlprmserror(network, xy, npoints)

</div></pre>
<a name=unit_mlpe></a><h2 class=pageheader><code>mlpe</code> module</h2>
<div class=pagecontent>
<h3 class=pageheader>Classes</h3>
<a href='#struct_mlpensemble' class=toc>mlpensemble</a><br>
<h3 class=pageheader>Functions</h3>
<a href='#sub_mlpeavgce' class=toc>mlpeavgce</a><br>
<a href='#sub_mlpeavgerror' class=toc>mlpeavgerror</a><br>
<a href='#sub_mlpeavgrelerror' class=toc>mlpeavgrelerror</a><br>
<a href='#sub_mlpebagginglbfgs' class=toc>mlpebagginglbfgs</a><br>
<a href='#sub_mlpebagginglm' class=toc>mlpebagginglm</a><br>
<a href='#sub_mlpecreate0' class=toc>mlpecreate0</a><br>
<a href='#sub_mlpecreate1' class=toc>mlpecreate1</a><br>
<a href='#sub_mlpecreate2' class=toc>mlpecreate2</a><br>
<a href='#sub_mlpecreateb0' class=toc>mlpecreateb0</a><br>
<a href='#sub_mlpecreateb1' class=toc>mlpecreateb1</a><br>
<a href='#sub_mlpecreateb2' class=toc>mlpecreateb2</a><br>
<a href='#sub_mlpecreatec0' class=toc>mlpecreatec0</a><br>
<a href='#sub_mlpecreatec1' class=toc>mlpecreatec1</a><br>
<a href='#sub_mlpecreatec2' class=toc>mlpecreatec2</a><br>
<a href='#sub_mlpecreatefromnetwork' class=toc>mlpecreatefromnetwork</a><br>
<a href='#sub_mlpecreater0' class=toc>mlpecreater0</a><br>
<a href='#sub_mlpecreater1' class=toc>mlpecreater1</a><br>
<a href='#sub_mlpecreater2' class=toc>mlpecreater2</a><br>
<a href='#sub_mlpeissoftmax' class=toc>mlpeissoftmax</a><br>
<a href='#sub_mlpeprocess' class=toc>mlpeprocess</a><br>
<a href='#sub_mlpeprocessi' class=toc>mlpeprocessi</a><br>
<a href='#sub_mlpeproperties' class=toc>mlpeproperties</a><br>
<a href='#sub_mlperandomize' class=toc>mlperandomize</a><br>
<a href='#sub_mlperelclserror' class=toc>mlperelclserror</a><br>
<a href='#sub_mlpermserror' class=toc>mlpermserror</a><br>
<a href='#sub_mlpetraines' class=toc>mlpetraines</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='struct_mlpensemble'></a><h3 class=pageheader><code>mlpensemble</code> class</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Neural networks ensemble
#

</div><div style='margin-top: 0; margin-bottom: 0;'><span style='font-weight: bold; color: green;'>class</span> mlpensemble(object):
    ...

</div></pre>
<a name='sub_mlpeavgce'></a><h3 class=pageheader><code>mlpeavgce</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Average cross-entropy (in bits per element) on the test set
# 
# INPUT PARAMETERS:
#     Ensemble-   ensemble
#     XY      -   test set
#     NPoints -   test set size
# 
# RESULT:
#     CrossEntropy/(NPoints*LN(2)).
#     Zero if ensemble solves regression task.
# 
#   -- ALGLIB --
#      Copyright 17.02.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.mlpeavgce(ensemble, xy, npoints)

</div></pre>
<a name='sub_mlpeavgerror'></a><h3 class=pageheader><code>mlpeavgerror</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Average error on the test set
# 
# INPUT PARAMETERS:
#     Ensemble-   ensemble
#     XY      -   test set
#     NPoints -   test set size
# 
# RESULT:
#     Its meaning for regression task is obvious. As for classification task
# it means average error when estimating posterior probabilities.
# 
#   -- ALGLIB --
#      Copyright 17.02.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.mlpeavgerror(ensemble, xy, npoints)

</div></pre>
<a name='sub_mlpeavgrelerror'></a><h3 class=pageheader><code>mlpeavgrelerror</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Average relative error on the test set
# 
# INPUT PARAMETERS:
#     Ensemble-   ensemble
#     XY      -   test set
#     NPoints -   test set size
# 
# RESULT:
#     Its meaning for regression task is obvious. As for classification task
# it means average relative error when estimating posterior probabilities.
# 
#   -- ALGLIB --
#      Copyright 17.02.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.mlpeavgrelerror(ensemble, xy, npoints)

</div></pre>
<a name='sub_mlpebagginglbfgs'></a><h3 class=pageheader><code>mlpebagginglbfgs</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Training neural networks ensemble using  bootstrap  aggregating (bagging).
# L-BFGS algorithm is used as base training method.
# 
# INPUT PARAMETERS:
#     Ensemble    -   model with initialized geometry
#     XY          -   training set
#     NPoints     -   training set size
#     Decay       -   weight decay coefficient, &gt;=0.001
#     Restarts    -   restarts, &gt;0.
#     WStep       -   stopping criterion, same as in MLPTrainLBFGS
#     MaxIts      -   stopping criterion, same as in MLPTrainLBFGS
# 
# OUTPUT PARAMETERS:
#     Ensemble    -   trained model
#     Info        -   return code:
#                     * -8, if both WStep=0 and MaxIts=0
#                     * -2, if there is a point with class number
#                           outside of [0..NClasses-1].
#                     * -1, if incorrect parameters was passed
#                           (NPoints&lt;0, Restarts&lt;1).
#                     *  2, if task has been solved.
#     Rep         -   training report.
#     OOBErrors   -   out-of-bag generalization error estimate
# 
#   -- ALGLIB --
#      Copyright 17.02.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: info, rep, ooberrors = xalglib.mlpebagginglbfgs(ensemble, xy, npoints, decay, restarts, wstep, maxits)

</div></pre>
<a name='sub_mlpebagginglm'></a><h3 class=pageheader><code>mlpebagginglm</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Training neural networks ensemble using  bootstrap  aggregating (bagging).
# Modified Levenberg-Marquardt algorithm is used as base training method.
# 
# INPUT PARAMETERS:
#     Ensemble    -   model with initialized geometry
#     XY          -   training set
#     NPoints     -   training set size
#     Decay       -   weight decay coefficient, &gt;=0.001
#     Restarts    -   restarts, &gt;0.
# 
# OUTPUT PARAMETERS:
#     Ensemble    -   trained model
#     Info        -   return code:
#                     * -2, if there is a point with class number
#                           outside of [0..NClasses-1].
#                     * -1, if incorrect parameters was passed
#                           (NPoints&lt;0, Restarts&lt;1).
#                     *  2, if task has been solved.
#     Rep         -   training report.
#     OOBErrors   -   out-of-bag generalization error estimate
# 
#   -- ALGLIB --
#      Copyright 17.02.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: info, rep, ooberrors = xalglib.mlpebagginglm(ensemble, xy, npoints, decay, restarts)

</div></pre>
<a name='sub_mlpecreate0'></a><h3 class=pageheader><code>mlpecreate0</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Like MLPCreate0, but for ensembles.
# 
#   -- ALGLIB --
#      Copyright 18.02.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: ensemble = xalglib.mlpecreate0(nin, nout, ensemblesize)

</div></pre>
<a name='sub_mlpecreate1'></a><h3 class=pageheader><code>mlpecreate1</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Like MLPCreate1, but for ensembles.
# 
#   -- ALGLIB --
#      Copyright 18.02.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: ensemble = xalglib.mlpecreate1(nin, nhid, nout, ensemblesize)

</div></pre>
<a name='sub_mlpecreate2'></a><h3 class=pageheader><code>mlpecreate2</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Like MLPCreate2, but for ensembles.
# 
#   -- ALGLIB --
#      Copyright 18.02.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: ensemble = xalglib.mlpecreate2(nin, nhid1, nhid2, nout, ensemblesize)

</div></pre>
<a name='sub_mlpecreateb0'></a><h3 class=pageheader><code>mlpecreateb0</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Like MLPCreateB0, but for ensembles.
# 
#   -- ALGLIB --
#      Copyright 18.02.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: ensemble = xalglib.mlpecreateb0(nin, nout, b, d, ensemblesize)

</div></pre>
<a name='sub_mlpecreateb1'></a><h3 class=pageheader><code>mlpecreateb1</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Like MLPCreateB1, but for ensembles.
# 
#   -- ALGLIB --
#      Copyright 18.02.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: ensemble = xalglib.mlpecreateb1(nin, nhid, nout, b, d, ensemblesize)

</div></pre>
<a name='sub_mlpecreateb2'></a><h3 class=pageheader><code>mlpecreateb2</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Like MLPCreateB2, but for ensembles.
# 
#   -- ALGLIB --
#      Copyright 18.02.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: ensemble = xalglib.mlpecreateb2(nin, nhid1, nhid2, nout, b, d, ensemblesize)

</div></pre>
<a name='sub_mlpecreatec0'></a><h3 class=pageheader><code>mlpecreatec0</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Like MLPCreateC0, but for ensembles.
# 
#   -- ALGLIB --
#      Copyright 18.02.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: ensemble = xalglib.mlpecreatec0(nin, nout, ensemblesize)

</div></pre>
<a name='sub_mlpecreatec1'></a><h3 class=pageheader><code>mlpecreatec1</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Like MLPCreateC1, but for ensembles.
# 
#   -- ALGLIB --
#      Copyright 18.02.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: ensemble = xalglib.mlpecreatec1(nin, nhid, nout, ensemblesize)

</div></pre>
<a name='sub_mlpecreatec2'></a><h3 class=pageheader><code>mlpecreatec2</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Like MLPCreateC2, but for ensembles.
# 
#   -- ALGLIB --
#      Copyright 18.02.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: ensemble = xalglib.mlpecreatec2(nin, nhid1, nhid2, nout, ensemblesize)

</div></pre>
<a name='sub_mlpecreatefromnetwork'></a><h3 class=pageheader><code>mlpecreatefromnetwork</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Creates ensemble from network. Only network geometry is copied.
# 
#   -- ALGLIB --
#      Copyright 17.02.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: ensemble = xalglib.mlpecreatefromnetwork(network, ensemblesize)

</div></pre>
<a name='sub_mlpecreater0'></a><h3 class=pageheader><code>mlpecreater0</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Like MLPCreateR0, but for ensembles.
# 
#   -- ALGLIB --
#      Copyright 18.02.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: ensemble = xalglib.mlpecreater0(nin, nout, a, b, ensemblesize)

</div></pre>
<a name='sub_mlpecreater1'></a><h3 class=pageheader><code>mlpecreater1</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Like MLPCreateR1, but for ensembles.
# 
#   -- ALGLIB --
#      Copyright 18.02.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: ensemble = xalglib.mlpecreater1(nin, nhid, nout, a, b, ensemblesize)

</div></pre>
<a name='sub_mlpecreater2'></a><h3 class=pageheader><code>mlpecreater2</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Like MLPCreateR2, but for ensembles.
# 
#   -- ALGLIB --
#      Copyright 18.02.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: ensemble = xalglib.mlpecreater2(nin, nhid1, nhid2, nout, a, b, ensemblesize)

</div></pre>
<a name='sub_mlpeissoftmax'></a><h3 class=pageheader><code>mlpeissoftmax</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Return normalization type (whether ensemble is SOFTMAX-normalized or not).
# 
#   -- ALGLIB --
#      Copyright 17.02.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.mlpeissoftmax(ensemble)

</div></pre>
<a name='sub_mlpeprocess'></a><h3 class=pageheader><code>mlpeprocess</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Procesing
# 
# INPUT PARAMETERS:
#     Ensemble-   neural networks ensemble
#     X       -   input vector,  array[0..NIn-1].
#     Y       -   (possibly) preallocated buffer; if size of Y is less than
#                 NOut, it will be reallocated. If it is large enough, it
#                 is NOT reallocated, so we can save some time on reallocation.
# 
# 
# OUTPUT PARAMETERS:
#     Y       -   result. Regression estimate when solving regression  task,
#                 vector of posterior probabilities for classification task.
# 
#   -- ALGLIB --
#      Copyright 17.02.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: y = xalglib.mlpeprocess(ensemble, x, y)

</div></pre>
<a name='sub_mlpeprocessi'></a><h3 class=pageheader><code>mlpeprocessi</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# 'interactive'  variant  of  MLPEProcess  for  languages  like Python which
# support constructs like &quot;Y = MLPEProcess(LM,X)&quot; and interactive mode of the
# interpreter
# 
# This function allocates new array on each call,  so  it  is  significantly
# slower than its 'non-interactive' counterpart, but it is  more  convenient
# when you call it from command line.
# 
#   -- ALGLIB --
#      Copyright 17.02.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: y = xalglib.mlpeprocessi(ensemble, x)

</div></pre>
<a name='sub_mlpeproperties'></a><h3 class=pageheader><code>mlpeproperties</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Return ensemble properties (number of inputs and outputs).
# 
#   -- ALGLIB --
#      Copyright 17.02.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: nin, nout = xalglib.mlpeproperties(ensemble)

</div></pre>
<a name='sub_mlperandomize'></a><h3 class=pageheader><code>mlperandomize</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Randomization of MLP ensemble
# 
#   -- ALGLIB --
#      Copyright 17.02.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: xalglib.mlperandomize(ensemble)

</div></pre>
<a name='sub_mlperelclserror'></a><h3 class=pageheader><code>mlperelclserror</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Relative classification error on the test set
# 
# INPUT PARAMETERS:
#     Ensemble-   ensemble
#     XY      -   test set
#     NPoints -   test set size
# 
# RESULT:
#     percent of incorrectly classified cases.
#     Works both for classifier betwork and for regression networks which
# are used as classifiers.
# 
#   -- ALGLIB --
#      Copyright 17.02.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.mlperelclserror(ensemble, xy, npoints)

</div></pre>
<a name='sub_mlpermserror'></a><h3 class=pageheader><code>mlpermserror</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# RMS error on the test set
# 
# INPUT PARAMETERS:
#     Ensemble-   ensemble
#     XY      -   test set
#     NPoints -   test set size
# 
# RESULT:
#     root mean square error.
#     Its meaning for regression task is obvious. As for classification task
# RMS error means error when estimating posterior probabilities.
# 
#   -- ALGLIB --
#      Copyright 17.02.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.mlpermserror(ensemble, xy, npoints)

</div></pre>
<a name='sub_mlpetraines'></a><h3 class=pageheader><code>mlpetraines</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Training neural networks ensemble using early stopping.
# 
# INPUT PARAMETERS:
#     Ensemble    -   model with initialized geometry
#     XY          -   training set
#     NPoints     -   training set size
#     Decay       -   weight decay coefficient, &gt;=0.001
#     Restarts    -   restarts, &gt;0.
# 
# OUTPUT PARAMETERS:
#     Ensemble    -   trained model
#     Info        -   return code:
#                     * -2, if there is a point with class number
#                           outside of [0..NClasses-1].
#                     * -1, if incorrect parameters was passed
#                           (NPoints&lt;0, Restarts&lt;1).
#                     *  6, if task has been solved.
#     Rep         -   training report.
#     OOBErrors   -   out-of-bag generalization error estimate
# 
#   -- ALGLIB --
#      Copyright 10.03.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: info, rep = xalglib.mlpetraines(ensemble, xy, npoints, decay, restarts)

</div></pre>
<a name=unit_mlptrain></a><h2 class=pageheader><code>mlptrain</code> module</h2>
<div class=pagecontent>
<h3 class=pageheader>Classes</h3>
<a href='#struct_mlpcvreport' class=toc>mlpcvreport</a><br>
<a href='#struct_mlpreport' class=toc>mlpreport</a><br>
<h3 class=pageheader>Functions</h3>
<a href='#sub_mlpkfoldcvlbfgs' class=toc>mlpkfoldcvlbfgs</a><br>
<a href='#sub_mlpkfoldcvlm' class=toc>mlpkfoldcvlm</a><br>
<a href='#sub_mlptraines' class=toc>mlptraines</a><br>
<a href='#sub_mlptrainlbfgs' class=toc>mlptrainlbfgs</a><br>
<a href='#sub_mlptrainlm' class=toc>mlptrainlm</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='struct_mlpcvreport'></a><h3 class=pageheader><code>mlpcvreport</code> class</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Cross-validation estimates of generalization error
#

</div><div style='margin-top: 0; margin-bottom: 0;'><span style='font-weight: bold; color: green;'>class</span> mlpcvreport(object):
    ...

</div></pre>
<a name='struct_mlpreport'></a><h3 class=pageheader><code>mlpreport</code> class</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Training report:
#     * NGrad     - number of gradient calculations
#     * NHess     - number of Hessian calculations
#     * NCholesky - number of Cholesky decompositions
#

</div><div style='margin-top: 0; margin-bottom: 0;'><span style='font-weight: bold; color: green;'>class</span> mlpreport(object):
    ...

</div></pre>
<a name='sub_mlpkfoldcvlbfgs'></a><h3 class=pageheader><code>mlpkfoldcvlbfgs</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Cross-validation estimate of generalization error.
# 
# Base algorithm - L-BFGS.
# 
# INPUT PARAMETERS:
#     Network     -   neural network with initialized geometry.   Network is
#                     not changed during cross-validation -  it is used only
#                     as a representative of its architecture.
#     XY          -   training set.
#     SSize       -   training set size
#     Decay       -   weight  decay, same as in MLPTrainLBFGS
#     Restarts    -   number of restarts, &gt;0.
#                     restarts are counted for each partition separately, so
#                     total number of restarts will be Restarts*FoldsCount.
#     WStep       -   stopping criterion, same as in MLPTrainLBFGS
#     MaxIts      -   stopping criterion, same as in MLPTrainLBFGS
#     FoldsCount  -   number of folds in k-fold cross-validation,
#                     2&lt;=FoldsCount&lt;=SSize.
#                     recommended value: 10.
# 
# OUTPUT PARAMETERS:
#     Info        -   return code, same as in MLPTrainLBFGS
#     Rep         -   report, same as in MLPTrainLM/MLPTrainLBFGS
#     CVRep       -   generalization error estimates
# 
#   -- ALGLIB --
#      Copyright 09.12.2007 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: info, rep, cvrep = xalglib.mlpkfoldcvlbfgs(network, xy, npoints, decay, restarts, wstep, maxits, foldscount)

</div></pre>
<a name='sub_mlpkfoldcvlm'></a><h3 class=pageheader><code>mlpkfoldcvlm</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Cross-validation estimate of generalization error.
# 
# Base algorithm - Levenberg-Marquardt.
# 
# INPUT PARAMETERS:
#     Network     -   neural network with initialized geometry.   Network is
#                     not changed during cross-validation -  it is used only
#                     as a representative of its architecture.
#     XY          -   training set.
#     SSize       -   training set size
#     Decay       -   weight  decay, same as in MLPTrainLBFGS
#     Restarts    -   number of restarts, &gt;0.
#                     restarts are counted for each partition separately, so
#                     total number of restarts will be Restarts*FoldsCount.
#     FoldsCount  -   number of folds in k-fold cross-validation,
#                     2&lt;=FoldsCount&lt;=SSize.
#                     recommended value: 10.
# 
# OUTPUT PARAMETERS:
#     Info        -   return code, same as in MLPTrainLBFGS
#     Rep         -   report, same as in MLPTrainLM/MLPTrainLBFGS
#     CVRep       -   generalization error estimates
# 
#   -- ALGLIB --
#      Copyright 09.12.2007 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: info, rep, cvrep = xalglib.mlpkfoldcvlm(network, xy, npoints, decay, restarts, foldscount)

</div></pre>
<a name='sub_mlptraines'></a><h3 class=pageheader><code>mlptraines</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Neural network training using early stopping (base algorithm - L-BFGS with
# regularization).
# 
# INPUT PARAMETERS:
#     Network     -   neural network with initialized geometry
#     TrnXY       -   training set
#     TrnSize     -   training set size
#     ValXY       -   validation set
#     ValSize     -   validation set size
#     Decay       -   weight decay constant, &gt;=0.001
#                     Decay term 'Decay*||Weights||^2' is added to error
#                     function.
#                     If you don't know what Decay to choose, use 0.001.
#     Restarts    -   number of restarts from random position, &gt;0.
#                     If you don't know what Restarts to choose, use 2.
# 
# OUTPUT PARAMETERS:
#     Network     -   trained neural network.
#     Info        -   return code:
#                     * -2, if there is a point with class number
#                           outside of [0..NOut-1].
#                     * -1, if wrong parameters specified
#                           (NPoints&lt;0, Restarts&lt;1, ...).
#                     *  2, task has been solved, stopping  criterion  met -
#                           sufficiently small step size.  Not expected  (we
#                           use  EARLY  stopping)  but  possible  and not an
#                           error.
#                     *  6, task has been solved, stopping  criterion  met -
#                           increasing of validation set error.
#     Rep         -   training report
# 
# NOTE:
# 
# Algorithm stops if validation set error increases for  a  long  enough  or
# step size is small enought  (there  are  task  where  validation  set  may
# decrease for eternity). In any case solution returned corresponds  to  the
# minimum of validation set error.
# 
#   -- ALGLIB --
#      Copyright 10.03.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: info, rep = xalglib.mlptraines(network, trnxy, trnsize, valxy, valsize, decay, restarts)

</div></pre>
<a name='sub_mlptrainlbfgs'></a><h3 class=pageheader><code>mlptrainlbfgs</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Neural  network  training  using  L-BFGS  algorithm  with  regularization.
# Subroutine  trains  neural  network  with  restarts from random positions.
# Algorithm  is  well  suited  for  problems  of  any dimensionality (memory
# requirements and step complexity are linear by weights number).
# 
# INPUT PARAMETERS:
#     Network     -   neural network with initialized geometry
#     XY          -   training set
#     NPoints     -   training set size
#     Decay       -   weight decay constant, &gt;=0.001
#                     Decay term 'Decay*||Weights||^2' is added to error
#                     function.
#                     If you don't know what Decay to choose, use 0.001.
#     Restarts    -   number of restarts from random position, &gt;0.
#                     If you don't know what Restarts to choose, use 2.
#     WStep       -   stopping criterion. Algorithm stops if  step  size  is
#                     less than WStep. Recommended value - 0.01.  Zero  step
#                     size means stopping after MaxIts iterations.
#     MaxIts      -   stopping   criterion.  Algorithm  stops  after  MaxIts
#                     iterations (NOT gradient  calculations).  Zero  MaxIts
#                     means stopping when step is sufficiently small.
# 
# OUTPUT PARAMETERS:
#     Network     -   trained neural network.
#     Info        -   return code:
#                     * -8, if both WStep=0 and MaxIts=0
#                     * -2, if there is a point with class number
#                           outside of [0..NOut-1].
#                     * -1, if wrong parameters specified
#                           (NPoints&lt;0, Restarts&lt;1).
#                     *  2, if task has been solved.
#     Rep         -   training report
# 
#   -- ALGLIB --
#      Copyright 09.12.2007 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: info, rep = xalglib.mlptrainlbfgs(network, xy, npoints, decay, restarts, wstep, maxits)

</div></pre>
<a name='sub_mlptrainlm'></a><h3 class=pageheader><code>mlptrainlm</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Neural network training  using  modified  Levenberg-Marquardt  with  exact
# Hessian calculation and regularization. Subroutine trains  neural  network
# with restarts from random positions. Algorithm is well  suited  for  small
# and medium scale problems (hundreds of weights).
# 
# INPUT PARAMETERS:
#     Network     -   neural network with initialized geometry
#     XY          -   training set
#     NPoints     -   training set size
#     Decay       -   weight decay constant, &gt;=0.001
#                     Decay term 'Decay*||Weights||^2' is added to error
#                     function.
#                     If you don't know what Decay to choose, use 0.001.
#     Restarts    -   number of restarts from random position, &gt;0.
#                     If you don't know what Restarts to choose, use 2.
# 
# OUTPUT PARAMETERS:
#     Network     -   trained neural network.
#     Info        -   return code:
#                     * -9, if internal matrix inverse subroutine failed
#                     * -2, if there is a point with class number
#                           outside of [0..NOut-1].
#                     * -1, if wrong parameters specified
#                           (NPoints&lt;0, Restarts&lt;1).
#                     *  2, if task has been solved.
#     Rep         -   training report
# 
#   -- ALGLIB --
#      Copyright 10.03.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: info, rep = xalglib.mlptrainlm(network, xy, npoints, decay, restarts)

</div></pre>
<a name=unit_nearestneighbor></a><h2 class=pageheader><code>nearestneighbor</code> module</h2>
<div class=pagecontent>
<h3 class=pageheader>Classes</h3>
<a href='#struct_kdtree' class=toc>kdtree</a><br>
<h3 class=pageheader>Functions</h3>
<a href='#sub_kdtreebuild' class=toc>kdtreebuild</a><br>
<a href='#sub_kdtreebuildtagged' class=toc>kdtreebuildtagged</a><br>
<a href='#sub_kdtreequeryaknn' class=toc>kdtreequeryaknn</a><br>
<a href='#sub_kdtreequeryknn' class=toc>kdtreequeryknn</a><br>
<a href='#sub_kdtreequeryresultsdistances' class=toc>kdtreequeryresultsdistances</a><br>
<a href='#sub_kdtreequeryresultsdistancesi' class=toc>kdtreequeryresultsdistancesi</a><br>
<a href='#sub_kdtreequeryresultstags' class=toc>kdtreequeryresultstags</a><br>
<a href='#sub_kdtreequeryresultstagsi' class=toc>kdtreequeryresultstagsi</a><br>
<a href='#sub_kdtreequeryresultsx' class=toc>kdtreequeryresultsx</a><br>
<a href='#sub_kdtreequeryresultsxi' class=toc>kdtreequeryresultsxi</a><br>
<a href='#sub_kdtreequeryresultsxy' class=toc>kdtreequeryresultsxy</a><br>
<a href='#sub_kdtreequeryresultsxyi' class=toc>kdtreequeryresultsxyi</a><br>
<a href='#sub_kdtreequeryrnn' class=toc>kdtreequeryrnn</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
<tr align=left valign=top><td><a href='#example_nneighbor_d_1' class=toc>nneighbor_d_1</a></td><td width=15>&nbsp;</td><td>Nearest neighbor search, KNN queries</td></tr>
</table></div>
<a name='struct_kdtree'></a><h3 class=pageheader><code>kdtree</code> class</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# 
#

</div><div style='margin-top: 0; margin-bottom: 0;'><span style='font-weight: bold; color: green;'>class</span> kdtree(object):
    ...

</div></pre>
<a name='sub_kdtreebuild'></a><h3 class=pageheader><code>kdtreebuild</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# KD-tree creation
# 
# This subroutine creates KD-tree from set of X-values and optional Y-values
# 
# INPUT PARAMETERS
#     XY      -   dataset, array[0..N-1,0..NX+NY-1].
#                 one row corresponds to one point.
#                 first NX columns contain X-values, next NY (NY may be zero)
#                 columns may contain associated Y-values
#     N       -   number of points, N&gt;=1
#     NX      -   space dimension, NX&gt;=1.
#     NY      -   number of optional Y-values, NY&gt;=0.
#     NormType-   norm type:
#                 * 0 denotes infinity-norm
#                 * 1 denotes 1-norm
#                 * 2 denotes 2-norm (Euclidean norm)
# 
# OUTPUT PARAMETERS
#     KDT     -   KD-tree
# 
# 
# NOTES
# 
# 1. KD-tree  creation  have O(N*logN) complexity and O(N*(2*NX+NY))  memory
#    requirements.
# 2. Although KD-trees may be used with any combination of N  and  NX,  they
#    are more efficient than brute-force search only when N &gt;&gt; 4^NX. So they
#    are most useful in low-dimensional tasks (NX=2, NX=3). NX=1  is another
#    inefficient case, because  simple  binary  search  (without  additional
#    structures) is much more efficient in such tasks than KD-trees.
# 
#   -- ALGLIB --
#      Copyright 28.02.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: kdt = xalglib.kdtreebuild(xy, n, nx, ny, normtype)
SYNTAX: kdt = xalglib.kdtreebuild(xy, nx, ny, normtype)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_nneighbor_d_1' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_kdtreebuildtagged'></a><h3 class=pageheader><code>kdtreebuildtagged</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# KD-tree creation
# 
# This  subroutine  creates  KD-tree  from set of X-values, integer tags and
# optional Y-values
# 
# INPUT PARAMETERS
#     XY      -   dataset, array[0..N-1,0..NX+NY-1].
#                 one row corresponds to one point.
#                 first NX columns contain X-values, next NY (NY may be zero)
#                 columns may contain associated Y-values
#     Tags    -   tags, array[0..N-1], contains integer tags associated
#                 with points.
#     N       -   number of points, N&gt;=1
#     NX      -   space dimension, NX&gt;=1.
#     NY      -   number of optional Y-values, NY&gt;=0.
#     NormType-   norm type:
#                 * 0 denotes infinity-norm
#                 * 1 denotes 1-norm
#                 * 2 denotes 2-norm (Euclidean norm)
# 
# OUTPUT PARAMETERS
#     KDT     -   KD-tree
# 
# NOTES
# 
# 1. KD-tree  creation  have O(N*logN) complexity and O(N*(2*NX+NY))  memory
#    requirements.
# 2. Although KD-trees may be used with any combination of N  and  NX,  they
#    are more efficient than brute-force search only when N &gt;&gt; 4^NX. So they
#    are most useful in low-dimensional tasks (NX=2, NX=3). NX=1  is another
#    inefficient case, because  simple  binary  search  (without  additional
#    structures) is much more efficient in such tasks than KD-trees.
# 
#   -- ALGLIB --
#      Copyright 28.02.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: kdt = xalglib.kdtreebuildtagged(xy, tags, n, nx, ny, normtype)
SYNTAX: kdt = xalglib.kdtreebuildtagged(xy, tags, nx, ny, normtype)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_nneighbor_d_1' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_kdtreequeryaknn'></a><h3 class=pageheader><code>kdtreequeryaknn</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# K-NN query: approximate K nearest neighbors
# 
# INPUT PARAMETERS
#     KDT         -   KD-tree
#     X           -   point, array[0..NX-1].
#     K           -   number of neighbors to return, K&gt;=1
#     SelfMatch   -   whether self-matches are allowed:
#                     * if True, nearest neighbor may be the point itself
#                       (if it exists in original dataset)
#                     * if False, then only points with non-zero distance
#                       are returned
#                     * if not given, considered True
#     Eps         -   approximation factor, Eps&gt;=0. eps-approximate  nearest
#                     neighbor  is  a  neighbor  whose distance from X is at
#                     most (1+eps) times distance of true nearest neighbor.
# 
# RESULT
#     number of actual neighbors found (either K or N, if K&gt;N).
# 
# NOTES
#     significant performance gain may be achieved only when Eps  is  is  on
#     the order of magnitude of 1 or larger.
# 
# This  subroutine  performs  query  and  stores  its result in the internal
# structures of the KD-tree. You can use  following  subroutines  to  obtain
# these results:
# * KDTreeQueryResultsX() to get X-values
# * KDTreeQueryResultsXY() to get X- and Y-values
# * KDTreeQueryResultsTags() to get tag values
# * KDTreeQueryResultsDistances() to get distances
# 
#   -- ALGLIB --
#      Copyright 28.02.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.kdtreequeryaknn(kdt, x, k, selfmatch, eps)
SYNTAX: result = xalglib.kdtreequeryaknn(kdt, x, k, eps)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_nneighbor_d_1' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_kdtreequeryknn'></a><h3 class=pageheader><code>kdtreequeryknn</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# K-NN query: K nearest neighbors
# 
# INPUT PARAMETERS
#     KDT         -   KD-tree
#     X           -   point, array[0..NX-1].
#     K           -   number of neighbors to return, K&gt;=1
#     SelfMatch   -   whether self-matches are allowed:
#                     * if True, nearest neighbor may be the point itself
#                       (if it exists in original dataset)
#                     * if False, then only points with non-zero distance
#                       are returned
#                     * if not given, considered True
# 
# RESULT
#     number of actual neighbors found (either K or N, if K&gt;N).
# 
# This  subroutine  performs  query  and  stores  its result in the internal
# structures of the KD-tree. You can use  following  subroutines  to  obtain
# these results:
# * KDTreeQueryResultsX() to get X-values
# * KDTreeQueryResultsXY() to get X- and Y-values
# * KDTreeQueryResultsTags() to get tag values
# * KDTreeQueryResultsDistances() to get distances
# 
#   -- ALGLIB --
#      Copyright 28.02.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.kdtreequeryknn(kdt, x, k, selfmatch)
SYNTAX: result = xalglib.kdtreequeryknn(kdt, x, k)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_nneighbor_d_1' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_kdtreequeryresultsdistances'></a><h3 class=pageheader><code>kdtreequeryresultsdistances</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Distances from last query
# 
# INPUT PARAMETERS
#     KDT     -   KD-tree
#     R       -   possibly pre-allocated buffer. If X is too small to store
#                 result, it is resized. If size(X) is enough to store
#                 result, it is left unchanged.
# 
# OUTPUT PARAMETERS
#     R       -   filled with distances (in corresponding norm)
# 
# NOTES
# 1. points are ordered by distance from the query point (first = closest)
# 2. if  XY is larger than required to store result, only leading part  will
#    be overwritten; trailing part will be left unchanged. So  if  on  input
#    XY = [[A,B],[C,D]], and result is [1,2],  then  on  exit  we  will  get
#    XY = [[1,2],[C,D]]. This is done purposely to increase performance;  if
#    you want function  to  resize  array  according  to  result  size,  use
#    function with same name and suffix 'I'.
# 
# SEE ALSO
# * KDTreeQueryResultsX()             X-values
# * KDTreeQueryResultsXY()            X- and Y-values
# * KDTreeQueryResultsTags()          tag values
# 
#   -- ALGLIB --
#      Copyright 28.02.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: r = xalglib.kdtreequeryresultsdistances(kdt, r)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_nneighbor_d_1' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_kdtreequeryresultsdistancesi'></a><h3 class=pageheader><code>kdtreequeryresultsdistancesi</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Distances from last query; 'interactive' variant for languages like Python
# which  support  constructs   like  &quot;R = KDTreeQueryResultsDistancesI(KDT)&quot;
# and interactive mode of interpreter.
# 
# This function allocates new array on each call,  so  it  is  significantly
# slower than its 'non-interactive' counterpart, but it is  more  convenient
# when you call it from command line.
# 
#   -- ALGLIB --
#      Copyright 28.02.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: r = xalglib.kdtreequeryresultsdistancesi(kdt)

</div></pre>
<a name='sub_kdtreequeryresultstags'></a><h3 class=pageheader><code>kdtreequeryresultstags</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Tags from last query
# 
# INPUT PARAMETERS
#     KDT     -   KD-tree
#     Tags    -   possibly pre-allocated buffer. If X is too small to store
#                 result, it is resized. If size(X) is enough to store
#                 result, it is left unchanged.
# 
# OUTPUT PARAMETERS
#     Tags    -   filled with tags associated with points,
#                 or, when no tags were supplied, with zeros
# 
# NOTES
# 1. points are ordered by distance from the query point (first = closest)
# 2. if  XY is larger than required to store result, only leading part  will
#    be overwritten; trailing part will be left unchanged. So  if  on  input
#    XY = [[A,B],[C,D]], and result is [1,2],  then  on  exit  we  will  get
#    XY = [[1,2],[C,D]]. This is done purposely to increase performance;  if
#    you want function  to  resize  array  according  to  result  size,  use
#    function with same name and suffix 'I'.
# 
# SEE ALSO
# * KDTreeQueryResultsX()             X-values
# * KDTreeQueryResultsXY()            X- and Y-values
# * KDTreeQueryResultsDistances()     distances
# 
#   -- ALGLIB --
#      Copyright 28.02.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: tags = xalglib.kdtreequeryresultstags(kdt, tags)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_nneighbor_d_1' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_kdtreequeryresultstagsi'></a><h3 class=pageheader><code>kdtreequeryresultstagsi</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Tags  from  last  query;  'interactive' variant for languages like  Python
# which  support  constructs  like &quot;Tags = KDTreeQueryResultsTagsI(KDT)&quot; and
# interactive mode of interpreter.
# 
# This function allocates new array on each call,  so  it  is  significantly
# slower than its 'non-interactive' counterpart, but it is  more  convenient
# when you call it from command line.
# 
#   -- ALGLIB --
#      Copyright 28.02.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: tags = xalglib.kdtreequeryresultstagsi(kdt)

</div></pre>
<a name='sub_kdtreequeryresultsx'></a><h3 class=pageheader><code>kdtreequeryresultsx</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# X-values from last query
# 
# INPUT PARAMETERS
#     KDT     -   KD-tree
#     X       -   possibly pre-allocated buffer. If X is too small to store
#                 result, it is resized. If size(X) is enough to store
#                 result, it is left unchanged.
# 
# OUTPUT PARAMETERS
#     X       -   rows are filled with X-values
# 
# NOTES
# 1. points are ordered by distance from the query point (first = closest)
# 2. if  XY is larger than required to store result, only leading part  will
#    be overwritten; trailing part will be left unchanged. So  if  on  input
#    XY = [[A,B],[C,D]], and result is [1,2],  then  on  exit  we  will  get
#    XY = [[1,2],[C,D]]. This is done purposely to increase performance;  if
#    you want function  to  resize  array  according  to  result  size,  use
#    function with same name and suffix 'I'.
# 
# SEE ALSO
# * KDTreeQueryResultsXY()            X- and Y-values
# * KDTreeQueryResultsTags()          tag values
# * KDTreeQueryResultsDistances()     distances
# 
#   -- ALGLIB --
#      Copyright 28.02.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: x = xalglib.kdtreequeryresultsx(kdt, x)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_nneighbor_d_1' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_kdtreequeryresultsxi'></a><h3 class=pageheader><code>kdtreequeryresultsxi</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# X-values from last query; 'interactive' variant for languages like  Python
# which   support    constructs   like  &quot;X = KDTreeQueryResultsXI(KDT)&quot;  and
# interactive mode of interpreter.
# 
# This function allocates new array on each call,  so  it  is  significantly
# slower than its 'non-interactive' counterpart, but it is  more  convenient
# when you call it from command line.
# 
#   -- ALGLIB --
#      Copyright 28.02.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: x = xalglib.kdtreequeryresultsxi(kdt)

</div></pre>
<a name='sub_kdtreequeryresultsxy'></a><h3 class=pageheader><code>kdtreequeryresultsxy</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# X- and Y-values from last query
# 
# INPUT PARAMETERS
#     KDT     -   KD-tree
#     XY      -   possibly pre-allocated buffer. If XY is too small to store
#                 result, it is resized. If size(XY) is enough to store
#                 result, it is left unchanged.
# 
# OUTPUT PARAMETERS
#     XY      -   rows are filled with points: first NX columns with
#                 X-values, next NY columns - with Y-values.
# 
# NOTES
# 1. points are ordered by distance from the query point (first = closest)
# 2. if  XY is larger than required to store result, only leading part  will
#    be overwritten; trailing part will be left unchanged. So  if  on  input
#    XY = [[A,B],[C,D]], and result is [1,2],  then  on  exit  we  will  get
#    XY = [[1,2],[C,D]]. This is done purposely to increase performance;  if
#    you want function  to  resize  array  according  to  result  size,  use
#    function with same name and suffix 'I'.
# 
# SEE ALSO
# * KDTreeQueryResultsX()             X-values
# * KDTreeQueryResultsTags()          tag values
# * KDTreeQueryResultsDistances()     distances
# 
#   -- ALGLIB --
#      Copyright 28.02.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: xy = xalglib.kdtreequeryresultsxy(kdt, xy)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_nneighbor_d_1' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_kdtreequeryresultsxyi'></a><h3 class=pageheader><code>kdtreequeryresultsxyi</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# XY-values from last query; 'interactive' variant for languages like Python
# which   support    constructs   like &quot;XY = KDTreeQueryResultsXYI(KDT)&quot; and
# interactive mode of interpreter.
# 
# This function allocates new array on each call,  so  it  is  significantly
# slower than its 'non-interactive' counterpart, but it is  more  convenient
# when you call it from command line.
# 
#   -- ALGLIB --
#      Copyright 28.02.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: xy = xalglib.kdtreequeryresultsxyi(kdt)

</div></pre>
<a name='sub_kdtreequeryrnn'></a><h3 class=pageheader><code>kdtreequeryrnn</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# R-NN query: all points within R-sphere centered at X
# 
# INPUT PARAMETERS
#     KDT         -   KD-tree
#     X           -   point, array[0..NX-1].
#     R           -   radius of sphere (in corresponding norm), R&gt;0
#     SelfMatch   -   whether self-matches are allowed:
#                     * if True, nearest neighbor may be the point itself
#                       (if it exists in original dataset)
#                     * if False, then only points with non-zero distance
#                       are returned
#                     * if not given, considered True
# 
# RESULT
#     number of neighbors found, &gt;=0
# 
# This  subroutine  performs  query  and  stores  its result in the internal
# structures of the KD-tree. You can use  following  subroutines  to  obtain
# actual results:
# * KDTreeQueryResultsX() to get X-values
# * KDTreeQueryResultsXY() to get X- and Y-values
# * KDTreeQueryResultsTags() to get tag values
# * KDTreeQueryResultsDistances() to get distances
# 
#   -- ALGLIB --
#      Copyright 28.02.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.kdtreequeryrnn(kdt, x, r, selfmatch)
SYNTAX: result = xalglib.kdtreequeryrnn(kdt, x, r)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_nneighbor_d_1' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='example_nneighbor_d_1'></a><h3 class=pageheader>nneighbor_d_1 example</h3>
<pre class=source>
import xalglib



a = [[0,0],[0,1],[1,0],[1,1]]
nx = 2
ny = 0
normtype = 2
r = [[]]
kdt = xalglib.kdtreebuild(a, nx, ny, normtype)
x = [-1,0]
k = xalglib.kdtreequeryknn(kdt, x, 1)
print(k) <font color=darkcyan># expected 1</font>
r = xalglib.kdtreequeryresultsx(kdt, r)
print(r) <font color=darkcyan># expected [[0,0]]</font>


</pre><a name=unit_nleq></a><h2 class=pageheader><code>nleq</code> module</h2>
<div class=pagecontent>
<h3 class=pageheader>Classes</h3>
<a href='#struct_nleqreport' class=toc>nleqreport</a><br>
<a href='#struct_nleqstate' class=toc>nleqstate</a><br>
<h3 class=pageheader>Functions</h3>
<a href='#sub_nleqcreatelm' class=toc>nleqcreatelm</a><br>
<a href='#sub_nleqrestartfrom' class=toc>nleqrestartfrom</a><br>
<a href='#sub_nleqresults' class=toc>nleqresults</a><br>
<a href='#sub_nleqresultsbuf' class=toc>nleqresultsbuf</a><br>
<a href='#sub_nleqsetcond' class=toc>nleqsetcond</a><br>
<a href='#sub_nleqsetstpmax' class=toc>nleqsetstpmax</a><br>
<a href='#sub_nleqsetxrep' class=toc>nleqsetxrep</a><br>
<a href='#sub_nleqsolve' class=toc>nleqsolve</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='struct_nleqreport'></a><h3 class=pageheader><code>nleqreport</code> class</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# 
#

</div><div style='margin-top: 0; margin-bottom: 0;'><span style='font-weight: bold; color: green;'>class</span> nleqreport(object):
    ...

</div></pre>
<a name='struct_nleqstate'></a><h3 class=pageheader><code>nleqstate</code> class</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# 
#

</div><div style='margin-top: 0; margin-bottom: 0;'><span style='font-weight: bold; color: green;'>class</span> nleqstate(object):
    ...

</div></pre>
<a name='sub_nleqcreatelm'></a><h3 class=pageheader><code>nleqcreatelm</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
#                 LEVENBERG-MARQUARDT-LIKE NONLINEAR SOLVER
# 
# DESCRIPTION:
# This algorithm solves system of nonlinear equations
#     F[0](x[0], ..., x[n-1])   = 0
#     F[1](x[0], ..., x[n-1])   = 0
#     ...
#     F[M-1](x[0], ..., x[n-1]) = 0
# with M/N do not necessarily coincide.  Algorithm  converges  quadratically
# under following conditions:
#     * the solution set XS is nonempty
#     * for some xs in XS there exist such neighbourhood N(xs) that:
#       * vector function F(x) and its Jacobian J(x) are continuously
#         differentiable on N
#       * ||F(x)|| provides local error bound on N, i.e. there  exists  such
#         c1, that ||F(x)||&gt;c1*distance(x,XS)
# Note that these conditions are much more weaker than usual non-singularity
# conditions. For example, algorithm will converge for any  affine  function
# F (whether its Jacobian singular or not).
# 
# 
# REQUIREMENTS:
# Algorithm will request following information during its operation:
# * function vector F[] and Jacobian matrix at given point X
# * value of merit function f(x)=F[0]^2(x)+...+F[M-1]^2(x) at given point X
# 
# 
# USAGE:
# 1. User initializes algorithm state with NLEQCreateLM() call
# 2. User tunes solver parameters with  NLEQSetCond(),  NLEQSetStpMax()  and
#    other functions
# 3. User  calls  NLEQSolve()  function  which  takes  algorithm  state  and
#    pointers (delegates, etc.) to callback functions which calculate  merit
#    function value and Jacobian.
# 4. User calls NLEQResults() to get solution
# 5. Optionally, user may call NLEQRestartFrom() to  solve  another  problem
#    with same parameters (N/M) but another starting  point  and/or  another
#    function vector. NLEQRestartFrom() allows to reuse already  initialized
#    structure.
# 
# 
# INPUT PARAMETERS:
#     N       -   space dimension, N&gt;1:
#                 * if provided, only leading N elements of X are used
#                 * if not provided, determined automatically from size of X
#     M       -   system size
#     X       -   starting point
# 
# 
# OUTPUT PARAMETERS:
#     State   -   structure which stores algorithm state
# 
# 
# NOTES:
# 1. you may tune stopping conditions with NLEQSetCond() function
# 2. if target function contains exp() or other fast growing functions,  and
#    optimization algorithm makes too large steps which leads  to  overflow,
#    use NLEQSetStpMax() function to bound algorithm's steps.
# 3. this  algorithm  is  a  slightly  modified implementation of the method
#    described  in  'Levenberg-Marquardt  method  for constrained  nonlinear
#    equations with strong local convergence properties' by Christian Kanzow
#    Nobuo Yamashita and Masao Fukushima and further  developed  in  'On the
#    convergence of a New Levenberg-Marquardt Method'  by  Jin-yan  Fan  and
#    Ya-Xiang Yuan.
# 
# 
#   -- ALGLIB --
#      Copyright 20.08.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: state = xalglib.nleqcreatelm(n, m, x)
SYNTAX: state = xalglib.nleqcreatelm(m, x)

</div></pre>
<a name='sub_nleqrestartfrom'></a><h3 class=pageheader><code>nleqrestartfrom</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# This  subroutine  restarts  CG  algorithm from new point. All optimization
# parameters are left unchanged.
# 
# This  function  allows  to  solve multiple  optimization  problems  (which
# must have same number of dimensions) without object reallocation penalty.
# 
# INPUT PARAMETERS:
#     State   -   structure used for reverse communication previously
#                 allocated with MinCGCreate call.
#     X       -   new starting point.
#     BndL    -   new lower bounds
#     BndU    -   new upper bounds
# 
#   -- ALGLIB --
#      Copyright 30.07.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: xalglib.nleqrestartfrom(state, x)

</div></pre>
<a name='sub_nleqresults'></a><h3 class=pageheader><code>nleqresults</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# NLEQ solver results
# 
# INPUT PARAMETERS:
#     State   -   algorithm state.
# 
# OUTPUT PARAMETERS:
#     X       -   array[0..N-1], solution
#     Rep     -   optimization report:
#                 * Rep.TerminationType completetion code:
#                     * -4    ERROR:  algorithm   has   converged   to   the
#                             stationary point Xf which is local minimum  of
#                             f=F[0]^2+...+F[m-1]^2, but is not solution  of
#                             nonlinear system.
#                     *  1    sqrt(f)&lt;=EpsF.
#                     *  5    MaxIts steps was taken
#                     *  7    stopping conditions are too stringent,
#                             further improvement is impossible
#                 * Rep.IterationsCount contains iterations count
#                 * NFEV countains number of function calculations
#                 * ActiveConstraints contains number of active constraints
# 
#   -- ALGLIB --
#      Copyright 20.08.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: x, rep = xalglib.nleqresults(state)

</div></pre>
<a name='sub_nleqresultsbuf'></a><h3 class=pageheader><code>nleqresultsbuf</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# NLEQ solver results
# 
# Buffered implementation of NLEQResults(), which uses pre-allocated  buffer
# to store X[]. If buffer size is  too  small,  it  resizes  buffer.  It  is
# intended to be used in the inner cycles of performance critical algorithms
# where array reallocation penalty is too large to be ignored.
# 
#   -- ALGLIB --
#      Copyright 20.08.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: x, rep = xalglib.nleqresultsbuf(state, x, rep)

</div></pre>
<a name='sub_nleqsetcond'></a><h3 class=pageheader><code>nleqsetcond</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# This function sets stopping conditions for the nonlinear solver
# 
# INPUT PARAMETERS:
#     State   -   structure which stores algorithm state
#     EpsF    -   &gt;=0
#                 The subroutine finishes  its work if on k+1-th iteration
#                 the condition ||F||&lt;=EpsF is satisfied
#     MaxIts  -   maximum number of iterations. If MaxIts=0, the  number  of
#                 iterations is unlimited.
# 
# Passing EpsF=0 and MaxIts=0 simultaneously will lead to  automatic
# stopping criterion selection (small EpsF).
# 
# NOTES:
# 
#   -- ALGLIB --
#      Copyright 20.08.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: xalglib.nleqsetcond(state, epsf, maxits)

</div></pre>
<a name='sub_nleqsetstpmax'></a><h3 class=pageheader><code>nleqsetstpmax</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# This function sets maximum step length
# 
# INPUT PARAMETERS:
#     State   -   structure which stores algorithm state
#     StpMax  -   maximum step length, &gt;=0. Set StpMax to 0.0,  if you don't
#                 want to limit step length.
# 
# Use this subroutine when target function  contains  exp()  or  other  fast
# growing functions, and algorithm makes  too  large  steps  which  lead  to
# overflow. This function allows us to reject steps that are too large  (and
# therefore expose us to the possible overflow) without actually calculating
# function value at the x+stp*d.
# 
#   -- ALGLIB --
#      Copyright 20.08.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: xalglib.nleqsetstpmax(state, stpmax)

</div></pre>
<a name='sub_nleqsetxrep'></a><h3 class=pageheader><code>nleqsetxrep</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# This function turns on/off reporting.
# 
# INPUT PARAMETERS:
#     State   -   structure which stores algorithm state
#     NeedXRep-   whether iteration reports are needed or not
# 
# If NeedXRep is True, algorithm will call rep() callback function if  it is
# provided to NLEQSolve().
# 
#   -- ALGLIB --
#      Copyright 20.08.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: xalglib.nleqsetxrep(state, needxrep)

</div></pre>
<a name='sub_nleqsolve'></a><h3 class=pageheader><code>nleqsolve</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# This family of functions is used to launcn iterations of nonlinear solver
# 
# These functions accept following parameters:
#     state   -   algorithm state
#     func    -   callback which calculates function (or merit function)
#                 value func at given point x
#     jac     -   callback which calculates function vector fi[]
#                 and Jacobian jac at given point x
#     rep     -   optional callback which is called after each iteration
#                 can be NULL
#     ptr     -   optional pointer which is passed to func/grad/hess/jac/rep
#                 can be NULL
# 
# 
#   -- ALGLIB --
#      Copyright 20.03.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: xalglib.nleqsolve_fj(state, func, jac, rep = None, param = None)

</div></pre>
<a name=unit_normaldistr></a><h2 class=pageheader><code>normaldistr</code> module</h2>
<div class=pagecontent>
<h3 class=pageheader>Functions</h3>
<a href='#sub_errorfunction' class=toc>errorfunction</a><br>
<a href='#sub_errorfunctionc' class=toc>errorfunctionc</a><br>
<a href='#sub_inverf' class=toc>inverf</a><br>
<a href='#sub_invnormaldistribution' class=toc>invnormaldistribution</a><br>
<a href='#sub_normaldistribution' class=toc>normaldistribution</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='sub_errorfunction'></a><h3 class=pageheader><code>errorfunction</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Error function
# 
# The integral is
# 
#                           x
#                            -
#                 2         | |          2
#   erf(x)  =  --------     |    exp( - t  ) dt.
#              sqrt(pi)   | |
#                          -
#                           0
# 
# For 0 &lt;= |x| &lt; 1, erf(x) = x * P4(x**2)/Q5(x**2); otherwise
# erf(x) = 1 - erfc(x).
# 
# 
# ACCURACY:
# 
#                      Relative error:
# arithmetic   domain     # trials      peak         rms
#    IEEE      0,1         30000       3.7e-16     1.0e-16
# 
# Cephes Math Library Release 2.8:  June, 2000
# Copyright 1984, 1987, 1988, 1992, 2000 by Stephen L. Moshier
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.errorfunction(x)

</div></pre>
<a name='sub_errorfunctionc'></a><h3 class=pageheader><code>errorfunctionc</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Complementary error function
# 
#  1 - erf(x) =
# 
#                           inf.
#                             -
#                  2         | |          2
#   erfc(x)  =  --------     |    exp( - t  ) dt
#               sqrt(pi)   | |
#                           -
#                            x
# 
# 
# For small x, erfc(x) = 1 - erf(x); otherwise rational
# approximations are computed.
# 
# 
# ACCURACY:
# 
#                      Relative error:
# arithmetic   domain     # trials      peak         rms
#    IEEE      0,26.6417   30000       5.7e-14     1.5e-14
# 
# Cephes Math Library Release 2.8:  June, 2000
# Copyright 1984, 1987, 1988, 1992, 2000 by Stephen L. Moshier
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.errorfunctionc(x)

</div></pre>
<a name='sub_inverf'></a><h3 class=pageheader><code>inverf</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Inverse of the error function
# 
# Cephes Math Library Release 2.8:  June, 2000
# Copyright 1984, 1987, 1988, 1992, 2000 by Stephen L. Moshier
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.inverf(e)

</div></pre>
<a name='sub_invnormaldistribution'></a><h3 class=pageheader><code>invnormaldistribution</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Inverse of Normal distribution function
# 
# Returns the argument, x, for which the area under the
# Gaussian probability density function (integrated from
# minus infinity to x) is equal to y.
# 
# 
# For small arguments 0 &lt; y &lt; exp(-2), the program computes
# z = sqrt( -2.0 * log(y) );  then the approximation is
# x = z - log(z)/z  - (1/z) P(1/z) / Q(1/z).
# There are two rational functions P/Q, one for 0 &lt; y &lt; exp(-32)
# and the other for y up to exp(-2).  For larger arguments,
# w = y - 0.5, and  x/sqrt(2pi) = w + w**3 R(w**2)/S(w**2)).
# 
# ACCURACY:
# 
#                      Relative error:
# arithmetic   domain        # trials      peak         rms
#    IEEE     0.125, 1        20000       7.2e-16     1.3e-16
#    IEEE     3e-308, 0.135   50000       4.6e-16     9.8e-17
# 
# Cephes Math Library Release 2.8:  June, 2000
# Copyright 1984, 1987, 1988, 1992, 2000 by Stephen L. Moshier
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.invnormaldistribution(y0)

</div></pre>
<a name='sub_normaldistribution'></a><h3 class=pageheader><code>normaldistribution</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Normal distribution function
# 
# Returns the area under the Gaussian probability density
# function, integrated from minus infinity to x:
# 
#                            x
#                             -
#                   1        | |          2
#    ndtr(x)  = ---------    |    exp( - t /2 ) dt
#               sqrt(2pi)  | |
#                           -
#                          -inf.
# 
#             =  ( 1 + erf(z) ) / 2
#             =  erfc(z) / 2
# 
# where z = x/sqrt(2). Computation is via the functions
# erf and erfc.
# 
# 
# ACCURACY:
# 
#                      Relative error:
# arithmetic   domain     # trials      peak         rms
#    IEEE     -13,0        30000       3.4e-14     6.7e-15
# 
# Cephes Math Library Release 2.8:  June, 2000
# Copyright 1984, 1987, 1988, 1992, 2000 by Stephen L. Moshier
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.normaldistribution(x)

</div></pre>
<a name=unit_odesolver></a><h2 class=pageheader><code>odesolver</code> module</h2>
<div class=pagecontent>
<h3 class=pageheader>Classes</h3>
<a href='#struct_odesolverreport' class=toc>odesolverreport</a><br>
<a href='#struct_odesolverstate' class=toc>odesolverstate</a><br>
<h3 class=pageheader>Functions</h3>
<a href='#sub_odesolverresults' class=toc>odesolverresults</a><br>
<a href='#sub_odesolverrkck' class=toc>odesolverrkck</a><br>
<a href='#sub_odesolversolve' class=toc>odesolversolve</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
<tr align=left valign=top><td><a href='#example_odesolver_d1' class=toc>odesolver_d1</a></td><td width=15>&nbsp;</td><td>Solving y'=-y with ODE solver</td></tr>
</table></div>
<a name='struct_odesolverreport'></a><h3 class=pageheader><code>odesolverreport</code> class</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# 
#

</div><div style='margin-top: 0; margin-bottom: 0;'><span style='font-weight: bold; color: green;'>class</span> odesolverreport(object):
    ...

</div></pre>
<a name='struct_odesolverstate'></a><h3 class=pageheader><code>odesolverstate</code> class</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# 
#

</div><div style='margin-top: 0; margin-bottom: 0;'><span style='font-weight: bold; color: green;'>class</span> odesolverstate(object):
    ...

</div></pre>
<a name='sub_odesolverresults'></a><h3 class=pageheader><code>odesolverresults</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# ODE solver results
# 
# Called after OdeSolverIteration returned False.
# 
# INPUT PARAMETERS:
#     State   -   algorithm state (used by OdeSolverIteration).
# 
# OUTPUT PARAMETERS:
#     M       -   number of tabulated values, M&gt;=1
#     XTbl    -   array[0..M-1], values of X
#     YTbl    -   array[0..M-1,0..N-1], values of Y in X[i]
#     Rep     -   solver report:
#                 * Rep.TerminationType completetion code:
#                     * -2    X is not ordered  by  ascending/descending  or
#                             there are non-distinct X[],  i.e.  X[i]=X[i+1]
#                     * -1    incorrect parameters were specified
#                     *  1    task has been solved
#                 * Rep.NFEV contains number of function calculations
# 
#   -- ALGLIB --
#      Copyright 01.09.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: m, xtbl, ytbl, rep = xalglib.odesolverresults(state)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_odesolver_d1' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_odesolverrkck'></a><h3 class=pageheader><code>odesolverrkck</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Cash-Karp adaptive ODE solver.
# 
# This subroutine solves ODE  Y'=f(Y,x)  with  initial  conditions  Y(xs)=Ys
# (here Y may be single variable or vector of N variables).
# 
# INPUT PARAMETERS:
#     Y       -   initial conditions, array[0..N-1].
#                 contains values of Y[] at X[0]
#     N       -   system size
#     X       -   points at which Y should be tabulated, array[0..M-1]
#                 integrations starts at X[0], ends at X[M-1],  intermediate
#                 values at X[i] are returned too.
#                 SHOULD BE ORDERED BY ASCENDING OR BY DESCENDING!!!!
#     M       -   number of intermediate points + first point + last point:
#                 * M&gt;2 means that you need both Y(X[M-1]) and M-2 values at
#                   intermediate points
#                 * M=2 means that you want just to integrate from  X[0]  to
#                   X[1] and don't interested in intermediate values.
#                 * M=1 means that you don't want to integrate :)
#                   it is degenerate case, but it will be handled correctly.
#                 * M&lt;1 means error
#     Eps     -   tolerance (absolute/relative error on each  step  will  be
#                 less than Eps). When passing:
#                 * Eps&gt;0, it means desired ABSOLUTE error
#                 * Eps&lt;0, it means desired RELATIVE error.  Relative errors
#                   are calculated with respect to maximum values of  Y seen
#                   so far. Be careful to use this criterion  when  starting
#                   from Y[] that are close to zero.
#     H       -   initial  step  lenth,  it  will  be adjusted automatically
#                 after the first  step.  If  H=0,  step  will  be  selected
#                 automatically  (usualy  it  will  be  equal  to  0.001  of
#                 min(x[i]-x[j])).
# 
# OUTPUT PARAMETERS
#     State   -   structure which stores algorithm state between  subsequent
#                 calls of OdeSolverIteration. Used for reverse communication.
#                 This structure should be passed  to the OdeSolverIteration
#                 subroutine.
# 
# SEE ALSO
#     AutoGKSmoothW, AutoGKSingular, AutoGKIteration, AutoGKResults.
# 
# 
#   -- ALGLIB --
#      Copyright 01.09.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: state = xalglib.odesolverrkck(y, n, x, m, eps, h)
SYNTAX: state = xalglib.odesolverrkck(y, x, eps, h)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_odesolver_d1' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_odesolversolve'></a><h3 class=pageheader><code>odesolversolve</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# This function is used to launcn iterations of ODE solver
# 
# It accepts following parameters:
#     diff    -   callback which calculates dy/dx for given y and x
#     ptr     -   optional pointer which is passed to diff; can be NULL
# 
# 
#   -- ALGLIB --
#      Copyright 01.09.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: xalglib.odesolversolve(state, dy, param = None)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_odesolver_d1' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='example_odesolver_d1'></a><h3 class=pageheader>odesolver_d1 example</h3>
<pre class=source>
import xalglib

<b>def</b> ode_function_1_diff(y, x, dy, param):
    <font color=darkcyan>#</font>
    <font color=darkcyan># this callback calculates f(y[],x)=-y[0]</font>
    <font color=darkcyan>#</font>
    dy[0] = -y[0]
    <b>return</b>

y = [1]
x = [0, 1, 2, 3]
eps = 0.00001
h = 0
s = xalglib.odesolverrkck(y, x, eps, h)
xalglib.odesolversolve(s, ode_function_1_diff);
m, xtbl, ytbl, rep = xalglib.odesolverresults(s)
print(m) <font color=darkcyan># expected 4</font>
print(xtbl) <font color=darkcyan># expected [0, 1, 2, 3]</font>
print(ytbl) <font color=darkcyan># expected [[1], [0.367], [0.135], [0.050]]</font>


</pre><a name=unit_ortfac></a><h2 class=pageheader><code>ortfac</code> module</h2>
<div class=pagecontent>
<h3 class=pageheader>Functions</h3>
<a href='#sub_cmatrixlq' class=toc>cmatrixlq</a><br>
<a href='#sub_cmatrixlqunpackl' class=toc>cmatrixlqunpackl</a><br>
<a href='#sub_cmatrixlqunpackq' class=toc>cmatrixlqunpackq</a><br>
<a href='#sub_cmatrixqr' class=toc>cmatrixqr</a><br>
<a href='#sub_cmatrixqrunpackq' class=toc>cmatrixqrunpackq</a><br>
<a href='#sub_cmatrixqrunpackr' class=toc>cmatrixqrunpackr</a><br>
<a href='#sub_hmatrixtd' class=toc>hmatrixtd</a><br>
<a href='#sub_hmatrixtdunpackq' class=toc>hmatrixtdunpackq</a><br>
<a href='#sub_rmatrixbd' class=toc>rmatrixbd</a><br>
<a href='#sub_rmatrixbdmultiplybyp' class=toc>rmatrixbdmultiplybyp</a><br>
<a href='#sub_rmatrixbdmultiplybyq' class=toc>rmatrixbdmultiplybyq</a><br>
<a href='#sub_rmatrixbdunpackdiagonals' class=toc>rmatrixbdunpackdiagonals</a><br>
<a href='#sub_rmatrixbdunpackpt' class=toc>rmatrixbdunpackpt</a><br>
<a href='#sub_rmatrixbdunpackq' class=toc>rmatrixbdunpackq</a><br>
<a href='#sub_rmatrixhessenberg' class=toc>rmatrixhessenberg</a><br>
<a href='#sub_rmatrixhessenbergunpackh' class=toc>rmatrixhessenbergunpackh</a><br>
<a href='#sub_rmatrixhessenbergunpackq' class=toc>rmatrixhessenbergunpackq</a><br>
<a href='#sub_rmatrixlq' class=toc>rmatrixlq</a><br>
<a href='#sub_rmatrixlqunpackl' class=toc>rmatrixlqunpackl</a><br>
<a href='#sub_rmatrixlqunpackq' class=toc>rmatrixlqunpackq</a><br>
<a href='#sub_rmatrixqr' class=toc>rmatrixqr</a><br>
<a href='#sub_rmatrixqrunpackq' class=toc>rmatrixqrunpackq</a><br>
<a href='#sub_rmatrixqrunpackr' class=toc>rmatrixqrunpackr</a><br>
<a href='#sub_smatrixtd' class=toc>smatrixtd</a><br>
<a href='#sub_smatrixtdunpackq' class=toc>smatrixtdunpackq</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='sub_cmatrixlq'></a><h3 class=pageheader><code>cmatrixlq</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# LQ decomposition of a rectangular complex matrix of size MxN
# 
# Input parameters:
#     A   -   matrix A whose indexes range within [0..M-1, 0..N-1]
#     M   -   number of rows in matrix A.
#     N   -   number of columns in matrix A.
# 
# Output parameters:
#     A   -   matrices Q and L in compact form
#     Tau -   array of scalar factors which are used to form matrix Q. Array
#             whose indexes range within [0.. Min(M,N)-1]
# 
# Matrix A is represented as A = LQ, where Q is an orthogonal matrix of size
# MxM, L - lower triangular (or lower trapezoid) matrix of size MxN.
# 
#   -- LAPACK routine (version 3.0) --
#      Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
#      Courant Institute, Argonne National Lab, and Rice University
#      September 30, 1994
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: a, tau = xalglib.cmatrixlq(a, m, n)

</div></pre>
<a name='sub_cmatrixlqunpackl'></a><h3 class=pageheader><code>cmatrixlqunpackl</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Unpacking of matrix L from the LQ decomposition of a matrix A
# 
# Input parameters:
#     A       -   matrices Q and L in compact form.
#                 Output of CMatrixLQ subroutine.
#     M       -   number of rows in given matrix A. M&gt;=0.
#     N       -   number of columns in given matrix A. N&gt;=0.
# 
# Output parameters:
#     L       -   matrix L, array[0..M-1, 0..N-1].
# 
#   -- ALGLIB routine --
#      17.02.2010
#      Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: l = xalglib.cmatrixlqunpackl(a, m, n)

</div></pre>
<a name='sub_cmatrixlqunpackq'></a><h3 class=pageheader><code>cmatrixlqunpackq</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Partial unpacking of matrix Q from LQ decomposition of a complex matrix A.
# 
# Input parameters:
#     A           -   matrices Q and R in compact form.
#                     Output of CMatrixLQ subroutine .
#     M           -   number of rows in matrix A. M&gt;=0.
#     N           -   number of columns in matrix A. N&gt;=0.
#     Tau         -   scalar factors which are used to form Q.
#                     Output of CMatrixLQ subroutine .
#     QRows       -   required number of rows in matrix Q. N&gt;=QColumns&gt;=0.
# 
# Output parameters:
#     Q           -   first QRows rows of matrix Q.
#                     Array whose index ranges within [0..QRows-1, 0..N-1].
#                     If QRows=0, array isn't changed.
# 
#   -- ALGLIB routine --
#      17.02.2010
#      Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: q = xalglib.cmatrixlqunpackq(a, m, n, tau, qrows)

</div></pre>
<a name='sub_cmatrixqr'></a><h3 class=pageheader><code>cmatrixqr</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# QR decomposition of a rectangular complex matrix of size MxN
# 
# Input parameters:
#     A   -   matrix A whose indexes range within [0..M-1, 0..N-1]
#     M   -   number of rows in matrix A.
#     N   -   number of columns in matrix A.
# 
# Output parameters:
#     A   -   matrices Q and R in compact form
#     Tau -   array of scalar factors which are used to form matrix Q. Array
#             whose indexes range within [0.. Min(M,N)-1]
# 
# Matrix A is represented as A = QR, where Q is an orthogonal matrix of size
# MxM, R - upper triangular (or upper trapezoid) matrix of size MxN.
# 
#   -- LAPACK routine (version 3.0) --
#      Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
#      Courant Institute, Argonne National Lab, and Rice University
#      September 30, 1994
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: a, tau = xalglib.cmatrixqr(a, m, n)

</div></pre>
<a name='sub_cmatrixqrunpackq'></a><h3 class=pageheader><code>cmatrixqrunpackq</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Partial unpacking of matrix Q from QR decomposition of a complex matrix A.
# 
# Input parameters:
#     A           -   matrices Q and R in compact form.
#                     Output of CMatrixQR subroutine .
#     M           -   number of rows in matrix A. M&gt;=0.
#     N           -   number of columns in matrix A. N&gt;=0.
#     Tau         -   scalar factors which are used to form Q.
#                     Output of CMatrixQR subroutine .
#     QColumns    -   required number of columns in matrix Q. M&gt;=QColumns&gt;=0.
# 
# Output parameters:
#     Q           -   first QColumns columns of matrix Q.
#                     Array whose index ranges within [0..M-1, 0..QColumns-1].
#                     If QColumns=0, array isn't changed.
# 
#   -- ALGLIB routine --
#      17.02.2010
#      Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: q = xalglib.cmatrixqrunpackq(a, m, n, tau, qcolumns)

</div></pre>
<a name='sub_cmatrixqrunpackr'></a><h3 class=pageheader><code>cmatrixqrunpackr</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Unpacking of matrix R from the QR decomposition of a matrix A
# 
# Input parameters:
#     A       -   matrices Q and R in compact form.
#                 Output of CMatrixQR subroutine.
#     M       -   number of rows in given matrix A. M&gt;=0.
#     N       -   number of columns in given matrix A. N&gt;=0.
# 
# Output parameters:
#     R       -   matrix R, array[0..M-1, 0..N-1].
# 
#   -- ALGLIB routine --
#      17.02.2010
#      Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: r = xalglib.cmatrixqrunpackr(a, m, n)

</div></pre>
<a name='sub_hmatrixtd'></a><h3 class=pageheader><code>hmatrixtd</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Reduction of a Hermitian matrix which is given  by  its  higher  or  lower
# triangular part to a real  tridiagonal  matrix  using  unitary  similarity
# transformation: Q'*A*Q = T.
# 
# Input parameters:
#     A       -   matrix to be transformed
#                 array with elements [0..N-1, 0..N-1].
#     N       -   size of matrix A.
#     IsUpper -   storage format. If IsUpper = True, then matrix A is  given
#                 by its upper triangle, and the lower triangle is not  used
#                 and not modified by the algorithm, and vice versa
#                 if IsUpper = False.
# 
# Output parameters:
#     A       -   matrices T and Q in  compact form (see lower)
#     Tau     -   array of factors which are forming matrices H(i)
#                 array with elements [0..N-2].
#     D       -   main diagonal of real symmetric matrix T.
#                 array with elements [0..N-1].
#     E       -   secondary diagonal of real symmetric matrix T.
#                 array with elements [0..N-2].
# 
# 
#   If IsUpper=True, the matrix Q is represented as a product of elementary
#   reflectors
# 
#      Q = H(n-2) . . . H(2) H(0).
# 
#   Each H(i) has the form
# 
#      H(i) = I - tau * v * v'
# 
#   where tau is a complex scalar, and v is a complex vector with
#   v(i+1:n-1) = 0, v(i) = 1, v(0:i-1) is stored on exit in
#   A(0:i-1,i+1), and tau in TAU(i).
# 
#   If IsUpper=False, the matrix Q is represented as a product of elementary
#   reflectors
# 
#      Q = H(0) H(2) . . . H(n-2).
# 
#   Each H(i) has the form
# 
#      H(i) = I - tau * v * v'
# 
#   where tau is a complex scalar, and v is a complex vector with
#   v(0:i) = 0, v(i+1) = 1, v(i+2:n-1) is stored on exit in A(i+2:n-1,i),
#   and tau in TAU(i).
# 
#   The contents of A on exit are illustrated by the following examples
#   with n = 5:
# 
#   if UPLO = 'U':                       if UPLO = 'L':
# 
#     (  d   e   v1  v2  v3 )              (  d                  )
#     (      d   e   v2  v3 )              (  e   d              )
#     (          d   e   v3 )              (  v0  e   d          )
#     (              d   e  )              (  v0  v1  e   d      )
#     (                  d  )              (  v0  v1  v2  e   d  )
# 
# where d and e denote diagonal and off-diagonal elements of T, and vi
# denotes an element of the vector defining H(i).
# 
#   -- LAPACK routine (version 3.0) --
#      Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
#      Courant Institute, Argonne National Lab, and Rice University
#      October 31, 1992
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: a, tau, d, e = xalglib.hmatrixtd(a, n, isupper)

</div></pre>
<a name='sub_hmatrixtdunpackq'></a><h3 class=pageheader><code>hmatrixtdunpackq</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Unpacking matrix Q which reduces a Hermitian matrix to a real  tridiagonal
# form.
# 
# Input parameters:
#     A       -   the result of a HMatrixTD subroutine
#     N       -   size of matrix A.
#     IsUpper -   storage format (a parameter of HMatrixTD subroutine)
#     Tau     -   the result of a HMatrixTD subroutine
# 
# Output parameters:
#     Q       -   transformation matrix.
#                 array with elements [0..N-1, 0..N-1].
# 
#   -- ALGLIB --
#      Copyright 2005-2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: q = xalglib.hmatrixtdunpackq(a, n, isupper, tau)

</div></pre>
<a name='sub_rmatrixbd'></a><h3 class=pageheader><code>rmatrixbd</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Reduction of a rectangular matrix to  bidiagonal form
# 
# The algorithm reduces the rectangular matrix A to  bidiagonal form by
# orthogonal transformations P and Q: A = Q*B*P.
# 
# Input parameters:
#     A       -   source matrix. array[0..M-1, 0..N-1]
#     M       -   number of rows in matrix A.
#     N       -   number of columns in matrix A.
# 
# Output parameters:
#     A       -   matrices Q, B, P in compact form (see below).
#     TauQ    -   scalar factors which are used to form matrix Q.
#     TauP    -   scalar factors which are used to form matrix P.
# 
# The main diagonal and one of the  secondary  diagonals  of  matrix  A  are
# replaced with bidiagonal  matrix  B.  Other  elements  contain  elementary
# reflections which form MxM matrix Q and NxN matrix P, respectively.
# 
# If M&gt;=N, B is the upper  bidiagonal  MxN  matrix  and  is  stored  in  the
# corresponding  elements  of  matrix  A.  Matrix  Q  is  represented  as  a
# product   of   elementary   reflections   Q = H(0)*H(1)*...*H(n-1),  where
# H(i) = 1-tau*v*v'. Here tau is a scalar which is stored  in  TauQ[i],  and
# vector v has the following  structure:  v(0:i-1)=0, v(i)=1, v(i+1:m-1)  is
# stored   in   elements   A(i+1:m-1,i).   Matrix   P  is  as  follows:  P =
# G(0)*G(1)*...*G(n-2), where G(i) = 1 - tau*u*u'. Tau is stored in TauP[i],
# u(0:i)=0, u(i+1)=1, u(i+2:n-1) is stored in elements A(i,i+2:n-1).
# 
# If M&lt;N, B is the  lower  bidiagonal  MxN  matrix  and  is  stored  in  the
# corresponding   elements  of  matrix  A.  Q = H(0)*H(1)*...*H(m-2),  where
# H(i) = 1 - tau*v*v', tau is stored in TauQ, v(0:i)=0, v(i+1)=1, v(i+2:m-1)
# is    stored    in   elements   A(i+2:m-1,i).    P = G(0)*G(1)*...*G(m-1),
# G(i) = 1-tau*u*u', tau is stored in  TauP,  u(0:i-1)=0, u(i)=1, u(i+1:n-1)
# is stored in A(i,i+1:n-1).
# 
# EXAMPLE:
# 
# m=6, n=5 (m &gt; n):               m=5, n=6 (m &lt; n):
# 
# (  d   e   u1  u1  u1 )         (  d   u1  u1  u1  u1  u1 )
# (  v1  d   e   u2  u2 )         (  e   d   u2  u2  u2  u2 )
# (  v1  v2  d   e   u3 )         (  v1  e   d   u3  u3  u3 )
# (  v1  v2  v3  d   e  )         (  v1  v2  e   d   u4  u4 )
# (  v1  v2  v3  v4  d  )         (  v1  v2  v3  e   d   u5 )
# (  v1  v2  v3  v4  v5 )
# 
# Here vi and ui are vectors which form H(i) and G(i), and d and e -
# are the diagonal and off-diagonal elements of matrix B.
# 
#   -- LAPACK routine (version 3.0) --
#      Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
#      Courant Institute, Argonne National Lab, and Rice University
#      September 30, 1994.
#      Sergey Bochkanov, ALGLIB project, translation from FORTRAN to
#      pseudocode, 2007-2010.
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: a, tauq, taup = xalglib.rmatrixbd(a, m, n)

</div></pre>
<a name='sub_rmatrixbdmultiplybyp'></a><h3 class=pageheader><code>rmatrixbdmultiplybyp</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Multiplication by matrix P which reduces matrix A to  bidiagonal form.
# 
# The algorithm allows pre- or post-multiply by P or P'.
# 
# Input parameters:
#     QP          -   matrices Q and P in compact form.
#                     Output of RMatrixBD subroutine.
#     M           -   number of rows in matrix A.
#     N           -   number of columns in matrix A.
#     TAUP        -   scalar factors which are used to form P.
#                     Output of RMatrixBD subroutine.
#     Z           -   multiplied matrix.
#                     Array whose indexes range within [0..ZRows-1,0..ZColumns-1].
#     ZRows       -   number of rows in matrix Z. If FromTheRight=False,
#                     ZRows=N, otherwise ZRows can be arbitrary.
#     ZColumns    -   number of columns in matrix Z. If FromTheRight=True,
#                     ZColumns=N, otherwise ZColumns can be arbitrary.
#     FromTheRight -  pre- or post-multiply.
#     DoTranspose -   multiply by P or P'.
# 
# Output parameters:
#     Z - product of Z and P.
#                 Array whose indexes range within [0..ZRows-1,0..ZColumns-1].
#                 If ZRows=0 or ZColumns=0, the array is not modified.
# 
#   -- ALGLIB --
#      2005-2010
#      Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: z = xalglib.rmatrixbdmultiplybyp(qp, m, n, taup, z, zrows, zcolumns, fromtheright, dotranspose)

</div></pre>
<a name='sub_rmatrixbdmultiplybyq'></a><h3 class=pageheader><code>rmatrixbdmultiplybyq</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Multiplication by matrix Q which reduces matrix A to  bidiagonal form.
# 
# The algorithm allows pre- or post-multiply by Q or Q'.
# 
# Input parameters:
#     QP          -   matrices Q and P in compact form.
#                     Output of ToBidiagonal subroutine.
#     M           -   number of rows in matrix A.
#     N           -   number of columns in matrix A.
#     TAUQ        -   scalar factors which are used to form Q.
#                     Output of ToBidiagonal subroutine.
#     Z           -   multiplied matrix.
#                     array[0..ZRows-1,0..ZColumns-1]
#     ZRows       -   number of rows in matrix Z. If FromTheRight=False,
#                     ZRows=M, otherwise ZRows can be arbitrary.
#     ZColumns    -   number of columns in matrix Z. If FromTheRight=True,
#                     ZColumns=M, otherwise ZColumns can be arbitrary.
#     FromTheRight -  pre- or post-multiply.
#     DoTranspose -   multiply by Q or Q'.
# 
# Output parameters:
#     Z           -   product of Z and Q.
#                     Array[0..ZRows-1,0..ZColumns-1]
#                     If ZRows=0 or ZColumns=0, the array is not modified.
# 
#   -- ALGLIB --
#      2005-2010
#      Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: z = xalglib.rmatrixbdmultiplybyq(qp, m, n, tauq, z, zrows, zcolumns, fromtheright, dotranspose)

</div></pre>
<a name='sub_rmatrixbdunpackdiagonals'></a><h3 class=pageheader><code>rmatrixbdunpackdiagonals</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Unpacking of the main and secondary diagonals of bidiagonal decomposition
# of matrix A.
# 
# Input parameters:
#     B   -   output of RMatrixBD subroutine.
#     M   -   number of rows in matrix B.
#     N   -   number of columns in matrix B.
# 
# Output parameters:
#     IsUpper -   True, if the matrix is upper bidiagonal.
#                 otherwise IsUpper is False.
#     D       -   the main diagonal.
#                 Array whose index ranges within [0..Min(M,N)-1].
#     E       -   the secondary diagonal (upper or lower, depending on
#                 the value of IsUpper).
#                 Array index ranges within [0..Min(M,N)-1], the last
#                 element is not used.
# 
#   -- ALGLIB --
#      2005-2010
#      Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: isupper, d, e = xalglib.rmatrixbdunpackdiagonals(b, m, n)

</div></pre>
<a name='sub_rmatrixbdunpackpt'></a><h3 class=pageheader><code>rmatrixbdunpackpt</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Unpacking matrix P which reduces matrix A to bidiagonal form.
# The subroutine returns transposed matrix P.
# 
# Input parameters:
#     QP      -   matrices Q and P in compact form.
#                 Output of ToBidiagonal subroutine.
#     M       -   number of rows in matrix A.
#     N       -   number of columns in matrix A.
#     TAUP    -   scalar factors which are used to form P.
#                 Output of ToBidiagonal subroutine.
#     PTRows  -   required number of rows of matrix P^T. N &gt;= PTRows &gt;= 0.
# 
# Output parameters:
#     PT      -   first PTRows columns of matrix P^T
#                 Array[0..PTRows-1, 0..N-1]
#                 If PTRows=0, the array is not modified.
# 
#   -- ALGLIB --
#      2005-2010
#      Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: pt = xalglib.rmatrixbdunpackpt(qp, m, n, taup, ptrows)

</div></pre>
<a name='sub_rmatrixbdunpackq'></a><h3 class=pageheader><code>rmatrixbdunpackq</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Unpacking matrix Q which reduces a matrix to bidiagonal form.
# 
# Input parameters:
#     QP          -   matrices Q and P in compact form.
#                     Output of ToBidiagonal subroutine.
#     M           -   number of rows in matrix A.
#     N           -   number of columns in matrix A.
#     TAUQ        -   scalar factors which are used to form Q.
#                     Output of ToBidiagonal subroutine.
#     QColumns    -   required number of columns in matrix Q.
#                     M&gt;=QColumns&gt;=0.
# 
# Output parameters:
#     Q           -   first QColumns columns of matrix Q.
#                     Array[0..M-1, 0..QColumns-1]
#                     If QColumns=0, the array is not modified.
# 
#   -- ALGLIB --
#      2005-2010
#      Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: q = xalglib.rmatrixbdunpackq(qp, m, n, tauq, qcolumns)

</div></pre>
<a name='sub_rmatrixhessenberg'></a><h3 class=pageheader><code>rmatrixhessenberg</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Reduction of a square matrix to  upper Hessenberg form: Q'*A*Q = H,
# where Q is an orthogonal matrix, H - Hessenberg matrix.
# 
# Input parameters:
#     A       -   matrix A with elements [0..N-1, 0..N-1]
#     N       -   size of matrix A.
# 
# Output parameters:
#     A       -   matrices Q and P in  compact form (see below).
#     Tau     -   array of scalar factors which are used to form matrix Q.
#                 Array whose index ranges within [0..N-2]
# 
# Matrix H is located on the main diagonal, on the lower secondary  diagonal
# and above the main diagonal of matrix A. The elements which are used to
# form matrix Q are situated in array Tau and below the lower secondary
# diagonal of matrix A as follows:
# 
# Matrix Q is represented as a product of elementary reflections
# 
# Q = H(0)*H(2)*...*H(n-2),
# 
# where each H(i) is given by
# 
# H(i) = 1 - tau * v * (v^T)
# 
# where tau is a scalar stored in Tau[I]; v - is a real vector,
# so that v(0:i) = 0, v(i+1) = 1, v(i+2:n-1) stored in A(i+2:n-1,i).
# 
#   -- LAPACK routine (version 3.0) --
#      Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
#      Courant Institute, Argonne National Lab, and Rice University
#      October 31, 1992
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: a, tau = xalglib.rmatrixhessenberg(a, n)

</div></pre>
<a name='sub_rmatrixhessenbergunpackh'></a><h3 class=pageheader><code>rmatrixhessenbergunpackh</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Unpacking matrix H (the result of matrix A reduction to upper Hessenberg form)
# 
# Input parameters:
#     A   -   output of RMatrixHessenberg subroutine.
#     N   -   size of matrix A.
# 
# Output parameters:
#     H   -   matrix H. Array whose indexes range within [0..N-1, 0..N-1].
# 
#   -- ALGLIB --
#      2005-2010
#      Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: h = xalglib.rmatrixhessenbergunpackh(a, n)

</div></pre>
<a name='sub_rmatrixhessenbergunpackq'></a><h3 class=pageheader><code>rmatrixhessenbergunpackq</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Unpacking matrix Q which reduces matrix A to upper Hessenberg form
# 
# Input parameters:
#     A   -   output of RMatrixHessenberg subroutine.
#     N   -   size of matrix A.
#     Tau -   scalar factors which are used to form Q.
#             Output of RMatrixHessenberg subroutine.
# 
# Output parameters:
#     Q   -   matrix Q.
#             Array whose indexes range within [0..N-1, 0..N-1].
# 
#   -- ALGLIB --
#      2005-2010
#      Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: q = xalglib.rmatrixhessenbergunpackq(a, n, tau)

</div></pre>
<a name='sub_rmatrixlq'></a><h3 class=pageheader><code>rmatrixlq</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# LQ decomposition of a rectangular matrix of size MxN
# 
# Input parameters:
#     A   -   matrix A whose indexes range within [0..M-1, 0..N-1].
#     M   -   number of rows in matrix A.
#     N   -   number of columns in matrix A.
# 
# Output parameters:
#     A   -   matrices L and Q in compact form (see below)
#     Tau -   array of scalar factors which are used to form
#             matrix Q. Array whose index ranges within [0..Min(M,N)-1].
# 
# Matrix A is represented as A = LQ, where Q is an orthogonal matrix of size
# MxM, L - lower triangular (or lower trapezoid) matrix of size M x N.
# 
# The elements of matrix L are located on and below  the  main  diagonal  of
# matrix A. The elements which are located in Tau array and above  the  main
# diagonal of matrix A are used to form matrix Q as follows:
# 
# Matrix Q is represented as a product of elementary reflections
# 
# Q = H(k-1)*H(k-2)*...*H(1)*H(0),
# 
# where k = min(m,n), and each H(i) is of the form
# 
# H(i) = 1 - tau * v * (v^T)
# 
# where tau is a scalar stored in Tau[I]; v - real vector, so that v(0:i-1)=0,
# v(i) = 1, v(i+1:n-1) stored in A(i,i+1:n-1).
# 
#   -- ALGLIB routine --
#      17.02.2010
#      Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: a, tau = xalglib.rmatrixlq(a, m, n)

</div></pre>
<a name='sub_rmatrixlqunpackl'></a><h3 class=pageheader><code>rmatrixlqunpackl</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Unpacking of matrix L from the LQ decomposition of a matrix A
# 
# Input parameters:
#     A       -   matrices Q and L in compact form.
#                 Output of RMatrixLQ subroutine.
#     M       -   number of rows in given matrix A. M&gt;=0.
#     N       -   number of columns in given matrix A. N&gt;=0.
# 
# Output parameters:
#     L       -   matrix L, array[0..M-1, 0..N-1].
# 
#   -- ALGLIB routine --
#      17.02.2010
#      Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: l = xalglib.rmatrixlqunpackl(a, m, n)

</div></pre>
<a name='sub_rmatrixlqunpackq'></a><h3 class=pageheader><code>rmatrixlqunpackq</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Partial unpacking of matrix Q from the LQ decomposition of a matrix A
# 
# Input parameters:
#     A       -   matrices L and Q in compact form.
#                 Output of RMatrixLQ subroutine.
#     M       -   number of rows in given matrix A. M&gt;=0.
#     N       -   number of columns in given matrix A. N&gt;=0.
#     Tau     -   scalar factors which are used to form Q.
#                 Output of the RMatrixLQ subroutine.
#     QRows   -   required number of rows in matrix Q. N&gt;=QRows&gt;=0.
# 
# Output parameters:
#     Q       -   first QRows rows of matrix Q. Array whose indexes range
#                 within [0..QRows-1, 0..N-1]. If QRows=0, the array remains
#                 unchanged.
# 
#   -- ALGLIB routine --
#      17.02.2010
#      Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: q = xalglib.rmatrixlqunpackq(a, m, n, tau, qrows)

</div></pre>
<a name='sub_rmatrixqr'></a><h3 class=pageheader><code>rmatrixqr</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# QR decomposition of a rectangular matrix of size MxN
# 
# Input parameters:
#     A   -   matrix A whose indexes range within [0..M-1, 0..N-1].
#     M   -   number of rows in matrix A.
#     N   -   number of columns in matrix A.
# 
# Output parameters:
#     A   -   matrices Q and R in compact form (see below).
#     Tau -   array of scalar factors which are used to form
#             matrix Q. Array whose index ranges within [0.. Min(M-1,N-1)].
# 
# Matrix A is represented as A = QR, where Q is an orthogonal matrix of size
# MxM, R - upper triangular (or upper trapezoid) matrix of size M x N.
# 
# The elements of matrix R are located on and above the main diagonal of
# matrix A. The elements which are located in Tau array and below the main
# diagonal of matrix A are used to form matrix Q as follows:
# 
# Matrix Q is represented as a product of elementary reflections
# 
# Q = H(0)*H(2)*...*H(k-1),
# 
# where k = min(m,n), and each H(i) is in the form
# 
# H(i) = 1 - tau * v * (v^T)
# 
# where tau is a scalar stored in Tau[I]; v - real vector,
# so that v(0:i-1) = 0, v(i) = 1, v(i+1:m-1) stored in A(i+1:m-1,i).
# 
#   -- ALGLIB routine --
#      17.02.2010
#      Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: a, tau = xalglib.rmatrixqr(a, m, n)

</div></pre>
<a name='sub_rmatrixqrunpackq'></a><h3 class=pageheader><code>rmatrixqrunpackq</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Partial unpacking of matrix Q from the QR decomposition of a matrix A
# 
# Input parameters:
#     A       -   matrices Q and R in compact form.
#                 Output of RMatrixQR subroutine.
#     M       -   number of rows in given matrix A. M&gt;=0.
#     N       -   number of columns in given matrix A. N&gt;=0.
#     Tau     -   scalar factors which are used to form Q.
#                 Output of the RMatrixQR subroutine.
#     QColumns -  required number of columns of matrix Q. M&gt;=QColumns&gt;=0.
# 
# Output parameters:
#     Q       -   first QColumns columns of matrix Q.
#                 Array whose indexes range within [0..M-1, 0..QColumns-1].
#                 If QColumns=0, the array remains unchanged.
# 
#   -- ALGLIB routine --
#      17.02.2010
#      Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: q = xalglib.rmatrixqrunpackq(a, m, n, tau, qcolumns)

</div></pre>
<a name='sub_rmatrixqrunpackr'></a><h3 class=pageheader><code>rmatrixqrunpackr</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Unpacking of matrix R from the QR decomposition of a matrix A
# 
# Input parameters:
#     A       -   matrices Q and R in compact form.
#                 Output of RMatrixQR subroutine.
#     M       -   number of rows in given matrix A. M&gt;=0.
#     N       -   number of columns in given matrix A. N&gt;=0.
# 
# Output parameters:
#     R       -   matrix R, array[0..M-1, 0..N-1].
# 
#   -- ALGLIB routine --
#      17.02.2010
#      Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: r = xalglib.rmatrixqrunpackr(a, m, n)

</div></pre>
<a name='sub_smatrixtd'></a><h3 class=pageheader><code>smatrixtd</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Reduction of a symmetric matrix which is given by its higher or lower
# triangular part to a tridiagonal matrix using orthogonal similarity
# transformation: Q'*A*Q=T.
# 
# Input parameters:
#     A       -   matrix to be transformed
#                 array with elements [0..N-1, 0..N-1].
#     N       -   size of matrix A.
#     IsUpper -   storage format. If IsUpper = True, then matrix A is given
#                 by its upper triangle, and the lower triangle is not used
#                 and not modified by the algorithm, and vice versa
#                 if IsUpper = False.
# 
# Output parameters:
#     A       -   matrices T and Q in  compact form (see lower)
#     Tau     -   array of factors which are forming matrices H(i)
#                 array with elements [0..N-2].
#     D       -   main diagonal of symmetric matrix T.
#                 array with elements [0..N-1].
#     E       -   secondary diagonal of symmetric matrix T.
#                 array with elements [0..N-2].
# 
# 
#   If IsUpper=True, the matrix Q is represented as a product of elementary
#   reflectors
# 
#      Q = H(n-2) . . . H(2) H(0).
# 
#   Each H(i) has the form
# 
#      H(i) = I - tau * v * v'
# 
#   where tau is a real scalar, and v is a real vector with
#   v(i+1:n-1) = 0, v(i) = 1, v(0:i-1) is stored on exit in
#   A(0:i-1,i+1), and tau in TAU(i).
# 
#   If IsUpper=False, the matrix Q is represented as a product of elementary
#   reflectors
# 
#      Q = H(0) H(2) . . . H(n-2).
# 
#   Each H(i) has the form
# 
#      H(i) = I - tau * v * v'
# 
#   where tau is a real scalar, and v is a real vector with
#   v(0:i) = 0, v(i+1) = 1, v(i+2:n-1) is stored on exit in A(i+2:n-1,i),
#   and tau in TAU(i).
# 
#   The contents of A on exit are illustrated by the following examples
#   with n = 5:
# 
#   if UPLO = 'U':                       if UPLO = 'L':
# 
#     (  d   e   v1  v2  v3 )              (  d                  )
#     (      d   e   v2  v3 )              (  e   d              )
#     (          d   e   v3 )              (  v0  e   d          )
#     (              d   e  )              (  v0  v1  e   d      )
#     (                  d  )              (  v0  v1  v2  e   d  )
# 
#   where d and e denote diagonal and off-diagonal elements of T, and vi
#   denotes an element of the vector defining H(i).
# 
#   -- LAPACK routine (version 3.0) --
#      Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
#      Courant Institute, Argonne National Lab, and Rice University
#      October 31, 1992
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: a, tau, d, e = xalglib.smatrixtd(a, n, isupper)

</div></pre>
<a name='sub_smatrixtdunpackq'></a><h3 class=pageheader><code>smatrixtdunpackq</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Unpacking matrix Q which reduces symmetric matrix to a tridiagonal
# form.
# 
# Input parameters:
#     A       -   the result of a SMatrixTD subroutine
#     N       -   size of matrix A.
#     IsUpper -   storage format (a parameter of SMatrixTD subroutine)
#     Tau     -   the result of a SMatrixTD subroutine
# 
# Output parameters:
#     Q       -   transformation matrix.
#                 array with elements [0..N-1, 0..N-1].
# 
#   -- ALGLIB --
#      Copyright 2005-2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: q = xalglib.smatrixtdunpackq(a, n, isupper, tau)

</div></pre>
<a name=unit_pca></a><h2 class=pageheader><code>pca</code> module</h2>
<div class=pagecontent>
<h3 class=pageheader>Functions</h3>
<a href='#sub_pcabuildbasis' class=toc>pcabuildbasis</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='sub_pcabuildbasis'></a><h3 class=pageheader><code>pcabuildbasis</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Principal components analysis
# 
# Subroutine  builds  orthogonal  basis  where  first  axis  corresponds  to
# direction with maximum variance, second axis maximizes variance in subspace
# orthogonal to first axis and so on.
# 
# It should be noted that, unlike LDA, PCA does not use class labels.
# 
# INPUT PARAMETERS:
#     X           -   dataset, array[0..NPoints-1,0..NVars-1].
#                     matrix contains ONLY INDEPENDENT VARIABLES.
#     NPoints     -   dataset size, NPoints&gt;=0
#     NVars       -   number of independent variables, NVars&gt;=1
# 
#  :
#     Info        -   return code:
#                     * -4, if SVD subroutine haven't converged
#                     * -1, if wrong parameters has been passed (NPoints&lt;0,
#                           NVars&lt;1)
#                     *  1, if task is solved
#     S2          -   array[0..NVars-1]. variance values corresponding
#                     to basis vectors.
#     V           -   array[0..NVars-1,0..NVars-1]
#                     matrix, whose columns store basis vectors.
# 
#   -- ALGLIB --
#      Copyright 25.08.2008 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: info, s2, v = xalglib.pcabuildbasis(x, npoints, nvars)

</div></pre>
<a name=unit_poissondistr></a><h2 class=pageheader><code>poissondistr</code> module</h2>
<div class=pagecontent>
<h3 class=pageheader>Functions</h3>
<a href='#sub_invpoissondistribution' class=toc>invpoissondistribution</a><br>
<a href='#sub_poissoncdistribution' class=toc>poissoncdistribution</a><br>
<a href='#sub_poissondistribution' class=toc>poissondistribution</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='sub_invpoissondistribution'></a><h3 class=pageheader><code>invpoissondistribution</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Inverse Poisson distribution
# 
# Finds the Poisson variable x such that the integral
# from 0 to x of the Poisson density is equal to the
# given probability y.
# 
# This is accomplished using the inverse gamma integral
# function and the relation
# 
#    m = igami( k+1, y ).
# 
# ACCURACY:
# 
# See inverse incomplete gamma function
# 
# Cephes Math Library Release 2.8:  June, 2000
# Copyright 1984, 1987, 1995, 2000 by Stephen L. Moshier
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.invpoissondistribution(k, y)

</div></pre>
<a name='sub_poissoncdistribution'></a><h3 class=pageheader><code>poissoncdistribution</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Complemented Poisson distribution
# 
# Returns the sum of the terms k+1 to infinity of the Poisson
# distribution:
# 
#  inf.       j
#   --   -m  m
#   &gt;   e    --
#   --       j!
#  j=k+1
# 
# The terms are not summed directly; instead the incomplete
# gamma integral is employed, according to the formula
# 
# y = pdtrc( k, m ) = igam( k+1, m ).
# 
# The arguments must both be positive.
# 
# ACCURACY:
# 
# See incomplete gamma function
# 
# Cephes Math Library Release 2.8:  June, 2000
# Copyright 1984, 1987, 1995, 2000 by Stephen L. Moshier
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.poissoncdistribution(k, m)

</div></pre>
<a name='sub_poissondistribution'></a><h3 class=pageheader><code>poissondistribution</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Poisson distribution
# 
# Returns the sum of the first k+1 terms of the Poisson
# distribution:
# 
#   k         j
#   --   -m  m
#   &gt;   e    --
#   --       j!
#  j=0
# 
# The terms are not summed directly; instead the incomplete
# gamma integral is employed, according to the relation
# 
# y = pdtr( k, m ) = igamc( k+1, m ).
# 
# The arguments must both be positive.
# ACCURACY:
# 
# See incomplete gamma function
# 
# Cephes Math Library Release 2.8:  June, 2000
# Copyright 1984, 1987, 1995, 2000 by Stephen L. Moshier
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.poissondistribution(k, m)

</div></pre>
<a name=unit_polint></a><h2 class=pageheader><code>polint</code> module</h2>
<div class=pagecontent>
<h3 class=pageheader>Functions</h3>
<a href='#sub_polynomialbar2cheb' class=toc>polynomialbar2cheb</a><br>
<a href='#sub_polynomialbar2pow' class=toc>polynomialbar2pow</a><br>
<a href='#sub_polynomialbuild' class=toc>polynomialbuild</a><br>
<a href='#sub_polynomialbuildcheb1' class=toc>polynomialbuildcheb1</a><br>
<a href='#sub_polynomialbuildcheb2' class=toc>polynomialbuildcheb2</a><br>
<a href='#sub_polynomialbuildeqdist' class=toc>polynomialbuildeqdist</a><br>
<a href='#sub_polynomialcalccheb1' class=toc>polynomialcalccheb1</a><br>
<a href='#sub_polynomialcalccheb2' class=toc>polynomialcalccheb2</a><br>
<a href='#sub_polynomialcalceqdist' class=toc>polynomialcalceqdist</a><br>
<a href='#sub_polynomialcheb2bar' class=toc>polynomialcheb2bar</a><br>
<a href='#sub_polynomialpow2bar' class=toc>polynomialpow2bar</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
<tr align=left valign=top><td><a href='#example_polint_d_calcdiff' class=toc>polint_d_calcdiff</a></td><td width=15>&nbsp;</td><td>Interpolation and differentiation using barycentric representation</td></tr>
<tr align=left valign=top><td><a href='#example_polint_d_conv' class=toc>polint_d_conv</a></td><td width=15>&nbsp;</td><td>Conversion between power basis and barycentric representation</td></tr>
<tr align=left valign=top><td><a href='#example_polint_d_spec' class=toc>polint_d_spec</a></td><td width=15>&nbsp;</td><td>Polynomial interpolation on special grids (equidistant, Chebyshev I/II)</td></tr>
</table></div>
<a name='sub_polynomialbar2cheb'></a><h3 class=pageheader><code>polynomialbar2cheb</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Conversion from barycentric representation to Chebyshev basis.
# This function has O(N^2) complexity.
# 
# INPUT PARAMETERS:
#     P   -   polynomial in barycentric form
#     A,B -   base interval for Chebyshev polynomials (see below)
#             A&lt;&gt;B
# 
# OUTPUT PARAMETERS
#     T   -   coefficients of Chebyshev representation;
#             P(x) = sum { T[i]*Ti(2*(x-A)/(B-A)-1), i=0..N-1 },
#             where Ti - I-th Chebyshev polynomial.
# 
# NOTES:
#     barycentric interpolant passed as P may be either polynomial  obtained
#     from  polynomial  interpolation/ fitting or rational function which is
#     NOT polynomial. We can't distinguish between these two cases, and this
#     algorithm just tries to work assuming that P IS a polynomial.  If not,
#     algorithm will return results, but they won't have any meaning.
# 
#   -- ALGLIB --
#      Copyright 30.09.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: t = xalglib.polynomialbar2cheb(p, a, b)

</div></pre>
<a name='sub_polynomialbar2pow'></a><h3 class=pageheader><code>polynomialbar2pow</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Conversion from barycentric representation to power basis.
# This function has O(N^2) complexity.
# 
# INPUT PARAMETERS:
#     P   -   polynomial in barycentric form
#     C   -   offset (see below); 0.0 is used as default value.
#     S   -   scale (see below);  1.0 is used as default value. S&lt;&gt;0.
# 
# OUTPUT PARAMETERS
#     A   -   coefficients, P(x) = sum { A[i]*((X-C)/S)^i, i=0..N-1 }
#     N   -   number of coefficients (polynomial degree plus 1)
# 
# NOTES:
# 1.  this function accepts offset and scale, which can be  set  to  improve
#     numerical properties of polynomial. For example, if P was obtained  as
#     result of interpolation on [-1,+1],  you  can  set  C=0  and  S=1  and
#     represent  P  as sum of 1, x, x^2, x^3 and so on. In most cases you it
#     is exactly what you need.
# 
#     However, if your interpolation model was built on [999,1001], you will
#     see significant growth of numerical errors when using {1, x, x^2, x^3}
#     as basis. Representing P as sum of 1, (x-1000), (x-1000)^2, (x-1000)^3
#     will be better option. Such representation can be  obtained  by  using
#     1000.0 as offset C and 1.0 as scale S.
# 
# 2.  power basis is ill-conditioned and tricks described above can't  solve
#     this problem completely. This function  will  return  coefficients  in
#     any  case,  but  for  N&gt;8  they  will  become unreliable. However, N's
#     less than 5 are pretty safe.
# 
# 3.  barycentric interpolant passed as P may be either polynomial  obtained
#     from  polynomial  interpolation/ fitting or rational function which is
#     NOT polynomial. We can't distinguish between these two cases, and this
#     algorithm just tries to work assuming that P IS a polynomial.  If not,
#     algorithm will return results, but they won't have any meaning.
# 
#   -- ALGLIB --
#      Copyright 30.09.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: a = xalglib.polynomialbar2pow(p, c, s)
SYNTAX: a = xalglib.polynomialbar2pow(p)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_polint_d_conv' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_polynomialbuild'></a><h3 class=pageheader><code>polynomialbuild</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Lagrange intepolant: generation of the model on the general grid.
# This function has O(N^2) complexity.
# 
# INPUT PARAMETERS:
#     X   -   abscissas, array[0..N-1]
#     Y   -   function values, array[0..N-1]
#     N   -   number of points, N&gt;=1
# 
# OUTPUT PARAMETERS
#     P   -   barycentric model which represents Lagrange interpolant
#             (see ratint unit info and BarycentricCalc() description for
#             more information).
# 
#   -- ALGLIB --
#      Copyright 02.12.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: p = xalglib.polynomialbuild(x, y, n)
SYNTAX: p = xalglib.polynomialbuild(x, y)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_polint_d_calcdiff' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_polynomialbuildcheb1'></a><h3 class=pageheader><code>polynomialbuildcheb1</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Lagrange intepolant on Chebyshev grid (first kind).
# This function has O(N) complexity.
# 
# INPUT PARAMETERS:
#     A   -   left boundary of [A,B]
#     B   -   right boundary of [A,B]
#     Y   -   function values at the nodes, array[0..N-1],
#             Y[I] = Y(0.5*(B+A) + 0.5*(B-A)*Cos(PI*(2*i+1)/(2*n)))
#     N   -   number of points, N&gt;=1
#             for N=1 a constant model is constructed.
# 
# OUTPUT PARAMETERS
#     P   -   barycentric model which represents Lagrange interpolant
#             (see ratint unit info and BarycentricCalc() description for
#             more information).
# 
#   -- ALGLIB --
#      Copyright 03.12.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: p = xalglib.polynomialbuildcheb1(a, b, y, n)
SYNTAX: p = xalglib.polynomialbuildcheb1(a, b, y)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_polint_d_spec' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_polynomialbuildcheb2'></a><h3 class=pageheader><code>polynomialbuildcheb2</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Lagrange intepolant on Chebyshev grid (second kind).
# This function has O(N) complexity.
# 
# INPUT PARAMETERS:
#     A   -   left boundary of [A,B]
#     B   -   right boundary of [A,B]
#     Y   -   function values at the nodes, array[0..N-1],
#             Y[I] = Y(0.5*(B+A) + 0.5*(B-A)*Cos(PI*i/(n-1)))
#     N   -   number of points, N&gt;=1
#             for N=1 a constant model is constructed.
# 
# OUTPUT PARAMETERS
#     P   -   barycentric model which represents Lagrange interpolant
#             (see ratint unit info and BarycentricCalc() description for
#             more information).
# 
#   -- ALGLIB --
#      Copyright 03.12.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: p = xalglib.polynomialbuildcheb2(a, b, y, n)
SYNTAX: p = xalglib.polynomialbuildcheb2(a, b, y)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_polint_d_spec' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_polynomialbuildeqdist'></a><h3 class=pageheader><code>polynomialbuildeqdist</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Lagrange intepolant: generation of the model on equidistant grid.
# This function has O(N) complexity.
# 
# INPUT PARAMETERS:
#     A   -   left boundary of [A,B]
#     B   -   right boundary of [A,B]
#     Y   -   function values at the nodes, array[0..N-1]
#     N   -   number of points, N&gt;=1
#             for N=1 a constant model is constructed.
# 
# OUTPUT PARAMETERS
#     P   -   barycentric model which represents Lagrange interpolant
#             (see ratint unit info and BarycentricCalc() description for
#             more information).
# 
#   -- ALGLIB --
#      Copyright 03.12.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: p = xalglib.polynomialbuildeqdist(a, b, y, n)
SYNTAX: p = xalglib.polynomialbuildeqdist(a, b, y)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_polint_d_spec' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_polynomialcalccheb1'></a><h3 class=pageheader><code>polynomialcalccheb1</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Fast polynomial interpolation function on Chebyshev points (first kind)
# with O(N) complexity.
# 
# INPUT PARAMETERS:
#     A   -   left boundary of [A,B]
#     B   -   right boundary of [A,B]
#     F   -   function values, array[0..N-1]
#     N   -   number of points on Chebyshev grid (first kind),
#             X[i] = 0.5*(B+A) + 0.5*(B-A)*Cos(PI*(2*i+1)/(2*n))
#             for N=1 a constant model is constructed.
#     T   -   position where P(x) is calculated
# 
# RESULT
#     value of the Lagrange interpolant at T
# 
# IMPORTANT
#     this function provides fast interface which is not overflow-safe
#     nor it is very precise.
#     the best option is to use  PolIntBuildCheb1()/BarycentricCalc()
#     subroutines unless you are pretty sure that your data will not result
#     in overflow.
# 
#   -- ALGLIB --
#      Copyright 02.12.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.polynomialcalccheb1(a, b, f, n, t)
SYNTAX: result = xalglib.polynomialcalccheb1(a, b, f, t)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_polint_d_spec' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_polynomialcalccheb2'></a><h3 class=pageheader><code>polynomialcalccheb2</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Fast polynomial interpolation function on Chebyshev points (second kind)
# with O(N) complexity.
# 
# INPUT PARAMETERS:
#     A   -   left boundary of [A,B]
#     B   -   right boundary of [A,B]
#     F   -   function values, array[0..N-1]
#     N   -   number of points on Chebyshev grid (second kind),
#             X[i] = 0.5*(B+A) + 0.5*(B-A)*Cos(PI*i/(n-1))
#             for N=1 a constant model is constructed.
#     T   -   position where P(x) is calculated
# 
# RESULT
#     value of the Lagrange interpolant at T
# 
# IMPORTANT
#     this function provides fast interface which is not overflow-safe
#     nor it is very precise.
#     the best option is to use PolIntBuildCheb2()/BarycentricCalc()
#     subroutines unless you are pretty sure that your data will not result
#     in overflow.
# 
#   -- ALGLIB --
#      Copyright 02.12.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.polynomialcalccheb2(a, b, f, n, t)
SYNTAX: result = xalglib.polynomialcalccheb2(a, b, f, t)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_polint_d_spec' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_polynomialcalceqdist'></a><h3 class=pageheader><code>polynomialcalceqdist</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Fast equidistant polynomial interpolation function with O(N) complexity
# 
# INPUT PARAMETERS:
#     A   -   left boundary of [A,B]
#     B   -   right boundary of [A,B]
#     F   -   function values, array[0..N-1]
#     N   -   number of points on equidistant grid, N&gt;=1
#             for N=1 a constant model is constructed.
#     T   -   position where P(x) is calculated
# 
# RESULT
#     value of the Lagrange interpolant at T
# 
# IMPORTANT
#     this function provides fast interface which is not overflow-safe
#     nor it is very precise.
#     the best option is to use  PolynomialBuildEqDist()/BarycentricCalc()
#     subroutines unless you are pretty sure that your data will not result
#     in overflow.
# 
#   -- ALGLIB --
#      Copyright 02.12.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.polynomialcalceqdist(a, b, f, n, t)
SYNTAX: result = xalglib.polynomialcalceqdist(a, b, f, t)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_polint_d_spec' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_polynomialcheb2bar'></a><h3 class=pageheader><code>polynomialcheb2bar</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Conversion from Chebyshev basis to barycentric representation.
# This function has O(N^2) complexity.
# 
# INPUT PARAMETERS:
#     T   -   coefficients of Chebyshev representation;
#             P(x) = sum { T[i]*Ti(2*(x-A)/(B-A)-1), i=0..N },
#             where Ti - I-th Chebyshev polynomial.
#     N   -   number of coefficients:
#             * if given, only leading N elements of T are used
#             * if not given, automatically determined from size of T
#     A,B -   base interval for Chebyshev polynomials (see above)
#             A&lt;B
# 
# OUTPUT PARAMETERS
#     P   -   polynomial in barycentric form
# 
#   -- ALGLIB --
#      Copyright 30.09.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: p = xalglib.polynomialcheb2bar(t, n, a, b)
SYNTAX: p = xalglib.polynomialcheb2bar(t, a, b)

</div></pre>
<a name='sub_polynomialpow2bar'></a><h3 class=pageheader><code>polynomialpow2bar</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Conversion from power basis to barycentric representation.
# This function has O(N^2) complexity.
# 
# INPUT PARAMETERS:
#     A   -   coefficients, P(x) = sum { A[i]*((X-C)/S)^i, i=0..N-1 }
#     N   -   number of coefficients (polynomial degree plus 1)
#             * if given, only leading N elements of A are used
#             * if not given, automatically determined from size of A
#     C   -   offset (see below); 0.0 is used as default value.
#     S   -   scale (see below);  1.0 is used as default value. S&lt;&gt;0.
# 
# OUTPUT PARAMETERS
#     P   -   polynomial in barycentric form
# 
# 
# NOTES:
# 1.  this function accepts offset and scale, which can be  set  to  improve
#     numerical properties of polynomial. For example, if you interpolate on
#     [-1,+1],  you  can  set C=0 and S=1 and convert from sum of 1, x, x^2,
#     x^3 and so on. In most cases you it is exactly what you need.
# 
#     However, if your interpolation model was built on [999,1001], you will
#     see significant growth of numerical errors when using {1, x, x^2, x^3}
#     as  input  basis.  Converting  from  sum  of  1, (x-1000), (x-1000)^2,
#     (x-1000)^3 will be better option (you have to specify 1000.0 as offset
#     C and 1.0 as scale S).
# 
# 2.  power basis is ill-conditioned and tricks described above can't  solve
#     this problem completely. This function  will  return barycentric model
#     in any case, but for N&gt;8 accuracy well degrade. However, N's less than
#     5 are pretty safe.
# 
#   -- ALGLIB --
#      Copyright 30.09.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: p = xalglib.polynomialpow2bar(a, n, c, s)
SYNTAX: p = xalglib.polynomialpow2bar(a)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_polint_d_conv' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='example_polint_d_calcdiff'></a><h3 class=pageheader>polint_d_calcdiff example</h3>
<pre class=source>
import xalglib



<font color=darkcyan>#</font>
<font color=darkcyan># Here we demonstrate polynomial interpolation and differentiation</font>
<font color=darkcyan># of y=x^2-x sampled at [0,1,2]. Barycentric representation of polynomial is used.</font>
<font color=darkcyan>#</font>
x = [0,1,2]
y = [0,0,2]
t = -1

<font color=darkcyan># barycentric model is created</font>
p = xalglib.polynomialbuild(x, y)

<font color=darkcyan># barycentric interpolation is demonstrated</font>
v = xalglib.barycentriccalc(p, t)
print(v) <font color=darkcyan># expected 2.0</font>

<font color=darkcyan># barycentric differentation is demonstrated</font>
v, dv = xalglib.barycentricdiff1(p, t)
print(v) <font color=darkcyan># expected 2.0</font>
print(dv) <font color=darkcyan># expected -3.0</font>

<font color=darkcyan># second derivatives with barycentric representation</font>
v, dv = xalglib.barycentricdiff1(p, t)
print(v) <font color=darkcyan># expected 2.0</font>
print(dv) <font color=darkcyan># expected -3.0</font>
v, dv, d2v = xalglib.barycentricdiff2(p, t)
print(v) <font color=darkcyan># expected 2.0</font>
print(dv) <font color=darkcyan># expected -3.0</font>
print(d2v) <font color=darkcyan># expected 2.0</font>


</pre><a name='example_polint_d_conv'></a><h3 class=pageheader>polint_d_conv example</h3>
<pre class=source>
import xalglib



<font color=darkcyan>#</font>
<font color=darkcyan># Here we demonstrate conversion of y=x^2-x</font>
<font color=darkcyan># between power basis and barycentric representation.</font>
<font color=darkcyan>#</font>
a = [0,-1,+1]
t = 2

<font color=darkcyan>#</font>
<font color=darkcyan># a=[0,-1,+1] is decomposition of y=x^2-x in the power basis:</font>
<font color=darkcyan>#</font>
<font color=darkcyan>#     y = 0 - 1*x + 1*x^2</font>
<font color=darkcyan>#</font>
<font color=darkcyan># We convert it to the barycentric form.</font>
<font color=darkcyan>#</font>
p = xalglib.polynomialpow2bar(a)

<font color=darkcyan># now we have barycentric interpolation; we can use it <b>for</b> interpolation</font>
v = xalglib.barycentriccalc(p, t)
print(v) <font color=darkcyan># expected 2.0</font>

<font color=darkcyan># we can also convert back from barycentric representation to power basis</font>
a2 = xalglib.polynomialbar2pow(p)
print(a2) <font color=darkcyan># expected [0,-1,+1]</font>


</pre><a name='example_polint_d_spec'></a><h3 class=pageheader>polint_d_spec example</h3>
<pre class=source>
import xalglib



<font color=darkcyan>#</font>
<font color=darkcyan># Temporaries:</font>
<font color=darkcyan># * values of y=x^2-x sampled at three special grids:</font>
<font color=darkcyan>#   * equdistant grid spanning [0,2],     x[i] = 2*i/(N-1), i=0..N-1</font>
<font color=darkcyan>#   * Chebyshev-I grid spanning [-1,+1],  x[i] = 1 + Cos(PI*(2*i+1)/(2*n)), i=0..N-1</font>
<font color=darkcyan>#   * Chebyshev-II grid spanning [-1,+1], x[i] = 1 + Cos(PI*i/(n-1)), i=0..N-1</font>
<font color=darkcyan># * barycentric interpolants <b>for</b> these three grids</font>
<font color=darkcyan># * vectors to store coefficients of quadratic representation</font>
<font color=darkcyan>#</font>
y_eqdist = [0,0,2]
y_cheb1 = [-0.116025,0.000000,1.616025]
y_cheb2 = [0,0,2]

<font color=darkcyan>#</font>
<font color=darkcyan># First, we demonstrate construction of barycentric interpolants on</font>
<font color=darkcyan># special grids. We unpack power representation to ensure that</font>
<font color=darkcyan># interpolant was built correctly.</font>
<font color=darkcyan>#</font>
<font color=darkcyan># In all three cases we should get same quadratic function.</font>
<font color=darkcyan>#</font>
p_eqdist = xalglib.polynomialbuildeqdist(0.0, 2.0, y_eqdist)
a_eqdist = xalglib.polynomialbar2pow(p_eqdist)
print(a_eqdist) <font color=darkcyan># expected [0,-1,+1]</font>

p_cheb1 = xalglib.polynomialbuildcheb1(-1, +1, y_cheb1)
a_cheb1 = xalglib.polynomialbar2pow(p_cheb1)
print(a_cheb1) <font color=darkcyan># expected [0,-1,+1]</font>

p_cheb2 = xalglib.polynomialbuildcheb2(-1, +1, y_cheb2)
a_cheb2 = xalglib.polynomialbar2pow(p_cheb2)
print(a_cheb2) <font color=darkcyan># expected [0,-1,+1]</font>

<font color=darkcyan>#</font>
<font color=darkcyan># Now we demonstrate polynomial interpolation without construction </font>
<font color=darkcyan># of the barycentricinterpolant structure.</font>
<font color=darkcyan>#</font>
<font color=darkcyan># We calculate interpolant value at x=-2.</font>
<font color=darkcyan># In all three cases we should get same f=6</font>
<font color=darkcyan>#</font>
t = -2
v = xalglib.polynomialcalceqdist(0.0, 2.0, y_eqdist, t)
print(v) <font color=darkcyan># expected 6.0</font>

v = xalglib.polynomialcalccheb1(-1, +1, y_cheb1, t)
print(v) <font color=darkcyan># expected 6.0</font>

v = xalglib.polynomialcalccheb2(-1, +1, y_cheb2, t)
print(v) <font color=darkcyan># expected 6.0</font>


</pre><a name=unit_psif></a><h2 class=pageheader><code>psif</code> module</h2>
<div class=pagecontent>
<h3 class=pageheader>Functions</h3>
<a href='#sub_psi' class=toc>psi</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='sub_psi'></a><h3 class=pageheader><code>psi</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Psi (digamma) function
# 
#              d      -
#   psi(x)  =  -- ln | (x)
#              dx
# 
# is the logarithmic derivative of the gamma function.
# For integer x,
#                   n-1
#                    -
# psi(n) = -EUL  +   &gt;  1/k.
#                    -
#                   k=1
# 
# This formula is used for 0 &lt; n &lt;= 10.  If x is negative, it
# is transformed to a positive argument by the reflection
# formula  psi(1-x) = psi(x) + pi cot(pi x).
# For general positive x, the argument is made greater than 10
# using the recurrence  psi(x+1) = psi(x) + 1/x.
# Then the following asymptotic expansion is applied:
# 
#                           inf.   B
#                            -      2k
# psi(x) = log(x) - 1/2x -   &gt;   -------
#                            -        2k
#                           k=1   2k x
# 
# where the B2k are Bernoulli numbers.
# 
# ACCURACY:
#    Relative error (except absolute when |psi| &lt; 1):
# arithmetic   domain     # trials      peak         rms
#    IEEE      0,30        30000       1.3e-15     1.4e-16
#    IEEE      -30,0       40000       1.5e-15     2.2e-16
# 
# Cephes Math Library Release 2.8:  June, 2000
# Copyright 1984, 1987, 1992, 2000 by Stephen L. Moshier
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.psi(x)

</div></pre>
<a name=unit_pspline></a><h2 class=pageheader><code>pspline</code> module</h2>
<div class=pagecontent>
<h3 class=pageheader>Classes</h3>
<a href='#struct_pspline2interpolant' class=toc>pspline2interpolant</a><br>
<a href='#struct_pspline3interpolant' class=toc>pspline3interpolant</a><br>
<h3 class=pageheader>Functions</h3>
<a href='#sub_pspline2arclength' class=toc>pspline2arclength</a><br>
<a href='#sub_pspline2build' class=toc>pspline2build</a><br>
<a href='#sub_pspline2buildperiodic' class=toc>pspline2buildperiodic</a><br>
<a href='#sub_pspline2calc' class=toc>pspline2calc</a><br>
<a href='#sub_pspline2diff' class=toc>pspline2diff</a><br>
<a href='#sub_pspline2diff2' class=toc>pspline2diff2</a><br>
<a href='#sub_pspline2parametervalues' class=toc>pspline2parametervalues</a><br>
<a href='#sub_pspline2tangent' class=toc>pspline2tangent</a><br>
<a href='#sub_pspline3arclength' class=toc>pspline3arclength</a><br>
<a href='#sub_pspline3build' class=toc>pspline3build</a><br>
<a href='#sub_pspline3buildperiodic' class=toc>pspline3buildperiodic</a><br>
<a href='#sub_pspline3calc' class=toc>pspline3calc</a><br>
<a href='#sub_pspline3diff' class=toc>pspline3diff</a><br>
<a href='#sub_pspline3diff2' class=toc>pspline3diff2</a><br>
<a href='#sub_pspline3parametervalues' class=toc>pspline3parametervalues</a><br>
<a href='#sub_pspline3tangent' class=toc>pspline3tangent</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='struct_pspline2interpolant'></a><h3 class=pageheader><code>pspline2interpolant</code> class</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Parametric spline inteprolant: 2-dimensional curve.
# 
# You should not try to access its members directly - use PSpline2XXXXXXXX()
# functions instead.
#

</div><div style='margin-top: 0; margin-bottom: 0;'><span style='font-weight: bold; color: green;'>class</span> pspline2interpolant(object):
    ...

</div></pre>
<a name='struct_pspline3interpolant'></a><h3 class=pageheader><code>pspline3interpolant</code> class</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Parametric spline inteprolant: 3-dimensional curve.
# 
# You should not try to access its members directly - use PSpline3XXXXXXXX()
# functions instead.
#

</div><div style='margin-top: 0; margin-bottom: 0;'><span style='font-weight: bold; color: green;'>class</span> pspline3interpolant(object):
    ...

</div></pre>
<a name='sub_pspline2arclength'></a><h3 class=pageheader><code>pspline2arclength</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# This function  calculates  arc length, i.e. length of  curve  between  t=a
# and t=b.
# 
# INPUT PARAMETERS:
#     P   -   parametric spline interpolant
#     A,B -   parameter values corresponding to arc ends:
#             * B&gt;A will result in positive length returned
#             * B&lt;A will result in negative length returned
# 
# RESULT:
#     length of arc starting at T=A and ending at T=B.
# 
# 
#   -- ALGLIB PROJECT --
#      Copyright 30.05.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.pspline2arclength(p, a, b)

</div></pre>
<a name='sub_pspline2build'></a><h3 class=pageheader><code>pspline2build</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# This function  builds  non-periodic 2-dimensional parametric spline  which
# starts at (X[0],Y[0]) and ends at (X[N-1],Y[N-1]).
# 
# INPUT PARAMETERS:
#     XY  -   points, array[0..N-1,0..1].
#             XY[I,0:1] corresponds to the Ith point.
#             Order of points is important!
#     N   -   points count, N&gt;=5 for Akima splines, N&gt;=2 for other types  of
#             splines.
#     ST  -   spline type:
#             * 0     Akima spline
#             * 1     parabolically terminated Catmull-Rom spline (Tension=0)
#             * 2     parabolically terminated cubic spline
#     PT  -   parameterization type:
#             * 0     uniform
#             * 1     chord length
#             * 2     centripetal
# 
# OUTPUT PARAMETERS:
#     P   -   parametric spline interpolant
# 
# 
# NOTES:
# * this function  assumes  that  there all consequent points  are distinct.
#   I.e. (x0,y0)&lt;&gt;(x1,y1),  (x1,y1)&lt;&gt;(x2,y2),  (x2,y2)&lt;&gt;(x3,y3)  and  so on.
#   However, non-consequent points may coincide, i.e. we can  have  (x0,y0)=
#   =(x2,y2).
# 
#   -- ALGLIB PROJECT --
#      Copyright 28.05.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: p = xalglib.pspline2build(xy, n, st, pt)

</div></pre>
<a name='sub_pspline2buildperiodic'></a><h3 class=pageheader><code>pspline2buildperiodic</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# This  function  builds  periodic  2-dimensional  parametric  spline  which
# starts at (X[0],Y[0]), goes through all points to (X[N-1],Y[N-1]) and then
# back to (X[0],Y[0]).
# 
# INPUT PARAMETERS:
#     XY  -   points, array[0..N-1,0..1].
#             XY[I,0:1] corresponds to the Ith point.
#             XY[N-1,0:1] must be different from XY[0,0:1].
#             Order of points is important!
#     N   -   points count, N&gt;=3 for other types of splines.
#     ST  -   spline type:
#             * 1     Catmull-Rom spline (Tension=0) with cyclic boundary conditions
#             * 2     cubic spline with cyclic boundary conditions
#     PT  -   parameterization type:
#             * 0     uniform
#             * 1     chord length
#             * 2     centripetal
# 
# OUTPUT PARAMETERS:
#     P   -   parametric spline interpolant
# 
# 
# NOTES:
# * this function  assumes  that there all consequent points  are  distinct.
#   I.e. (x0,y0)&lt;&gt;(x1,y1), (x1,y1)&lt;&gt;(x2,y2),  (x2,y2)&lt;&gt;(x3,y3)  and  so  on.
#   However, non-consequent points may coincide, i.e. we can  have  (x0,y0)=
#   =(x2,y2).
# * last point of sequence is NOT equal to the first  point.  You  shouldn't
#   make curve &quot;explicitly periodic&quot; by making them equal.
# 
#   -- ALGLIB PROJECT --
#      Copyright 28.05.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: p = xalglib.pspline2buildperiodic(xy, n, st, pt)

</div></pre>
<a name='sub_pspline2calc'></a><h3 class=pageheader><code>pspline2calc</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# This function  calculates  the value of the parametric spline for a  given
# value of parameter T
# 
# INPUT PARAMETERS:
#     P   -   parametric spline interpolant
#     T   -   point:
#             * T in [0,1] corresponds to interval spanned by points
#             * for non-periodic splines T&lt;0 (or T&gt;1) correspond to parts of
#               the curve before the first (after the last) point
#             * for periodic splines T&lt;0 (or T&gt;1) are projected  into  [0,1]
#               by making T=T-floor(T).
# 
# OUTPUT PARAMETERS:
#     X   -   X-position
#     Y   -   Y-position
# 
# 
#   -- ALGLIB PROJECT --
#      Copyright 28.05.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: x, y = xalglib.pspline2calc(p, t)

</div></pre>
<a name='sub_pspline2diff'></a><h3 class=pageheader><code>pspline2diff</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# This function calculates derivative, i.e. it returns (dX/dT,dY/dT).
# 
# INPUT PARAMETERS:
#     P   -   parametric spline interpolant
#     T   -   point:
#             * T in [0,1] corresponds to interval spanned by points
#             * for non-periodic splines T&lt;0 (or T&gt;1) correspond to parts of
#               the curve before the first (after the last) point
#             * for periodic splines T&lt;0 (or T&gt;1) are projected  into  [0,1]
#               by making T=T-floor(T).
# 
# OUTPUT PARAMETERS:
#     X   -   X-value
#     DX  -   X-derivative
#     Y   -   Y-value
#     DY  -   Y-derivative
# 
# 
#   -- ALGLIB PROJECT --
#      Copyright 28.05.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: x, dx, y, dy = xalglib.pspline2diff(p, t)

</div></pre>
<a name='sub_pspline2diff2'></a><h3 class=pageheader><code>pspline2diff2</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# This function calculates first and second derivative with respect to T.
# 
# INPUT PARAMETERS:
#     P   -   parametric spline interpolant
#     T   -   point:
#             * T in [0,1] corresponds to interval spanned by points
#             * for non-periodic splines T&lt;0 (or T&gt;1) correspond to parts of
#               the curve before the first (after the last) point
#             * for periodic splines T&lt;0 (or T&gt;1) are projected  into  [0,1]
#               by making T=T-floor(T).
# 
# OUTPUT PARAMETERS:
#     X   -   X-value
#     DX  -   derivative
#     D2X -   second derivative
#     Y   -   Y-value
#     DY  -   derivative
#     D2Y -   second derivative
# 
# 
#   -- ALGLIB PROJECT --
#      Copyright 28.05.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: x, dx, d2x, y, dy, d2y = xalglib.pspline2diff2(p, t)

</div></pre>
<a name='sub_pspline2parametervalues'></a><h3 class=pageheader><code>pspline2parametervalues</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# This function returns vector of parameter values correspoding to points.
# 
# I.e. for P created from (X[0],Y[0])...(X[N-1],Y[N-1]) and U=TValues(P)  we
# have
#     (X[0],Y[0]) = PSpline2Calc(P,U[0]),
#     (X[1],Y[1]) = PSpline2Calc(P,U[1]),
#     (X[2],Y[2]) = PSpline2Calc(P,U[2]),
#     ...
# 
# INPUT PARAMETERS:
#     P   -   parametric spline interpolant
# 
# OUTPUT PARAMETERS:
#     N   -   array size
#     T   -   array[0..N-1]
# 
# 
# NOTES:
# * for non-periodic splines U[0]=0, U[0]&lt;U[1]&lt;...&lt;U[N-1], U[N-1]=1
# * for periodic splines     U[0]=0, U[0]&lt;U[1]&lt;...&lt;U[N-1], U[N-1]&lt;1
# 
#   -- ALGLIB PROJECT --
#      Copyright 28.05.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: n, t = xalglib.pspline2parametervalues(p)

</div></pre>
<a name='sub_pspline2tangent'></a><h3 class=pageheader><code>pspline2tangent</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# This function  calculates  tangent vector for a given value of parameter T
# 
# INPUT PARAMETERS:
#     P   -   parametric spline interpolant
#     T   -   point:
#             * T in [0,1] corresponds to interval spanned by points
#             * for non-periodic splines T&lt;0 (or T&gt;1) correspond to parts of
#               the curve before the first (after the last) point
#             * for periodic splines T&lt;0 (or T&gt;1) are projected  into  [0,1]
#               by making T=T-floor(T).
# 
# OUTPUT PARAMETERS:
#     X    -   X-component of tangent vector (normalized)
#     Y    -   Y-component of tangent vector (normalized)
# 
# NOTE:
#     X^2+Y^2 is either 1 (for non-zero tangent vector) or 0.
# 
# 
#   -- ALGLIB PROJECT --
#      Copyright 28.05.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: x, y = xalglib.pspline2tangent(p, t)

</div></pre>
<a name='sub_pspline3arclength'></a><h3 class=pageheader><code>pspline3arclength</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# This function  calculates  arc length, i.e. length of  curve  between  t=a
# and t=b.
# 
# INPUT PARAMETERS:
#     P   -   parametric spline interpolant
#     A,B -   parameter values corresponding to arc ends:
#             * B&gt;A will result in positive length returned
#             * B&lt;A will result in negative length returned
# 
# RESULT:
#     length of arc starting at T=A and ending at T=B.
# 
# 
#   -- ALGLIB PROJECT --
#      Copyright 30.05.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.pspline3arclength(p, a, b)

</div></pre>
<a name='sub_pspline3build'></a><h3 class=pageheader><code>pspline3build</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# This function  builds  non-periodic 3-dimensional parametric spline  which
# starts at (X[0],Y[0],Z[0]) and ends at (X[N-1],Y[N-1],Z[N-1]).
# 
# Same as PSpline2Build() function, but for 3D, so we  won't  duplicate  its
# description here.
# 
#   -- ALGLIB PROJECT --
#      Copyright 28.05.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: p = xalglib.pspline3build(xy, n, st, pt)

</div></pre>
<a name='sub_pspline3buildperiodic'></a><h3 class=pageheader><code>pspline3buildperiodic</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# This  function  builds  periodic  3-dimensional  parametric  spline  which
# starts at (X[0],Y[0],Z[0]), goes through all points to (X[N-1],Y[N-1],Z[N-1])
# and then back to (X[0],Y[0],Z[0]).
# 
# Same as PSpline2Build() function, but for 3D, so we  won't  duplicate  its
# description here.
# 
#   -- ALGLIB PROJECT --
#      Copyright 28.05.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: p = xalglib.pspline3buildperiodic(xy, n, st, pt)

</div></pre>
<a name='sub_pspline3calc'></a><h3 class=pageheader><code>pspline3calc</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# This function  calculates  the value of the parametric spline for a  given
# value of parameter T.
# 
# INPUT PARAMETERS:
#     P   -   parametric spline interpolant
#     T   -   point:
#             * T in [0,1] corresponds to interval spanned by points
#             * for non-periodic splines T&lt;0 (or T&gt;1) correspond to parts of
#               the curve before the first (after the last) point
#             * for periodic splines T&lt;0 (or T&gt;1) are projected  into  [0,1]
#               by making T=T-floor(T).
# 
# OUTPUT PARAMETERS:
#     X   -   X-position
#     Y   -   Y-position
#     Z   -   Z-position
# 
# 
#   -- ALGLIB PROJECT --
#      Copyright 28.05.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: x, y, z = xalglib.pspline3calc(p, t)

</div></pre>
<a name='sub_pspline3diff'></a><h3 class=pageheader><code>pspline3diff</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# This function calculates derivative, i.e. it returns (dX/dT,dY/dT,dZ/dT).
# 
# INPUT PARAMETERS:
#     P   -   parametric spline interpolant
#     T   -   point:
#             * T in [0,1] corresponds to interval spanned by points
#             * for non-periodic splines T&lt;0 (or T&gt;1) correspond to parts of
#               the curve before the first (after the last) point
#             * for periodic splines T&lt;0 (or T&gt;1) are projected  into  [0,1]
#               by making T=T-floor(T).
# 
# OUTPUT PARAMETERS:
#     X   -   X-value
#     DX  -   X-derivative
#     Y   -   Y-value
#     DY  -   Y-derivative
#     Z   -   Z-value
#     DZ  -   Z-derivative
# 
# 
#   -- ALGLIB PROJECT --
#      Copyright 28.05.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: x, dx, y, dy, z, dz = xalglib.pspline3diff(p, t)

</div></pre>
<a name='sub_pspline3diff2'></a><h3 class=pageheader><code>pspline3diff2</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# This function calculates first and second derivative with respect to T.
# 
# INPUT PARAMETERS:
#     P   -   parametric spline interpolant
#     T   -   point:
#             * T in [0,1] corresponds to interval spanned by points
#             * for non-periodic splines T&lt;0 (or T&gt;1) correspond to parts of
#               the curve before the first (after the last) point
#             * for periodic splines T&lt;0 (or T&gt;1) are projected  into  [0,1]
#               by making T=T-floor(T).
# 
# OUTPUT PARAMETERS:
#     X   -   X-value
#     DX  -   derivative
#     D2X -   second derivative
#     Y   -   Y-value
#     DY  -   derivative
#     D2Y -   second derivative
#     Z   -   Z-value
#     DZ  -   derivative
#     D2Z -   second derivative
# 
# 
#   -- ALGLIB PROJECT --
#      Copyright 28.05.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: x, dx, d2x, y, dy, d2y, z, dz, d2z = xalglib.pspline3diff2(p, t)

</div></pre>
<a name='sub_pspline3parametervalues'></a><h3 class=pageheader><code>pspline3parametervalues</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# This function returns vector of parameter values correspoding to points.
# 
# Same as PSpline2ParameterValues(), but for 3D.
# 
#   -- ALGLIB PROJECT --
#      Copyright 28.05.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: n, t = xalglib.pspline3parametervalues(p)

</div></pre>
<a name='sub_pspline3tangent'></a><h3 class=pageheader><code>pspline3tangent</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# This function  calculates  tangent vector for a given value of parameter T
# 
# INPUT PARAMETERS:
#     P   -   parametric spline interpolant
#     T   -   point:
#             * T in [0,1] corresponds to interval spanned by points
#             * for non-periodic splines T&lt;0 (or T&gt;1) correspond to parts of
#               the curve before the first (after the last) point
#             * for periodic splines T&lt;0 (or T&gt;1) are projected  into  [0,1]
#               by making T=T-floor(T).
# 
# OUTPUT PARAMETERS:
#     X    -   X-component of tangent vector (normalized)
#     Y    -   Y-component of tangent vector (normalized)
#     Z    -   Z-component of tangent vector (normalized)
# 
# NOTE:
#     X^2+Y^2+Z^2 is either 1 (for non-zero tangent vector) or 0.
# 
# 
#   -- ALGLIB PROJECT --
#      Copyright 28.05.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: x, y, z = xalglib.pspline3tangent(p, t)

</div></pre>
<a name=unit_ratint></a><h2 class=pageheader><code>ratint</code> module</h2>
<div class=pagecontent>
<h3 class=pageheader>Classes</h3>
<a href='#struct_barycentricinterpolant' class=toc>barycentricinterpolant</a><br>
<h3 class=pageheader>Functions</h3>
<a href='#sub_barycentricbuildfloaterhormann' class=toc>barycentricbuildfloaterhormann</a><br>
<a href='#sub_barycentricbuildxyw' class=toc>barycentricbuildxyw</a><br>
<a href='#sub_barycentriccalc' class=toc>barycentriccalc</a><br>
<a href='#sub_barycentricdiff1' class=toc>barycentricdiff1</a><br>
<a href='#sub_barycentricdiff2' class=toc>barycentricdiff2</a><br>
<a href='#sub_barycentriclintransx' class=toc>barycentriclintransx</a><br>
<a href='#sub_barycentriclintransy' class=toc>barycentriclintransy</a><br>
<a href='#sub_barycentricunpack' class=toc>barycentricunpack</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='struct_barycentricinterpolant'></a><h3 class=pageheader><code>barycentricinterpolant</code> class</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Barycentric interpolant.
#

</div><div style='margin-top: 0; margin-bottom: 0;'><span style='font-weight: bold; color: green;'>class</span> barycentricinterpolant(object):
    ...

</div></pre>
<a name='sub_barycentricbuildfloaterhormann'></a><h3 class=pageheader><code>barycentricbuildfloaterhormann</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Rational interpolant without poles
# 
# The subroutine constructs the rational interpolating function without real
# poles  (see  'Barycentric rational interpolation with no  poles  and  high
# rates of approximation', Michael S. Floater. and  Kai  Hormann,  for  more
# information on this subject).
# 
# Input parameters:
#     X   -   interpolation nodes, array[0..N-1].
#     Y   -   function values, array[0..N-1].
#     N   -   number of nodes, N&gt;0.
#     D   -   order of the interpolation scheme, 0 &lt;= D &lt;= N-1.
#             D&lt;0 will cause an error.
#             D&gt;=N it will be replaced with D=N-1.
#             if you don't know what D to choose, use small value about 3-5.
# 
# Output parameters:
#     B   -   barycentric interpolant.
# 
# Note:
#     this algorithm always succeeds and calculates the weights  with  close
#     to machine precision.
# 
#   -- ALGLIB PROJECT --
#      Copyright 17.06.2007 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: b = xalglib.barycentricbuildfloaterhormann(x, y, n, d)

</div></pre>
<a name='sub_barycentricbuildxyw'></a><h3 class=pageheader><code>barycentricbuildxyw</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Rational interpolant from X/Y/W arrays
# 
# F(t) = SUM(i=0,n-1,w[i]*f[i]/(t-x[i])) / SUM(i=0,n-1,w[i]/(t-x[i]))
# 
# INPUT PARAMETERS:
#     X   -   interpolation nodes, array[0..N-1]
#     F   -   function values, array[0..N-1]
#     W   -   barycentric weights, array[0..N-1]
#     N   -   nodes count, N&gt;0
# 
# OUTPUT PARAMETERS:
#     B   -   barycentric interpolant built from (X, Y, W)
# 
#   -- ALGLIB --
#      Copyright 17.08.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: b = xalglib.barycentricbuildxyw(x, y, w, n)

</div></pre>
<a name='sub_barycentriccalc'></a><h3 class=pageheader><code>barycentriccalc</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Rational interpolation using barycentric formula
# 
# F(t) = SUM(i=0,n-1,w[i]*f[i]/(t-x[i])) / SUM(i=0,n-1,w[i]/(t-x[i]))
# 
# Input parameters:
#     B   -   barycentric interpolant built with one of model building
#             subroutines.
#     T   -   interpolation point
# 
# Result:
#     barycentric interpolant F(t)
# 
#   -- ALGLIB --
#      Copyright 17.08.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.barycentriccalc(b, t)

</div></pre>
<a name='sub_barycentricdiff1'></a><h3 class=pageheader><code>barycentricdiff1</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Differentiation of barycentric interpolant: first derivative.
# 
# Algorithm used in this subroutine is very robust and should not fail until
# provided with values too close to MaxRealNumber  (usually  MaxRealNumber/N
# or greater will overflow).
# 
# INPUT PARAMETERS:
#     B   -   barycentric interpolant built with one of model building
#             subroutines.
#     T   -   interpolation point
# 
# OUTPUT PARAMETERS:
#     F   -   barycentric interpolant at T
#     DF  -   first derivative
# 
# NOTE
# 
# 
#   -- ALGLIB --
#      Copyright 17.08.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: f, df = xalglib.barycentricdiff1(b, t)

</div></pre>
<a name='sub_barycentricdiff2'></a><h3 class=pageheader><code>barycentricdiff2</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Differentiation of barycentric interpolant: first/second derivatives.
# 
# INPUT PARAMETERS:
#     B   -   barycentric interpolant built with one of model building
#             subroutines.
#     T   -   interpolation point
# 
# OUTPUT PARAMETERS:
#     F   -   barycentric interpolant at T
#     DF  -   first derivative
#     D2F -   second derivative
# 
# NOTE: this algorithm may fail due to overflow/underflor if  used  on  data
# whose values are close to MaxRealNumber or MinRealNumber.  Use more robust
# BarycentricDiff1() subroutine in such cases.
# 
# 
#   -- ALGLIB --
#      Copyright 17.08.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: f, df, d2f = xalglib.barycentricdiff2(b, t)

</div></pre>
<a name='sub_barycentriclintransx'></a><h3 class=pageheader><code>barycentriclintransx</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# This subroutine performs linear transformation of the argument.
# 
# INPUT PARAMETERS:
#     B       -   rational interpolant in barycentric form
#     CA, CB  -   transformation coefficients: x = CA*t + CB
# 
# OUTPUT PARAMETERS:
#     B       -   transformed interpolant with X replaced by T
# 
#   -- ALGLIB PROJECT --
#      Copyright 19.08.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: xalglib.barycentriclintransx(b, ca, cb)

</div></pre>
<a name='sub_barycentriclintransy'></a><h3 class=pageheader><code>barycentriclintransy</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# This  subroutine   performs   linear  transformation  of  the  barycentric
# interpolant.
# 
# INPUT PARAMETERS:
#     B       -   rational interpolant in barycentric form
#     CA, CB  -   transformation coefficients: B2(x) = CA*B(x) + CB
# 
# OUTPUT PARAMETERS:
#     B       -   transformed interpolant
# 
#   -- ALGLIB PROJECT --
#      Copyright 19.08.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: xalglib.barycentriclintransy(b, ca, cb)

</div></pre>
<a name='sub_barycentricunpack'></a><h3 class=pageheader><code>barycentricunpack</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Extracts X/Y/W arrays from rational interpolant
# 
# INPUT PARAMETERS:
#     B   -   barycentric interpolant
# 
# OUTPUT PARAMETERS:
#     N   -   nodes count, N&gt;0
#     X   -   interpolation nodes, array[0..N-1]
#     F   -   function values, array[0..N-1]
#     W   -   barycentric weights, array[0..N-1]
# 
#   -- ALGLIB --
#      Copyright 17.08.2009 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: n, x, y, w = xalglib.barycentricunpack(b)

</div></pre>
<a name=unit_rcond></a><h2 class=pageheader><code>rcond</code> module</h2>
<div class=pagecontent>
<h3 class=pageheader>Functions</h3>
<a href='#sub_cmatrixlurcond1' class=toc>cmatrixlurcond1</a><br>
<a href='#sub_cmatrixlurcondinf' class=toc>cmatrixlurcondinf</a><br>
<a href='#sub_cmatrixrcond1' class=toc>cmatrixrcond1</a><br>
<a href='#sub_cmatrixrcondinf' class=toc>cmatrixrcondinf</a><br>
<a href='#sub_cmatrixtrrcond1' class=toc>cmatrixtrrcond1</a><br>
<a href='#sub_cmatrixtrrcondinf' class=toc>cmatrixtrrcondinf</a><br>
<a href='#sub_hpdmatrixcholeskyrcond' class=toc>hpdmatrixcholeskyrcond</a><br>
<a href='#sub_hpdmatrixrcond' class=toc>hpdmatrixrcond</a><br>
<a href='#sub_rmatrixlurcond1' class=toc>rmatrixlurcond1</a><br>
<a href='#sub_rmatrixlurcondinf' class=toc>rmatrixlurcondinf</a><br>
<a href='#sub_rmatrixrcond1' class=toc>rmatrixrcond1</a><br>
<a href='#sub_rmatrixrcondinf' class=toc>rmatrixrcondinf</a><br>
<a href='#sub_rmatrixtrrcond1' class=toc>rmatrixtrrcond1</a><br>
<a href='#sub_rmatrixtrrcondinf' class=toc>rmatrixtrrcondinf</a><br>
<a href='#sub_spdmatrixcholeskyrcond' class=toc>spdmatrixcholeskyrcond</a><br>
<a href='#sub_spdmatrixrcond' class=toc>spdmatrixrcond</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='sub_cmatrixlurcond1'></a><h3 class=pageheader><code>cmatrixlurcond1</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Estimate of the condition number of a matrix given by its LU decomposition (1-norm)
# 
# The algorithm calculates a lower bound of the condition number. In this case,
# the algorithm does not return a lower bound of the condition number, but an
# inverse number (to avoid an overflow in case of a singular matrix).
# 
# Input parameters:
#     LUA         -   LU decomposition of a matrix in compact form. Output of
#                     the CMatrixLU subroutine.
#     N           -   size of matrix A.
# 
# Result: 1/LowerBound(cond(A))
# 
# NOTE:
#     if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
#     0.0 is returned in such cases.
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.cmatrixlurcond1(lua, n)

</div></pre>
<a name='sub_cmatrixlurcondinf'></a><h3 class=pageheader><code>cmatrixlurcondinf</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Estimate of the condition number of a matrix given by its LU decomposition
# (infinity norm).
# 
# The algorithm calculates a lower bound of the condition number. In this case,
# the algorithm does not return a lower bound of the condition number, but an
# inverse number (to avoid an overflow in case of a singular matrix).
# 
# Input parameters:
#     LUA     -   LU decomposition of a matrix in compact form. Output of
#                 the CMatrixLU subroutine.
#     N       -   size of matrix A.
# 
# Result: 1/LowerBound(cond(A))
# 
# NOTE:
#     if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
#     0.0 is returned in such cases.
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.cmatrixlurcondinf(lua, n)

</div></pre>
<a name='sub_cmatrixrcond1'></a><h3 class=pageheader><code>cmatrixrcond1</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Estimate of a matrix condition number (1-norm)
# 
# The algorithm calculates a lower bound of the condition number. In this case,
# the algorithm does not return a lower bound of the condition number, but an
# inverse number (to avoid an overflow in case of a singular matrix).
# 
# Input parameters:
#     A   -   matrix. Array whose indexes range within [0..N-1, 0..N-1].
#     N   -   size of matrix A.
# 
# Result: 1/LowerBound(cond(A))
# 
# NOTE:
#     if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
#     0.0 is returned in such cases.
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.cmatrixrcond1(a, n)

</div></pre>
<a name='sub_cmatrixrcondinf'></a><h3 class=pageheader><code>cmatrixrcondinf</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Estimate of a matrix condition number (infinity-norm).
# 
# The algorithm calculates a lower bound of the condition number. In this case,
# the algorithm does not return a lower bound of the condition number, but an
# inverse number (to avoid an overflow in case of a singular matrix).
# 
# Input parameters:
#     A   -   matrix. Array whose indexes range within [0..N-1, 0..N-1].
#     N   -   size of matrix A.
# 
# Result: 1/LowerBound(cond(A))
# 
# NOTE:
#     if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
#     0.0 is returned in such cases.
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.cmatrixrcondinf(a, n)

</div></pre>
<a name='sub_cmatrixtrrcond1'></a><h3 class=pageheader><code>cmatrixtrrcond1</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Triangular matrix: estimate of a condition number (1-norm)
# 
# The algorithm calculates a lower bound of the condition number. In this case,
# the algorithm does not return a lower bound of the condition number, but an
# inverse number (to avoid an overflow in case of a singular matrix).
# 
# Input parameters:
#     A       -   matrix. Array[0..N-1, 0..N-1].
#     N       -   size of A.
#     IsUpper -   True, if the matrix is upper triangular.
#     IsUnit  -   True, if the matrix has a unit diagonal.
# 
# Result: 1/LowerBound(cond(A))
# 
# NOTE:
#     if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
#     0.0 is returned in such cases.
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.cmatrixtrrcond1(a, n, isupper, isunit)

</div></pre>
<a name='sub_cmatrixtrrcondinf'></a><h3 class=pageheader><code>cmatrixtrrcondinf</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Triangular matrix: estimate of a matrix condition number (infinity-norm).
# 
# The algorithm calculates a lower bound of the condition number. In this case,
# the algorithm does not return a lower bound of the condition number, but an
# inverse number (to avoid an overflow in case of a singular matrix).
# 
# Input parameters:
#     A   -   matrix. Array whose indexes range within [0..N-1, 0..N-1].
#     N   -   size of matrix A.
#     IsUpper -   True, if the matrix is upper triangular.
#     IsUnit  -   True, if the matrix has a unit diagonal.
# 
# Result: 1/LowerBound(cond(A))
# 
# NOTE:
#     if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
#     0.0 is returned in such cases.
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.cmatrixtrrcondinf(a, n, isupper, isunit)

</div></pre>
<a name='sub_hpdmatrixcholeskyrcond'></a><h3 class=pageheader><code>hpdmatrixcholeskyrcond</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Condition number estimate of a Hermitian positive definite matrix given by
# Cholesky decomposition.
# 
# The algorithm calculates a lower bound of the condition number. In this
# case, the algorithm does not return a lower bound of the condition number,
# but an inverse number (to avoid an overflow in case of a singular matrix).
# 
# It should be noted that 1-norm and inf-norm condition numbers of symmetric
# matrices are equal, so the algorithm doesn't take into account the
# differences between these types of norms.
# 
# Input parameters:
#     CD  - Cholesky decomposition of matrix A,
#           output of SMatrixCholesky subroutine.
#     N   - size of matrix A.
# 
# Result: 1/LowerBound(cond(A))
# 
# NOTE:
#     if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
#     0.0 is returned in such cases.
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.hpdmatrixcholeskyrcond(a, n, isupper)

</div></pre>
<a name='sub_hpdmatrixrcond'></a><h3 class=pageheader><code>hpdmatrixrcond</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Condition number estimate of a Hermitian positive definite matrix.
# 
# The algorithm calculates a lower bound of the condition number. In this case,
# the algorithm does not return a lower bound of the condition number, but an
# inverse number (to avoid an overflow in case of a singular matrix).
# 
# It should be noted that 1-norm and inf-norm of condition numbers of symmetric
# matrices are equal, so the algorithm doesn't take into account the
# differences between these types of norms.
# 
# Input parameters:
#     A       -   Hermitian positive definite matrix which is given by its
#                 upper or lower triangle depending on the value of
#                 IsUpper. Array with elements [0..N-1, 0..N-1].
#     N       -   size of matrix A.
#     IsUpper -   storage format.
# 
# Result:
#     1/LowerBound(cond(A)), if matrix A is positive definite,
#    -1, if matrix A is not positive definite, and its condition number
#     could not be found by this algorithm.
# 
# NOTE:
#     if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
#     0.0 is returned in such cases.
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.hpdmatrixrcond(a, n, isupper)

</div></pre>
<a name='sub_rmatrixlurcond1'></a><h3 class=pageheader><code>rmatrixlurcond1</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Estimate of the condition number of a matrix given by its LU decomposition (1-norm)
# 
# The algorithm calculates a lower bound of the condition number. In this case,
# the algorithm does not return a lower bound of the condition number, but an
# inverse number (to avoid an overflow in case of a singular matrix).
# 
# Input parameters:
#     LUA         -   LU decomposition of a matrix in compact form. Output of
#                     the RMatrixLU subroutine.
#     N           -   size of matrix A.
# 
# Result: 1/LowerBound(cond(A))
# 
# NOTE:
#     if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
#     0.0 is returned in such cases.
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.rmatrixlurcond1(lua, n)

</div></pre>
<a name='sub_rmatrixlurcondinf'></a><h3 class=pageheader><code>rmatrixlurcondinf</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Estimate of the condition number of a matrix given by its LU decomposition
# (infinity norm).
# 
# The algorithm calculates a lower bound of the condition number. In this case,
# the algorithm does not return a lower bound of the condition number, but an
# inverse number (to avoid an overflow in case of a singular matrix).
# 
# Input parameters:
#     LUA     -   LU decomposition of a matrix in compact form. Output of
#                 the RMatrixLU subroutine.
#     N       -   size of matrix A.
# 
# Result: 1/LowerBound(cond(A))
# 
# NOTE:
#     if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
#     0.0 is returned in such cases.
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.rmatrixlurcondinf(lua, n)

</div></pre>
<a name='sub_rmatrixrcond1'></a><h3 class=pageheader><code>rmatrixrcond1</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Estimate of a matrix condition number (1-norm)
# 
# The algorithm calculates a lower bound of the condition number. In this case,
# the algorithm does not return a lower bound of the condition number, but an
# inverse number (to avoid an overflow in case of a singular matrix).
# 
# Input parameters:
#     A   -   matrix. Array whose indexes range within [0..N-1, 0..N-1].
#     N   -   size of matrix A.
# 
# Result: 1/LowerBound(cond(A))
# 
# NOTE:
#     if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
#     0.0 is returned in such cases.
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.rmatrixrcond1(a, n)

</div></pre>
<a name='sub_rmatrixrcondinf'></a><h3 class=pageheader><code>rmatrixrcondinf</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Estimate of a matrix condition number (infinity-norm).
# 
# The algorithm calculates a lower bound of the condition number. In this case,
# the algorithm does not return a lower bound of the condition number, but an
# inverse number (to avoid an overflow in case of a singular matrix).
# 
# Input parameters:
#     A   -   matrix. Array whose indexes range within [0..N-1, 0..N-1].
#     N   -   size of matrix A.
# 
# Result: 1/LowerBound(cond(A))
# 
# NOTE:
#     if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
#     0.0 is returned in such cases.
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.rmatrixrcondinf(a, n)

</div></pre>
<a name='sub_rmatrixtrrcond1'></a><h3 class=pageheader><code>rmatrixtrrcond1</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Triangular matrix: estimate of a condition number (1-norm)
# 
# The algorithm calculates a lower bound of the condition number. In this case,
# the algorithm does not return a lower bound of the condition number, but an
# inverse number (to avoid an overflow in case of a singular matrix).
# 
# Input parameters:
#     A       -   matrix. Array[0..N-1, 0..N-1].
#     N       -   size of A.
#     IsUpper -   True, if the matrix is upper triangular.
#     IsUnit  -   True, if the matrix has a unit diagonal.
# 
# Result: 1/LowerBound(cond(A))
# 
# NOTE:
#     if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
#     0.0 is returned in such cases.
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.rmatrixtrrcond1(a, n, isupper, isunit)

</div></pre>
<a name='sub_rmatrixtrrcondinf'></a><h3 class=pageheader><code>rmatrixtrrcondinf</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Triangular matrix: estimate of a matrix condition number (infinity-norm).
# 
# The algorithm calculates a lower bound of the condition number. In this case,
# the algorithm does not return a lower bound of the condition number, but an
# inverse number (to avoid an overflow in case of a singular matrix).
# 
# Input parameters:
#     A   -   matrix. Array whose indexes range within [0..N-1, 0..N-1].
#     N   -   size of matrix A.
#     IsUpper -   True, if the matrix is upper triangular.
#     IsUnit  -   True, if the matrix has a unit diagonal.
# 
# Result: 1/LowerBound(cond(A))
# 
# NOTE:
#     if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
#     0.0 is returned in such cases.
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.rmatrixtrrcondinf(a, n, isupper, isunit)

</div></pre>
<a name='sub_spdmatrixcholeskyrcond'></a><h3 class=pageheader><code>spdmatrixcholeskyrcond</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Condition number estimate of a symmetric positive definite matrix given by
# Cholesky decomposition.
# 
# The algorithm calculates a lower bound of the condition number. In this
# case, the algorithm does not return a lower bound of the condition number,
# but an inverse number (to avoid an overflow in case of a singular matrix).
# 
# It should be noted that 1-norm and inf-norm condition numbers of symmetric
# matrices are equal, so the algorithm doesn't take into account the
# differences between these types of norms.
# 
# Input parameters:
#     CD  - Cholesky decomposition of matrix A,
#           output of SMatrixCholesky subroutine.
#     N   - size of matrix A.
# 
# Result: 1/LowerBound(cond(A))
# 
# NOTE:
#     if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
#     0.0 is returned in such cases.
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.spdmatrixcholeskyrcond(a, n, isupper)

</div></pre>
<a name='sub_spdmatrixrcond'></a><h3 class=pageheader><code>spdmatrixrcond</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Condition number estimate of a symmetric positive definite matrix.
# 
# The algorithm calculates a lower bound of the condition number. In this case,
# the algorithm does not return a lower bound of the condition number, but an
# inverse number (to avoid an overflow in case of a singular matrix).
# 
# It should be noted that 1-norm and inf-norm of condition numbers of symmetric
# matrices are equal, so the algorithm doesn't take into account the
# differences between these types of norms.
# 
# Input parameters:
#     A       -   symmetric positive definite matrix which is given by its
#                 upper or lower triangle depending on the value of
#                 IsUpper. Array with elements [0..N-1, 0..N-1].
#     N       -   size of matrix A.
#     IsUpper -   storage format.
# 
# Result:
#     1/LowerBound(cond(A)), if matrix A is positive definite,
#    -1, if matrix A is not positive definite, and its condition number
#     could not be found by this algorithm.
# 
# NOTE:
#     if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
#     0.0 is returned in such cases.
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.spdmatrixrcond(a, n, isupper)

</div></pre>
<a name=unit_schur></a><h2 class=pageheader><code>schur</code> module</h2>
<div class=pagecontent>
<h3 class=pageheader>Functions</h3>
<a href='#sub_rmatrixschur' class=toc>rmatrixschur</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='sub_rmatrixschur'></a><h3 class=pageheader><code>rmatrixschur</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Subroutine performing the Schur decomposition of a general matrix by using
# the QR algorithm with multiple shifts.
# 
# The source matrix A is represented as S'*A*S = T, where S is an orthogonal
# matrix (Schur vectors), T - upper quasi-triangular matrix (with blocks of
# sizes 1x1 and 2x2 on the main diagonal).
# 
# Input parameters:
#     A   -   matrix to be decomposed.
#             Array whose indexes range within [0..N-1, 0..N-1].
#     N   -   size of A, N&gt;=0.
# 
# 
# Output parameters:
#     A   -   contains matrix T.
#             Array whose indexes range within [0..N-1, 0..N-1].
#     S   -   contains Schur vectors.
#             Array whose indexes range within [0..N-1, 0..N-1].
# 
# Note 1:
#     The block structure of matrix T can be easily recognized: since all
#     the elements below the blocks are zeros, the elements a[i+1,i] which
#     are equal to 0 show the block border.
# 
# Note 2:
#     The algorithm performance depends on the value of the internal parameter
#     NS of the InternalSchurDecomposition subroutine which defines the number
#     of shifts in the QR algorithm (similarly to the block width in block-matrix
#     algorithms in linear algebra). If you require maximum performance on
#     your machine, it is recommended to adjust this parameter manually.
# 
# Result:
#     True,
#         if the algorithm has converged and parameters A and S contain the result.
#     False,
#         if the algorithm has not converged.
# 
# Algorithm implemented on the basis of the DHSEQR subroutine (LAPACK 3.0 library).
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result, a, s = xalglib.rmatrixschur(a, n)

</div></pre>
<a name=unit_spdgevd></a><h2 class=pageheader><code>spdgevd</code> module</h2>
<div class=pagecontent>
<h3 class=pageheader>Functions</h3>
<a href='#sub_smatrixgevd' class=toc>smatrixgevd</a><br>
<a href='#sub_smatrixgevdreduce' class=toc>smatrixgevdreduce</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='sub_smatrixgevd'></a><h3 class=pageheader><code>smatrixgevd</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Algorithm for solving the following generalized symmetric positive-definite
# eigenproblem:
#     A*x = lambda*B*x (1) or
#     A*B*x = lambda*x (2) or
#     B*A*x = lambda*x (3).
# where A is a symmetric matrix, B - symmetric positive-definite matrix.
# The problem is solved by reducing it to an ordinary  symmetric  eigenvalue
# problem.
# 
# Input parameters:
#     A           -   symmetric matrix which is given by its upper or lower
#                     triangular part.
#                     Array whose indexes range within [0..N-1, 0..N-1].
#     N           -   size of matrices A and B.
#     IsUpperA    -   storage format of matrix A.
#     B           -   symmetric positive-definite matrix which is given by
#                     its upper or lower triangular part.
#                     Array whose indexes range within [0..N-1, 0..N-1].
#     IsUpperB    -   storage format of matrix B.
#     ZNeeded     -   if ZNeeded is equal to:
#                      * 0, the eigenvectors are not returned;
#                      * 1, the eigenvectors are returned.
#     ProblemType -   if ProblemType is equal to:
#                      * 1, the following problem is solved: A*x = lambda*B*x;
#                      * 2, the following problem is solved: A*B*x = lambda*x;
#                      * 3, the following problem is solved: B*A*x = lambda*x.
# 
# Output parameters:
#     D           -   eigenvalues in ascending order.
#                     Array whose index ranges within [0..N-1].
#     Z           -   if ZNeeded is equal to:
#                      * 0, Z hasnt changed;
#                      * 1, Z contains eigenvectors.
#                     Array whose indexes range within [0..N-1, 0..N-1].
#                     The eigenvectors are stored in matrix columns. It should
#                     be noted that the eigenvectors in such problems do not
#                     form an orthogonal system.
# 
# Result:
#     True, if the problem was solved successfully.
#     False, if the error occurred during the Cholesky decomposition of matrix
#     B (the matrix isnt positive-definite) or during the work of the iterative
#     algorithm for solving the symmetric eigenproblem.
# 
# See also the GeneralizedSymmetricDefiniteEVDReduce subroutine.
# 
#   -- ALGLIB --
#      Copyright 1.28.2006 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result, d, z = xalglib.smatrixgevd(a, n, isuppera, b, isupperb, zneeded, problemtype)

</div></pre>
<a name='sub_smatrixgevdreduce'></a><h3 class=pageheader><code>smatrixgevdreduce</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Algorithm for reduction of the following generalized symmetric positive-
# definite eigenvalue problem:
#     A*x = lambda*B*x (1) or
#     A*B*x = lambda*x (2) or
#     B*A*x = lambda*x (3)
# to the symmetric eigenvalues problem C*y = lambda*y (eigenvalues of this and
# the given problems are the same, and the eigenvectors of the given problem
# could be obtained by multiplying the obtained eigenvectors by the
# transformation matrix x = R*y).
# 
# Here A is a symmetric matrix, B - symmetric positive-definite matrix.
# 
# Input parameters:
#     A           -   symmetric matrix which is given by its upper or lower
#                     triangular part.
#                     Array whose indexes range within [0..N-1, 0..N-1].
#     N           -   size of matrices A and B.
#     IsUpperA    -   storage format of matrix A.
#     B           -   symmetric positive-definite matrix which is given by
#                     its upper or lower triangular part.
#                     Array whose indexes range within [0..N-1, 0..N-1].
#     IsUpperB    -   storage format of matrix B.
#     ProblemType -   if ProblemType is equal to:
#                      * 1, the following problem is solved: A*x = lambda*B*x;
#                      * 2, the following problem is solved: A*B*x = lambda*x;
#                      * 3, the following problem is solved: B*A*x = lambda*x.
# 
# Output parameters:
#     A           -   symmetric matrix which is given by its upper or lower
#                     triangle depending on IsUpperA. Contains matrix C.
#                     Array whose indexes range within [0..N-1, 0..N-1].
#     R           -   upper triangular or low triangular transformation matrix
#                     which is used to obtain the eigenvectors of a given problem
#                     as the product of eigenvectors of C (from the right) and
#                     matrix R (from the left). If the matrix is upper
#                     triangular, the elements below the main diagonal
#                     are equal to 0 (and vice versa). Thus, we can perform
#                     the multiplication without taking into account the
#                     internal structure (which is an easier though less
#                     effective way).
#                     Array whose indexes range within [0..N-1, 0..N-1].
#     IsUpperR    -   type of matrix R (upper or lower triangular).
# 
# Result:
#     True, if the problem was reduced successfully.
#     False, if the error occurred during the Cholesky decomposition of
#         matrix B (the matrix is not positive-definite).
# 
#   -- ALGLIB --
#      Copyright 1.28.2006 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result, a, r, isupperr = xalglib.smatrixgevdreduce(a, n, isuppera, b, isupperb, problemtype)

</div></pre>
<a name=unit_spline1d></a><h2 class=pageheader><code>spline1d</code> module</h2>
<div class=pagecontent>
<h3 class=pageheader>Classes</h3>
<a href='#struct_spline1dinterpolant' class=toc>spline1dinterpolant</a><br>
<h3 class=pageheader>Functions</h3>
<a href='#sub_spline1dbuildakima' class=toc>spline1dbuildakima</a><br>
<a href='#sub_spline1dbuildcatmullrom' class=toc>spline1dbuildcatmullrom</a><br>
<a href='#sub_spline1dbuildcubic' class=toc>spline1dbuildcubic</a><br>
<a href='#sub_spline1dbuildhermite' class=toc>spline1dbuildhermite</a><br>
<a href='#sub_spline1dbuildlinear' class=toc>spline1dbuildlinear</a><br>
<a href='#sub_spline1dcalc' class=toc>spline1dcalc</a><br>
<a href='#sub_spline1dconvcubic' class=toc>spline1dconvcubic</a><br>
<a href='#sub_spline1dconvdiff2cubic' class=toc>spline1dconvdiff2cubic</a><br>
<a href='#sub_spline1dconvdiffcubic' class=toc>spline1dconvdiffcubic</a><br>
<a href='#sub_spline1ddiff' class=toc>spline1ddiff</a><br>
<a href='#sub_spline1dgriddiff2cubic' class=toc>spline1dgriddiff2cubic</a><br>
<a href='#sub_spline1dgriddiffcubic' class=toc>spline1dgriddiffcubic</a><br>
<a href='#sub_spline1dintegrate' class=toc>spline1dintegrate</a><br>
<a href='#sub_spline1dlintransx' class=toc>spline1dlintransx</a><br>
<a href='#sub_spline1dlintransy' class=toc>spline1dlintransy</a><br>
<a href='#sub_spline1dunpack' class=toc>spline1dunpack</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
<tr align=left valign=top><td><a href='#example_spline1d_d_convdiff' class=toc>spline1d_d_convdiff</a></td><td width=15>&nbsp;</td><td>Resampling using cubic splines</td></tr>
<tr align=left valign=top><td><a href='#example_spline1d_d_cubic' class=toc>spline1d_d_cubic</a></td><td width=15>&nbsp;</td><td>Cubic spline interpolation</td></tr>
<tr align=left valign=top><td><a href='#example_spline1d_d_griddiff' class=toc>spline1d_d_griddiff</a></td><td width=15>&nbsp;</td><td>Differentiation on the grid using cubic splines</td></tr>
<tr align=left valign=top><td><a href='#example_spline1d_d_linear' class=toc>spline1d_d_linear</a></td><td width=15>&nbsp;</td><td>Piecewise linear spline interpolation</td></tr>
</table></div>
<a name='struct_spline1dinterpolant'></a><h3 class=pageheader><code>spline1dinterpolant</code> class</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# 1-dimensional spline inteprolant
#

</div><div style='margin-top: 0; margin-bottom: 0;'><span style='font-weight: bold; color: green;'>class</span> spline1dinterpolant(object):
    ...

</div></pre>
<a name='sub_spline1dbuildakima'></a><h3 class=pageheader><code>spline1dbuildakima</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# This subroutine builds Akima spline interpolant
# 
# INPUT PARAMETERS:
#     X           -   spline nodes, array[0..N-1]
#     Y           -   function values, array[0..N-1]
#     N           -   points count (optional):
#                     * N&gt;=5
#                     * if given, only first N points are used to build spline
#                     * if not given, automatically detected from X/Y sizes
#                       (len(X) must be equal to len(Y))
# 
# OUTPUT PARAMETERS:
#     C           -   spline interpolant
# 
# 
# ORDER OF POINTS
# 
# Subroutine automatically sorts points, so caller may pass unsorted array.
# 
#   -- ALGLIB PROJECT --
#      Copyright 24.06.2007 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: c = xalglib.spline1dbuildakima(x, y, n)
SYNTAX: c = xalglib.spline1dbuildakima(x, y)

</div></pre>
<a name='sub_spline1dbuildcatmullrom'></a><h3 class=pageheader><code>spline1dbuildcatmullrom</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# This subroutine builds Catmull-Rom spline interpolant.
# 
# INPUT PARAMETERS:
#     X           -   spline nodes, array[0..N-1].
#     Y           -   function values, array[0..N-1].
# 
# OPTIONAL PARAMETERS:
#     N           -   points count:
#                     * N&gt;=2
#                     * if given, only first N points are used to build spline
#                     * if not given, automatically detected from X/Y sizes
#                       (len(X) must be equal to len(Y))
#     BoundType   -   boundary condition type:
#                     * -1 for periodic boundary condition
#                     *  0 for parabolically terminated spline (default)
#     Tension     -   tension parameter:
#                     * tension=0   corresponds to classic Catmull-Rom spline (default)
#                     * 0&lt;tension&lt;1 corresponds to more general form - cardinal spline
# 
# OUTPUT PARAMETERS:
#     C           -   spline interpolant
# 
# 
# ORDER OF POINTS
# 
# Subroutine automatically sorts points, so caller may pass unsorted array.
# 
# PROBLEMS WITH PERIODIC BOUNDARY CONDITIONS:
# 
# Problems with periodic boundary conditions have Y[first_point]=Y[last_point].
# However, this subroutine doesn't require you to specify equal  values  for
# the first and last points - it automatically forces them  to  be  equal by
# copying  Y[first_point]  (corresponds  to the leftmost,  minimal  X[])  to
# Y[last_point]. However it is recommended to pass consistent values of Y[],
# i.e. to make Y[first_point]=Y[last_point].
# 
#   -- ALGLIB PROJECT --
#      Copyright 23.06.2007 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: c = xalglib.spline1dbuildcatmullrom(x, y, n, boundtype, tension)
SYNTAX: c = xalglib.spline1dbuildcatmullrom(x, y)

</div></pre>
<a name='sub_spline1dbuildcubic'></a><h3 class=pageheader><code>spline1dbuildcubic</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# This subroutine builds cubic spline interpolant.
# 
# INPUT PARAMETERS:
#     X           -   spline nodes, array[0..N-1].
#     Y           -   function values, array[0..N-1].
# 
# OPTIONAL PARAMETERS:
#     N           -   points count:
#                     * N&gt;=2
#                     * if given, only first N points are used to build spline
#                     * if not given, automatically detected from X/Y sizes
#                       (len(X) must be equal to len(Y))
#     BoundLType  -   boundary condition type for the left boundary
#     BoundL      -   left boundary condition (first or second derivative,
#                     depending on the BoundLType)
#     BoundRType  -   boundary condition type for the right boundary
#     BoundR      -   right boundary condition (first or second derivative,
#                     depending on the BoundRType)
# 
# OUTPUT PARAMETERS:
#     C           -   spline interpolant
# 
# ORDER OF POINTS
# 
# Subroutine automatically sorts points, so caller may pass unsorted array.
# 
# SETTING BOUNDARY VALUES:
# 
# The BoundLType/BoundRType parameters can have the following values:
#     * -1, which corresonds to the periodic (cyclic) boundary conditions.
#           In this case:
#           * both BoundLType and BoundRType must be equal to -1.
#           * BoundL/BoundR are ignored
#           * Y[last] is ignored (it is assumed to be equal to Y[first]).
#     *  0, which  corresponds  to  the  parabolically   terminated  spline
#           (BoundL and/or BoundR are ignored).
#     *  1, which corresponds to the first derivative boundary condition
#     *  2, which corresponds to the second derivative boundary condition
#     *  by default, BoundType=0 is used
# 
# PROBLEMS WITH PERIODIC BOUNDARY CONDITIONS:
# 
# Problems with periodic boundary conditions have Y[first_point]=Y[last_point].
# However, this subroutine doesn't require you to specify equal  values  for
# the first and last points - it automatically forces them  to  be  equal by
# copying  Y[first_point]  (corresponds  to the leftmost,  minimal  X[])  to
# Y[last_point]. However it is recommended to pass consistent values of Y[],
# i.e. to make Y[first_point]=Y[last_point].
# 
#   -- ALGLIB PROJECT --
#      Copyright 23.06.2007 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: c = xalglib.spline1dbuildcubic(x, y, n, boundltype, boundl, boundrtype, boundr)
SYNTAX: c = xalglib.spline1dbuildcubic(x, y)

</div></pre>
<a name='sub_spline1dbuildhermite'></a><h3 class=pageheader><code>spline1dbuildhermite</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# This subroutine builds Hermite spline interpolant.
# 
# INPUT PARAMETERS:
#     X           -   spline nodes, array[0..N-1]
#     Y           -   function values, array[0..N-1]
#     D           -   derivatives, array[0..N-1]
#     N           -   points count (optional):
#                     * N&gt;=2
#                     * if given, only first N points are used to build spline
#                     * if not given, automatically detected from X/Y sizes
#                       (len(X) must be equal to len(Y))
# 
# OUTPUT PARAMETERS:
#     C           -   spline interpolant.
# 
# 
# ORDER OF POINTS
# 
# Subroutine automatically sorts points, so caller may pass unsorted array.
# 
#   -- ALGLIB PROJECT --
#      Copyright 23.06.2007 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: c = xalglib.spline1dbuildhermite(x, y, d, n)
SYNTAX: c = xalglib.spline1dbuildhermite(x, y, d)

</div></pre>
<a name='sub_spline1dbuildlinear'></a><h3 class=pageheader><code>spline1dbuildlinear</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# This subroutine builds linear spline interpolant
# 
# INPUT PARAMETERS:
#     X   -   spline nodes, array[0..N-1]
#     Y   -   function values, array[0..N-1]
#     N   -   points count (optional):
#             * N&gt;=2
#             * if given, only first N points are used to build spline
#             * if not given, automatically detected from X/Y sizes
#               (len(X) must be equal to len(Y))
# 
# OUTPUT PARAMETERS:
#     C   -   spline interpolant
# 
# 
# ORDER OF POINTS
# 
# Subroutine automatically sorts points, so caller may pass unsorted array.
# 
#   -- ALGLIB PROJECT --
#      Copyright 24.06.2007 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: c = xalglib.spline1dbuildlinear(x, y, n)
SYNTAX: c = xalglib.spline1dbuildlinear(x, y)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_spline1d_d_linear' class=nav>[1]</a>&nbsp;&nbsp;<a href='#example_spline1d_d_cubic' class=nav>[2]</a>&nbsp;&nbsp;</p>
<a name='sub_spline1dcalc'></a><h3 class=pageheader><code>spline1dcalc</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# This subroutine calculates the value of the spline at the given point X.
# 
# INPUT PARAMETERS:
#     C   -   spline interpolant
#     X   -   point
# 
# Result:
#     S(x)
# 
#   -- ALGLIB PROJECT --
#      Copyright 23.06.2007 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.spline1dcalc(c, x)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_spline1d_d_linear' class=nav>[1]</a>&nbsp;&nbsp;<a href='#example_spline1d_d_cubic' class=nav>[2]</a>&nbsp;&nbsp;</p>
<a name='sub_spline1dconvcubic'></a><h3 class=pageheader><code>spline1dconvcubic</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# This function solves following problem: given table y[] of function values
# at old nodes x[]  and new nodes  x2[],  it calculates and returns table of
# function values y2[] (calculated at x2[]).
# 
# This function yields same result as Spline1DBuildCubic() call followed  by
# sequence of Spline1DDiff() calls, but it can be several times faster  when
# called for ordered X[] and X2[].
# 
# INPUT PARAMETERS:
#     X           -   old spline nodes
#     Y           -   function values
#     X2           -  new spline nodes
# 
# OPTIONAL PARAMETERS:
#     N           -   points count:
#                     * N&gt;=2
#                     * if given, only first N points from X/Y are used
#                     * if not given, automatically detected from X/Y sizes
#                       (len(X) must be equal to len(Y))
#     BoundLType  -   boundary condition type for the left boundary
#     BoundL      -   left boundary condition (first or second derivative,
#                     depending on the BoundLType)
#     BoundRType  -   boundary condition type for the right boundary
#     BoundR      -   right boundary condition (first or second derivative,
#                     depending on the BoundRType)
#     N2          -   new points count:
#                     * N2&gt;=2
#                     * if given, only first N2 points from X2 are used
#                     * if not given, automatically detected from X2 size
# 
# OUTPUT PARAMETERS:
#     F2          -   function values at X2[]
# 
# ORDER OF POINTS
# 
# Subroutine automatically sorts points, so caller  may pass unsorted array.
# Function  values  are correctly reordered on  return, so F2[I]  is  always
# equal to S(X2[I]) independently of points order.
# 
# SETTING BOUNDARY VALUES:
# 
# The BoundLType/BoundRType parameters can have the following values:
#     * -1, which corresonds to the periodic (cyclic) boundary conditions.
#           In this case:
#           * both BoundLType and BoundRType must be equal to -1.
#           * BoundL/BoundR are ignored
#           * Y[last] is ignored (it is assumed to be equal to Y[first]).
#     *  0, which  corresponds  to  the  parabolically   terminated  spline
#           (BoundL and/or BoundR are ignored).
#     *  1, which corresponds to the first derivative boundary condition
#     *  2, which corresponds to the second derivative boundary condition
#     *  by default, BoundType=0 is used
# 
# PROBLEMS WITH PERIODIC BOUNDARY CONDITIONS:
# 
# Problems with periodic boundary conditions have Y[first_point]=Y[last_point].
# However, this subroutine doesn't require you to specify equal  values  for
# the first and last points - it automatically forces them  to  be  equal by
# copying  Y[first_point]  (corresponds  to the leftmost,  minimal  X[])  to
# Y[last_point]. However it is recommended to pass consistent values of Y[],
# i.e. to make Y[first_point]=Y[last_point].
# 
#   -- ALGLIB PROJECT --
#      Copyright 03.09.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: y2 = xalglib.spline1dconvcubic(x, y, n, boundltype, boundl, boundrtype, boundr, x2, n2)
SYNTAX: y2 = xalglib.spline1dconvcubic(x, y, x2)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_spline1d_d_convdiff' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_spline1dconvdiff2cubic'></a><h3 class=pageheader><code>spline1dconvdiff2cubic</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# This function solves following problem: given table y[] of function values
# at old nodes x[]  and new nodes  x2[],  it calculates and returns table of
# function  values  y2[],  first  and  second  derivatives  d2[]  and  dd2[]
# (calculated at x2[]).
# 
# This function yields same result as Spline1DBuildCubic() call followed  by
# sequence of Spline1DDiff() calls, but it can be several times faster  when
# called for ordered X[] and X2[].
# 
# INPUT PARAMETERS:
#     X           -   old spline nodes
#     Y           -   function values
#     X2           -  new spline nodes
# 
# OPTIONAL PARAMETERS:
#     N           -   points count:
#                     * N&gt;=2
#                     * if given, only first N points from X/Y are used
#                     * if not given, automatically detected from X/Y sizes
#                       (len(X) must be equal to len(Y))
#     BoundLType  -   boundary condition type for the left boundary
#     BoundL      -   left boundary condition (first or second derivative,
#                     depending on the BoundLType)
#     BoundRType  -   boundary condition type for the right boundary
#     BoundR      -   right boundary condition (first or second derivative,
#                     depending on the BoundRType)
#     N2          -   new points count:
#                     * N2&gt;=2
#                     * if given, only first N2 points from X2 are used
#                     * if not given, automatically detected from X2 size
# 
# OUTPUT PARAMETERS:
#     F2          -   function values at X2[]
#     D2          -   first derivatives at X2[]
#     DD2         -   second derivatives at X2[]
# 
# ORDER OF POINTS
# 
# Subroutine automatically sorts points, so caller  may pass unsorted array.
# Function  values  are correctly reordered on  return, so F2[I]  is  always
# equal to S(X2[I]) independently of points order.
# 
# SETTING BOUNDARY VALUES:
# 
# The BoundLType/BoundRType parameters can have the following values:
#     * -1, which corresonds to the periodic (cyclic) boundary conditions.
#           In this case:
#           * both BoundLType and BoundRType must be equal to -1.
#           * BoundL/BoundR are ignored
#           * Y[last] is ignored (it is assumed to be equal to Y[first]).
#     *  0, which  corresponds  to  the  parabolically   terminated  spline
#           (BoundL and/or BoundR are ignored).
#     *  1, which corresponds to the first derivative boundary condition
#     *  2, which corresponds to the second derivative boundary condition
#     *  by default, BoundType=0 is used
# 
# PROBLEMS WITH PERIODIC BOUNDARY CONDITIONS:
# 
# Problems with periodic boundary conditions have Y[first_point]=Y[last_point].
# However, this subroutine doesn't require you to specify equal  values  for
# the first and last points - it automatically forces them  to  be  equal by
# copying  Y[first_point]  (corresponds  to the leftmost,  minimal  X[])  to
# Y[last_point]. However it is recommended to pass consistent values of Y[],
# i.e. to make Y[first_point]=Y[last_point].
# 
#   -- ALGLIB PROJECT --
#      Copyright 03.09.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: y2, d2, dd2 = xalglib.spline1dconvdiff2cubic(x, y, n, boundltype, boundl, boundrtype, boundr, x2, n2)
SYNTAX: y2, d2, dd2 = xalglib.spline1dconvdiff2cubic(x, y, x2)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_spline1d_d_convdiff' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_spline1dconvdiffcubic'></a><h3 class=pageheader><code>spline1dconvdiffcubic</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# This function solves following problem: given table y[] of function values
# at old nodes x[]  and new nodes  x2[],  it calculates and returns table of
# function values y2[] and derivatives d2[] (calculated at x2[]).
# 
# This function yields same result as Spline1DBuildCubic() call followed  by
# sequence of Spline1DDiff() calls, but it can be several times faster  when
# called for ordered X[] and X2[].
# 
# INPUT PARAMETERS:
#     X           -   old spline nodes
#     Y           -   function values
#     X2           -  new spline nodes
# 
# OPTIONAL PARAMETERS:
#     N           -   points count:
#                     * N&gt;=2
#                     * if given, only first N points from X/Y are used
#                     * if not given, automatically detected from X/Y sizes
#                       (len(X) must be equal to len(Y))
#     BoundLType  -   boundary condition type for the left boundary
#     BoundL      -   left boundary condition (first or second derivative,
#                     depending on the BoundLType)
#     BoundRType  -   boundary condition type for the right boundary
#     BoundR      -   right boundary condition (first or second derivative,
#                     depending on the BoundRType)
#     N2          -   new points count:
#                     * N2&gt;=2
#                     * if given, only first N2 points from X2 are used
#                     * if not given, automatically detected from X2 size
# 
# OUTPUT PARAMETERS:
#     F2          -   function values at X2[]
#     D2          -   first derivatives at X2[]
# 
# ORDER OF POINTS
# 
# Subroutine automatically sorts points, so caller  may pass unsorted array.
# Function  values  are correctly reordered on  return, so F2[I]  is  always
# equal to S(X2[I]) independently of points order.
# 
# SETTING BOUNDARY VALUES:
# 
# The BoundLType/BoundRType parameters can have the following values:
#     * -1, which corresonds to the periodic (cyclic) boundary conditions.
#           In this case:
#           * both BoundLType and BoundRType must be equal to -1.
#           * BoundL/BoundR are ignored
#           * Y[last] is ignored (it is assumed to be equal to Y[first]).
#     *  0, which  corresponds  to  the  parabolically   terminated  spline
#           (BoundL and/or BoundR are ignored).
#     *  1, which corresponds to the first derivative boundary condition
#     *  2, which corresponds to the second derivative boundary condition
#     *  by default, BoundType=0 is used
# 
# PROBLEMS WITH PERIODIC BOUNDARY CONDITIONS:
# 
# Problems with periodic boundary conditions have Y[first_point]=Y[last_point].
# However, this subroutine doesn't require you to specify equal  values  for
# the first and last points - it automatically forces them  to  be  equal by
# copying  Y[first_point]  (corresponds  to the leftmost,  minimal  X[])  to
# Y[last_point]. However it is recommended to pass consistent values of Y[],
# i.e. to make Y[first_point]=Y[last_point].
# 
#   -- ALGLIB PROJECT --
#      Copyright 03.09.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: y2, d2 = xalglib.spline1dconvdiffcubic(x, y, n, boundltype, boundl, boundrtype, boundr, x2, n2)
SYNTAX: y2, d2 = xalglib.spline1dconvdiffcubic(x, y, x2)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_spline1d_d_convdiff' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_spline1ddiff'></a><h3 class=pageheader><code>spline1ddiff</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# This subroutine differentiates the spline.
# 
# INPUT PARAMETERS:
#     C   -   spline interpolant.
#     X   -   point
# 
# Result:
#     S   -   S(x)
#     DS  -   S'(x)
#     D2S -   S''(x)
# 
#   -- ALGLIB PROJECT --
#      Copyright 24.06.2007 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: s, ds, d2s = xalglib.spline1ddiff(c, x)

</div></pre>
<a name='sub_spline1dgriddiff2cubic'></a><h3 class=pageheader><code>spline1dgriddiff2cubic</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# This function solves following problem: given table y[] of function values
# at  nodes  x[],  it  calculates  and  returns  tables  of first and second
# function derivatives d1[] and d2[] (calculated at the same nodes x[]).
# 
# This function yields same result as Spline1DBuildCubic() call followed  by
# sequence of Spline1DDiff() calls, but it can be several times faster  when
# called for ordered X[] and X2[].
# 
# INPUT PARAMETERS:
#     X           -   spline nodes
#     Y           -   function values
# 
# OPTIONAL PARAMETERS:
#     N           -   points count:
#                     * N&gt;=2
#                     * if given, only first N points are used
#                     * if not given, automatically detected from X/Y sizes
#                       (len(X) must be equal to len(Y))
#     BoundLType  -   boundary condition type for the left boundary
#     BoundL      -   left boundary condition (first or second derivative,
#                     depending on the BoundLType)
#     BoundRType  -   boundary condition type for the right boundary
#     BoundR      -   right boundary condition (first or second derivative,
#                     depending on the BoundRType)
# 
# OUTPUT PARAMETERS:
#     D1          -   S' values at X[]
#     D2          -   S'' values at X[]
# 
# ORDER OF POINTS
# 
# Subroutine automatically sorts points, so caller may pass unsorted array.
# Derivative values are correctly reordered on return, so  D[I]  is  always
# equal to S'(X[I]) independently of points order.
# 
# SETTING BOUNDARY VALUES:
# 
# The BoundLType/BoundRType parameters can have the following values:
#     * -1, which corresonds to the periodic (cyclic) boundary conditions.
#           In this case:
#           * both BoundLType and BoundRType must be equal to -1.
#           * BoundL/BoundR are ignored
#           * Y[last] is ignored (it is assumed to be equal to Y[first]).
#     *  0, which  corresponds  to  the  parabolically   terminated  spline
#           (BoundL and/or BoundR are ignored).
#     *  1, which corresponds to the first derivative boundary condition
#     *  2, which corresponds to the second derivative boundary condition
#     *  by default, BoundType=0 is used
# 
# PROBLEMS WITH PERIODIC BOUNDARY CONDITIONS:
# 
# Problems with periodic boundary conditions have Y[first_point]=Y[last_point].
# However, this subroutine doesn't require you to specify equal  values  for
# the first and last points - it automatically forces them  to  be  equal by
# copying  Y[first_point]  (corresponds  to the leftmost,  minimal  X[])  to
# Y[last_point]. However it is recommended to pass consistent values of Y[],
# i.e. to make Y[first_point]=Y[last_point].
# 
#   -- ALGLIB PROJECT --
#      Copyright 03.09.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: d1, d2 = xalglib.spline1dgriddiff2cubic(x, y, n, boundltype, boundl, boundrtype, boundr)
SYNTAX: d1, d2 = xalglib.spline1dgriddiff2cubic(x, y)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_spline1d_d_griddiff' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_spline1dgriddiffcubic'></a><h3 class=pageheader><code>spline1dgriddiffcubic</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# This function solves following problem: given table y[] of function values
# at nodes x[], it calculates and returns table of function derivatives  d[]
# (calculated at the same nodes x[]).
# 
# This function yields same result as Spline1DBuildCubic() call followed  by
# sequence of Spline1DDiff() calls, but it can be several times faster  when
# called for ordered X[] and X2[].
# 
# INPUT PARAMETERS:
#     X           -   spline nodes
#     Y           -   function values
# 
# OPTIONAL PARAMETERS:
#     N           -   points count:
#                     * N&gt;=2
#                     * if given, only first N points are used
#                     * if not given, automatically detected from X/Y sizes
#                       (len(X) must be equal to len(Y))
#     BoundLType  -   boundary condition type for the left boundary
#     BoundL      -   left boundary condition (first or second derivative,
#                     depending on the BoundLType)
#     BoundRType  -   boundary condition type for the right boundary
#     BoundR      -   right boundary condition (first or second derivative,
#                     depending on the BoundRType)
# 
# OUTPUT PARAMETERS:
#     D           -   derivative values at X[]
# 
# ORDER OF POINTS
# 
# Subroutine automatically sorts points, so caller may pass unsorted array.
# Derivative values are correctly reordered on return, so  D[I]  is  always
# equal to S'(X[I]) independently of points order.
# 
# SETTING BOUNDARY VALUES:
# 
# The BoundLType/BoundRType parameters can have the following values:
#     * -1, which corresonds to the periodic (cyclic) boundary conditions.
#           In this case:
#           * both BoundLType and BoundRType must be equal to -1.
#           * BoundL/BoundR are ignored
#           * Y[last] is ignored (it is assumed to be equal to Y[first]).
#     *  0, which  corresponds  to  the  parabolically   terminated  spline
#           (BoundL and/or BoundR are ignored).
#     *  1, which corresponds to the first derivative boundary condition
#     *  2, which corresponds to the second derivative boundary condition
#     *  by default, BoundType=0 is used
# 
# PROBLEMS WITH PERIODIC BOUNDARY CONDITIONS:
# 
# Problems with periodic boundary conditions have Y[first_point]=Y[last_point].
# However, this subroutine doesn't require you to specify equal  values  for
# the first and last points - it automatically forces them  to  be  equal by
# copying  Y[first_point]  (corresponds  to the leftmost,  minimal  X[])  to
# Y[last_point]. However it is recommended to pass consistent values of Y[],
# i.e. to make Y[first_point]=Y[last_point].
# 
#   -- ALGLIB PROJECT --
#      Copyright 03.09.2010 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: d = xalglib.spline1dgriddiffcubic(x, y, n, boundltype, boundl, boundrtype, boundr)
SYNTAX: d = xalglib.spline1dgriddiffcubic(x, y)

</div></pre>
<p align=left class=pagecontent><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_spline1d_d_griddiff' class=nav>[1]</a>&nbsp;&nbsp;</p>
<a name='sub_spline1dintegrate'></a><h3 class=pageheader><code>spline1dintegrate</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# This subroutine integrates the spline.
# 
# INPUT PARAMETERS:
#     C   -   spline interpolant.
#     X   -   right bound of the integration interval [a, x],
#             here 'a' denotes min(x[])
# Result:
#     integral(S(t)dt,a,x)
# 
#   -- ALGLIB PROJECT --
#      Copyright 23.06.2007 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.spline1dintegrate(c, x)

</div></pre>
<a name='sub_spline1dlintransx'></a><h3 class=pageheader><code>spline1dlintransx</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# This subroutine performs linear transformation of the spline argument.
# 
# INPUT PARAMETERS:
#     C   -   spline interpolant.
#     A, B-   transformation coefficients: x = A*t + B
# Result:
#     C   -   transformed spline
# 
#   -- ALGLIB PROJECT --
#      Copyright 30.06.2007 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: xalglib.spline1dlintransx(c, a, b)

</div></pre>
<a name='sub_spline1dlintransy'></a><h3 class=pageheader><code>spline1dlintransy</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# This subroutine performs linear transformation of the spline.
# 
# INPUT PARAMETERS:
#     C   -   spline interpolant.
#     A, B-   transformation coefficients: S2(x) = A*S(x) + B
# Result:
#     C   -   transformed spline
# 
#   -- ALGLIB PROJECT --
#      Copyright 30.06.2007 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: xalglib.spline1dlintransy(c, a, b)

</div></pre>
<a name='sub_spline1dunpack'></a><h3 class=pageheader><code>spline1dunpack</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# This subroutine unpacks the spline into the coefficients table.
# 
# INPUT PARAMETERS:
#     C   -   spline interpolant.
#     X   -   point
# 
# Result:
#     Tbl -   coefficients table, unpacked format, array[0..N-2, 0..5].
#             For I = 0...N-2:
#                 Tbl[I,0] = X[i]
#                 Tbl[I,1] = X[i+1]
#                 Tbl[I,2] = C0
#                 Tbl[I,3] = C1
#                 Tbl[I,4] = C2
#                 Tbl[I,5] = C3
#             On [x[i], x[i+1]] spline is equals to:
#                 S(x) = C0 + C1*t + C2*t^2 + C3*t^3
#                 t = x-x[i]
# 
#   -- ALGLIB PROJECT --
#      Copyright 29.06.2007 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: n, tbl = xalglib.spline1dunpack(c)

</div></pre>
<a name='example_spline1d_d_convdiff'></a><h3 class=pageheader>spline1d_d_convdiff example</h3>
<pre class=source>
import xalglib



<font color=darkcyan>#</font>
<font color=darkcyan># We use cubic spline to <b>do</b> resampling, i.e. having</font>
<font color=darkcyan># values of f(x)=x^2 sampled at 5 equidistant nodes on [-1,+1]</font>
<font color=darkcyan># we calculate values/derivatives of cubic spline on </font>
<font color=darkcyan># another grid (equidistant with 9 nodes on [-1,+1])</font>
<font color=darkcyan># WITHOUT CONSTRUCTION OF SPLINE OBJECT.</font>
<font color=darkcyan>#</font>
<font color=darkcyan># There are efficient functions spline1dconvcubic(),</font>
<font color=darkcyan># spline1dconvdiffcubic() and spline1dconvdiff2cubic() </font>
<font color=darkcyan># <b>for</b> such calculations.</font>
<font color=darkcyan>#</font>
<font color=darkcyan># We use default boundary conditions (&quot;parabolically terminated</font>
<font color=darkcyan># spline&quot;) because cubic spline built with such boundary conditions </font>
<font color=darkcyan># will exactly reproduce any quadratic f(x).</font>
<font color=darkcyan>#</font>
<font color=darkcyan># Actually, we could use natural conditions, but we feel that </font>
<font color=darkcyan># spline which exactly reproduces f() will show us more </font>
<font color=darkcyan># understandable results.</font>
<font color=darkcyan>#</font>
x_old = [-1.0,-0.5,0.0,+0.5,+1.0]
y_old = [+1.0,0.25,0.0,0.25,+1.0]
x_new = [-1.00,-0.75,-0.50,-0.25,0.00,+0.25,+0.50,+0.75,+1.00]

<font color=darkcyan>#</font>
<font color=darkcyan># First, conversion without differentiation.</font>
<font color=darkcyan>#</font>
<font color=darkcyan>#</font>
y_new = xalglib.spline1dconvcubic(x_old, y_old, x_new)
print(y_new) <font color=darkcyan># expected [1.0000, 0.5625, 0.2500, 0.0625, 0.0000, 0.0625, 0.2500, 0.5625, 1.0000]</font>

<font color=darkcyan>#</font>
<font color=darkcyan># Then, conversion with differentiation (first derivatives only)</font>
<font color=darkcyan>#</font>
<font color=darkcyan>#</font>
y_new, d1_new = xalglib.spline1dconvdiffcubic(x_old, y_old, x_new)
print(y_new) <font color=darkcyan># expected [1.0000, 0.5625, 0.2500, 0.0625, 0.0000, 0.0625, 0.2500, 0.5625, 1.0000]</font>
print(d1_new) <font color=darkcyan># expected [-2.0, -1.5, -1.0, -0.5, 0.0, 0.5, 1.0, 1.5, 2.0]</font>

<font color=darkcyan>#</font>
<font color=darkcyan># Finally, conversion with first and second derivatives</font>
<font color=darkcyan>#</font>
<font color=darkcyan>#</font>
y_new, d1_new, d2_new = xalglib.spline1dconvdiff2cubic(x_old, y_old, x_new)
print(y_new) <font color=darkcyan># expected [1.0000, 0.5625, 0.2500, 0.0625, 0.0000, 0.0625, 0.2500, 0.5625, 1.0000]</font>
print(d1_new) <font color=darkcyan># expected [-2.0, -1.5, -1.0, -0.5, 0.0, 0.5, 1.0, 1.5, 2.0]</font>
print(d2_new) <font color=darkcyan># expected [2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0]</font>


</pre><a name='example_spline1d_d_cubic'></a><h3 class=pageheader>spline1d_d_cubic example</h3>
<pre class=source>
import xalglib



<font color=darkcyan>#</font>
<font color=darkcyan># We use cubic spline to interpolate f(x)=x^2 sampled </font>
<font color=darkcyan># at 5 equidistant nodes on [-1,+1].</font>
<font color=darkcyan>#</font>
<font color=darkcyan># First, we use default boundary conditions (&quot;parabolically terminated</font>
<font color=darkcyan># spline&quot;) because cubic spline built with such boundary conditions </font>
<font color=darkcyan># will exactly reproduce any quadratic f(x).</font>
<font color=darkcyan>#</font>
<font color=darkcyan># Then we try to use natural boundary conditions</font>
<font color=darkcyan>#     d2S(-1)/dx^2 = 0.0</font>
<font color=darkcyan>#     d2S(+1)/dx^2 = 0.0</font>
<font color=darkcyan># and see that such spline interpolated f(x) with small error.</font>
<font color=darkcyan>#</font>
x = [-1.0,-0.5,0.0,+0.5,+1.0]
y = [+1.0,0.25,0.0,0.25,+1.0]
t = 0.25
natural_bound_type = 2
<font color=darkcyan>#</font>
<font color=darkcyan># Test exact boundary conditions: build S(x), calculare S(0.25)</font>
<font color=darkcyan># (almost same as original function)</font>
<font color=darkcyan>#</font>
s = xalglib.spline1dbuildcubic(x, y)
v = xalglib.spline1dcalc(s, t)
print(v) <font color=darkcyan># expected 0.0625</font>

<font color=darkcyan>#</font>
<font color=darkcyan># Test natural boundary conditions: build S(x), calculare S(0.25)</font>
<font color=darkcyan># (small interpolation error)</font>
<font color=darkcyan>#</font>
s = xalglib.spline1dbuildcubic(x, y, 5, natural_bound_type, 0.0, natural_bound_type, 0.0)
v = xalglib.spline1dcalc(s, t)
print(v) <font color=darkcyan># expected 0.0580</font>


</pre><a name='example_spline1d_d_griddiff'></a><h3 class=pageheader>spline1d_d_griddiff example</h3>
<pre class=source>
import xalglib



<font color=darkcyan>#</font>
<font color=darkcyan># We use cubic spline to <b>do</b> grid differentiation, i.e. having</font>
<font color=darkcyan># values of f(x)=x^2 sampled at 5 equidistant nodes on [-1,+1]</font>
<font color=darkcyan># we calculate derivatives of cubic spline at nodes WITHOUT</font>
<font color=darkcyan># CONSTRUCTION OF SPLINE OBJECT.</font>
<font color=darkcyan>#</font>
<font color=darkcyan># There are efficient functions spline1dgriddiffcubic() and</font>
<font color=darkcyan># spline1dgriddiff2cubic() <b>for</b> such calculations.</font>
<font color=darkcyan>#</font>
<font color=darkcyan># We use default boundary conditions (&quot;parabolically terminated</font>
<font color=darkcyan># spline&quot;) because cubic spline built with such boundary conditions </font>
<font color=darkcyan># will exactly reproduce any quadratic f(x).</font>
<font color=darkcyan>#</font>
<font color=darkcyan># Actually, we could use natural conditions, but we feel that </font>
<font color=darkcyan># spline which exactly reproduces f() will show us more </font>
<font color=darkcyan># understandable results.</font>
<font color=darkcyan>#</font>
x = [-1.0,-0.5,0.0,+0.5,+1.0]
y = [+1.0,0.25,0.0,0.25,+1.0]

<font color=darkcyan>#</font>
<font color=darkcyan># We calculate first derivatives: they must be equal to 2*x</font>
<font color=darkcyan>#</font>
d1 = xalglib.spline1dgriddiffcubic(x, y)
print(d1) <font color=darkcyan># expected [-2.0, -1.0, 0.0, +1.0, +2.0]</font>

<font color=darkcyan>#</font>
<font color=darkcyan># Now test griddiff2, which returns first AND second derivatives.</font>
<font color=darkcyan># First derivative is 2*x, second is equal to 2.0</font>
<font color=darkcyan>#</font>
d1, d2 = xalglib.spline1dgriddiff2cubic(x, y)
print(d1) <font color=darkcyan># expected [-2.0, -1.0, 0.0, +1.0, +2.0]</font>
print(d2) <font color=darkcyan># expected [ 2.0,  2.0, 2.0,  2.0,  2.0]</font>


</pre><a name='example_spline1d_d_linear'></a><h3 class=pageheader>spline1d_d_linear example</h3>
<pre class=source>
import xalglib



<font color=darkcyan>#</font>
<font color=darkcyan># We use piecewise linear spline to interpolate f(x)=x^2 sampled </font>
<font color=darkcyan># at 5 equidistant nodes on [-1,+1].</font>
<font color=darkcyan>#</font>
x = [-1.0,-0.5,0.0,+0.5,+1.0]
y = [+1.0,0.25,0.0,0.25,+1.0]
t = 0.25

<font color=darkcyan># build spline</font>
s = xalglib.spline1dbuildlinear(x, y)

<font color=darkcyan># calculate S(0.25) - it is quite different from 0.25^2=0.0625</font>
v = xalglib.spline1dcalc(s, t)
print(v) <font color=darkcyan># expected 0.125</font>


</pre><a name=unit_spline2d></a><h2 class=pageheader><code>spline2d</code> module</h2>
<div class=pagecontent>
<h3 class=pageheader>Classes</h3>
<a href='#struct_spline2dinterpolant' class=toc>spline2dinterpolant</a><br>
<h3 class=pageheader>Functions</h3>
<a href='#sub_spline2dbuildbicubic' class=toc>spline2dbuildbicubic</a><br>
<a href='#sub_spline2dbuildbilinear' class=toc>spline2dbuildbilinear</a><br>
<a href='#sub_spline2dcalc' class=toc>spline2dcalc</a><br>
<a href='#sub_spline2ddiff' class=toc>spline2ddiff</a><br>
<a href='#sub_spline2dlintransf' class=toc>spline2dlintransf</a><br>
<a href='#sub_spline2dlintransxy' class=toc>spline2dlintransxy</a><br>
<a href='#sub_spline2dresamplebicubic' class=toc>spline2dresamplebicubic</a><br>
<a href='#sub_spline2dresamplebilinear' class=toc>spline2dresamplebilinear</a><br>
<a href='#sub_spline2dunpack' class=toc>spline2dunpack</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='struct_spline2dinterpolant'></a><h3 class=pageheader><code>spline2dinterpolant</code> class</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# 2-dimensional spline inteprolant
#

</div><div style='margin-top: 0; margin-bottom: 0;'><span style='font-weight: bold; color: green;'>class</span> spline2dinterpolant(object):
    ...

</div></pre>
<a name='sub_spline2dbuildbicubic'></a><h3 class=pageheader><code>spline2dbuildbicubic</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# This subroutine builds bicubic spline coefficients table.
# 
# Input parameters:
#     X   -   spline abscissas, array[0..N-1]
#     Y   -   spline ordinates, array[0..M-1]
#     F   -   function values, array[0..M-1,0..N-1]
#     M,N -   grid size, M&gt;=2, N&gt;=2
# 
# Output parameters:
#     C   -   spline interpolant
# 
#   -- ALGLIB PROJECT --
#      Copyright 05.07.2007 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: c = xalglib.spline2dbuildbicubic(x, y, f, m, n)

</div></pre>
<a name='sub_spline2dbuildbilinear'></a><h3 class=pageheader><code>spline2dbuildbilinear</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# This subroutine builds bilinear spline coefficients table.
# 
# Input parameters:
#     X   -   spline abscissas, array[0..N-1]
#     Y   -   spline ordinates, array[0..M-1]
#     F   -   function values, array[0..M-1,0..N-1]
#     M,N -   grid size, M&gt;=2, N&gt;=2
# 
# Output parameters:
#     C   -   spline interpolant
# 
#   -- ALGLIB PROJECT --
#      Copyright 05.07.2007 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: c = xalglib.spline2dbuildbilinear(x, y, f, m, n)

</div></pre>
<a name='sub_spline2dcalc'></a><h3 class=pageheader><code>spline2dcalc</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# This subroutine calculates the value of the bilinear or bicubic spline  at
# the given point X.
# 
# Input parameters:
#     C   -   coefficients table.
#             Built by BuildBilinearSpline or BuildBicubicSpline.
#     X, Y-   point
# 
# Result:
#     S(x,y)
# 
#   -- ALGLIB PROJECT --
#      Copyright 05.07.2007 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.spline2dcalc(c, x, y)

</div></pre>
<a name='sub_spline2ddiff'></a><h3 class=pageheader><code>spline2ddiff</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# This subroutine calculates the value of the bilinear or bicubic spline  at
# the given point X and its derivatives.
# 
# Input parameters:
#     C   -   spline interpolant.
#     X, Y-   point
# 
# Output parameters:
#     F   -   S(x,y)
#     FX  -   dS(x,y)/dX
#     FY  -   dS(x,y)/dY
#     FXY -   d2S(x,y)/dXdY
# 
#   -- ALGLIB PROJECT --
#      Copyright 05.07.2007 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: f, fx, fy, fxy = xalglib.spline2ddiff(c, x, y)

</div></pre>
<a name='sub_spline2dlintransf'></a><h3 class=pageheader><code>spline2dlintransf</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# This subroutine performs linear transformation of the spline.
# 
# Input parameters:
#     C   -   spline interpolant.
#     A, B-   transformation coefficients: S2(x,y) = A*S(x,y) + B
# 
# Output parameters:
#     C   -   transformed spline
# 
#   -- ALGLIB PROJECT --
#      Copyright 30.06.2007 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: xalglib.spline2dlintransf(c, a, b)

</div></pre>
<a name='sub_spline2dlintransxy'></a><h3 class=pageheader><code>spline2dlintransxy</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# This subroutine performs linear transformation of the spline argument.
# 
# Input parameters:
#     C       -   spline interpolant
#     AX, BX  -   transformation coefficients: x = A*t + B
#     AY, BY  -   transformation coefficients: y = A*u + B
# Result:
#     C   -   transformed spline
# 
#   -- ALGLIB PROJECT --
#      Copyright 30.06.2007 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: xalglib.spline2dlintransxy(c, ax, bx, ay, by)

</div></pre>
<a name='sub_spline2dresamplebicubic'></a><h3 class=pageheader><code>spline2dresamplebicubic</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Bicubic spline resampling
# 
# Input parameters:
#     A           -   function values at the old grid,
#                     array[0..OldHeight-1, 0..OldWidth-1]
#     OldHeight   -   old grid height, OldHeight&gt;1
#     OldWidth    -   old grid width, OldWidth&gt;1
#     NewHeight   -   new grid height, NewHeight&gt;1
#     NewWidth    -   new grid width, NewWidth&gt;1
# 
# Output parameters:
#     B           -   function values at the new grid,
#                     array[0..NewHeight-1, 0..NewWidth-1]
# 
#   -- ALGLIB routine --
#      15 May, 2007
#      Copyright by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: b = xalglib.spline2dresamplebicubic(a, oldheight, oldwidth, newheight, newwidth)

</div></pre>
<a name='sub_spline2dresamplebilinear'></a><h3 class=pageheader><code>spline2dresamplebilinear</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Bilinear spline resampling
# 
# Input parameters:
#     A           -   function values at the old grid,
#                     array[0..OldHeight-1, 0..OldWidth-1]
#     OldHeight   -   old grid height, OldHeight&gt;1
#     OldWidth    -   old grid width, OldWidth&gt;1
#     NewHeight   -   new grid height, NewHeight&gt;1
#     NewWidth    -   new grid width, NewWidth&gt;1
# 
# Output parameters:
#     B           -   function values at the new grid,
#                     array[0..NewHeight-1, 0..NewWidth-1]
# 
#   -- ALGLIB routine --
#      09.07.2007
#      Copyright by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: b = xalglib.spline2dresamplebilinear(a, oldheight, oldwidth, newheight, newwidth)

</div></pre>
<a name='sub_spline2dunpack'></a><h3 class=pageheader><code>spline2dunpack</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# This subroutine unpacks two-dimensional spline into the coefficients table
# 
# Input parameters:
#     C   -   spline interpolant.
# 
# Result:
#     M, N-   grid size (x-axis and y-axis)
#     Tbl -   coefficients table, unpacked format,
#             [0..(N-1)*(M-1)-1, 0..19].
#             For I = 0...M-2, J=0..N-2:
#                 K =  I*(N-1)+J
#                 Tbl[K,0] = X[j]
#                 Tbl[K,1] = X[j+1]
#                 Tbl[K,2] = Y[i]
#                 Tbl[K,3] = Y[i+1]
#                 Tbl[K,4] = C00
#                 Tbl[K,5] = C01
#                 Tbl[K,6] = C02
#                 Tbl[K,7] = C03
#                 Tbl[K,8] = C10
#                 Tbl[K,9] = C11
#                 ...
#                 Tbl[K,19] = C33
#             On each grid square spline is equals to:
#                 S(x) = SUM(c[i,j]*(x^i)*(y^j), i=0..3, j=0..3)
#                 t = x-x[j]
#                 u = y-y[i]
# 
#   -- ALGLIB PROJECT --
#      Copyright 29.06.2007 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: m, n, tbl = xalglib.spline2dunpack(c)

</div></pre>
<a name=unit_stest></a><h2 class=pageheader><code>stest</code> module</h2>
<div class=pagecontent>
<h3 class=pageheader>Functions</h3>
<a href='#sub_onesamplesigntest' class=toc>onesamplesigntest</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='sub_onesamplesigntest'></a><h3 class=pageheader><code>onesamplesigntest</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Sign test
# 
# This test checks three hypotheses about the median of  the  given  sample.
# The following tests are performed:
#     * two-tailed test (null hypothesis - the median is equal to the  given
#       value)
#     * left-tailed test (null hypothesis - the median is  greater  than  or
#       equal to the given value)
#     * right-tailed test (null hypothesis - the  median  is  less  than  or
#       equal to the given value)
# 
# Requirements:
#     * the scale of measurement should be ordinal, interval or ratio  (i.e.
#       the test could not be applied to nominal variables).
# 
# The test is non-parametric and doesn't require distribution X to be normal
# 
# Input parameters:
#     X       -   sample. Array whose index goes from 0 to N-1.
#     N       -   size of the sample.
#     Median  -   assumed median value.
# 
# Output parameters:
#     BothTails   -   p-value for two-tailed test.
#                     If BothTails is less than the given significance level
#                     the null hypothesis is rejected.
#     LeftTail    -   p-value for left-tailed test.
#                     If LeftTail is less than the given significance level,
#                     the null hypothesis is rejected.
#     RightTail   -   p-value for right-tailed test.
#                     If RightTail is less than the given significance level
#                     the null hypothesis is rejected.
# 
# While   calculating   p-values   high-precision   binomial    distribution
# approximation is used, so significance levels have about 15 exact digits.
# 
#   -- ALGLIB --
#      Copyright 08.09.2006 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: bothtails, lefttail, righttail = xalglib.onesamplesigntest(x, n, median)

</div></pre>
<a name=unit_studenttdistr></a><h2 class=pageheader><code>studenttdistr</code> module</h2>
<div class=pagecontent>
<h3 class=pageheader>Functions</h3>
<a href='#sub_invstudenttdistribution' class=toc>invstudenttdistribution</a><br>
<a href='#sub_studenttdistribution' class=toc>studenttdistribution</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='sub_invstudenttdistribution'></a><h3 class=pageheader><code>invstudenttdistribution</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Functional inverse of Student's t distribution
# 
# Given probability p, finds the argument t such that stdtr(k,t)
# is equal to p.
# 
# ACCURACY:
# 
# Tested at random 1 &lt;= k &lt;= 100.  The &quot;domain&quot; refers to p:
#                      Relative error:
# arithmetic   domain     # trials      peak         rms
#    IEEE    .001,.999     25000       5.7e-15     8.0e-16
#    IEEE    10^-6,.001    25000       2.0e-12     2.9e-14
# 
# Cephes Math Library Release 2.8:  June, 2000
# Copyright 1984, 1987, 1995, 2000 by Stephen L. Moshier
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.invstudenttdistribution(k, p)

</div></pre>
<a name='sub_studenttdistribution'></a><h3 class=pageheader><code>studenttdistribution</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Student's t distribution
# 
# Computes the integral from minus infinity to t of the Student
# t distribution with integer k &gt; 0 degrees of freedom:
# 
#                                      t
#                                      -
#                                     | |
#              -                      |         2   -(k+1)/2
#             | ( (k+1)/2 )           |  (     x   )
#       ----------------------        |  ( 1 + --- )        dx
#                     -               |  (      k  )
#       sqrt( k pi ) | ( k/2 )        |
#                                   | |
#                                    -
#                                   -inf.
# 
# Relation to incomplete beta integral:
# 
#        1 - stdtr(k,t) = 0.5 * incbet( k/2, 1/2, z )
# where
#        z = k/(k + t**2).
# 
# For t &lt; -2, this is the method of computation.  For higher t,
# a direct method is derived from integration by parts.
# Since the function is symmetric about t=0, the area under the
# right tail of the density is found by calling the function
# with -t instead of t.
# 
# ACCURACY:
# 
# Tested at random 1 &lt;= k &lt;= 25.  The &quot;domain&quot; refers to t.
#                      Relative error:
# arithmetic   domain     # trials      peak         rms
#    IEEE     -100,-2      50000       5.9e-15     1.4e-15
#    IEEE     -2,100      500000       2.7e-15     4.9e-17
# 
# Cephes Math Library Release 2.8:  June, 2000
# Copyright 1984, 1987, 1995, 2000 by Stephen L. Moshier
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result = xalglib.studenttdistribution(k, t)

</div></pre>
<a name=unit_studentttests></a><h2 class=pageheader><code>studentttests</code> module</h2>
<div class=pagecontent>
<h3 class=pageheader>Functions</h3>
<a href='#sub_studentttest1' class=toc>studentttest1</a><br>
<a href='#sub_studentttest2' class=toc>studentttest2</a><br>
<a href='#sub_unequalvariancettest' class=toc>unequalvariancettest</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='sub_studentttest1'></a><h3 class=pageheader><code>studentttest1</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# One-sample t-test
# 
# This test checks three hypotheses about the mean of the given sample.  The
# following tests are performed:
#     * two-tailed test (null hypothesis - the mean is equal  to  the  given
#       value)
#     * left-tailed test (null hypothesis - the  mean  is  greater  than  or
#       equal to the given value)
#     * right-tailed test (null hypothesis - the mean is less than or  equal
#       to the given value).
# 
# The test is based on the assumption that  a  given  sample  has  a  normal
# distribution and  an  unknown  dispersion.  If  the  distribution  sharply
# differs from normal, the test will work incorrectly.
# 
# Input parameters:
#     X       -   sample. Array whose index goes from 0 to N-1.
#     N       -   size of sample.
#     Mean    -   assumed value of the mean.
# 
# Output parameters:
#     BothTails   -   p-value for two-tailed test.
#                     If BothTails is less than the given significance level
#                     the null hypothesis is rejected.
#     LeftTail    -   p-value for left-tailed test.
#                     If LeftTail is less than the given significance level,
#                     the null hypothesis is rejected.
#     RightTail   -   p-value for right-tailed test.
#                     If RightTail is less than the given significance level
#                     the null hypothesis is rejected.
# 
#   -- ALGLIB --
#      Copyright 08.09.2006 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: bothtails, lefttail, righttail = xalglib.studentttest1(x, n, mean)

</div></pre>
<a name='sub_studentttest2'></a><h3 class=pageheader><code>studentttest2</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Two-sample pooled test
# 
# This test checks three hypotheses about the mean of the given samples. The
# following tests are performed:
#     * two-tailed test (null hypothesis - the means are equal)
#     * left-tailed test (null hypothesis - the mean of the first sample  is
#       greater than or equal to the mean of the second sample)
#     * right-tailed test (null hypothesis - the mean of the first sample is
#       less than or equal to the mean of the second sample).
# 
# Test is based on the following assumptions:
#     * given samples have normal distributions
#     * dispersions are equal
#     * samples are independent.
# 
# Input parameters:
#     X       -   sample 1. Array whose index goes from 0 to N-1.
#     N       -   size of sample.
#     Y       -   sample 2. Array whose index goes from 0 to M-1.
#     M       -   size of sample.
# 
# Output parameters:
#     BothTails   -   p-value for two-tailed test.
#                     If BothTails is less than the given significance level
#                     the null hypothesis is rejected.
#     LeftTail    -   p-value for left-tailed test.
#                     If LeftTail is less than the given significance level,
#                     the null hypothesis is rejected.
#     RightTail   -   p-value for right-tailed test.
#                     If RightTail is less than the given significance level
#                     the null hypothesis is rejected.
# 
#   -- ALGLIB --
#      Copyright 18.09.2006 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: bothtails, lefttail, righttail = xalglib.studentttest2(x, n, y, m)

</div></pre>
<a name='sub_unequalvariancettest'></a><h3 class=pageheader><code>unequalvariancettest</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Two-sample unpooled test
# 
# This test checks three hypotheses about the mean of the given samples. The
# following tests are performed:
#     * two-tailed test (null hypothesis - the means are equal)
#     * left-tailed test (null hypothesis - the mean of the first sample  is
#       greater than or equal to the mean of the second sample)
#     * right-tailed test (null hypothesis - the mean of the first sample is
#       less than or equal to the mean of the second sample).
# 
# Test is based on the following assumptions:
#     * given samples have normal distributions
#     * samples are independent.
# Dispersion equality is not required
# 
# Input parameters:
#     X - sample 1. Array whose index goes from 0 to N-1.
#     N - size of the sample.
#     Y - sample 2. Array whose index goes from 0 to M-1.
#     M - size of the sample.
# 
# Output parameters:
#     BothTails   -   p-value for two-tailed test.
#                     If BothTails is less than the given significance level
#                     the null hypothesis is rejected.
#     LeftTail    -   p-value for left-tailed test.
#                     If LeftTail is less than the given significance level,
#                     the null hypothesis is rejected.
#     RightTail   -   p-value for right-tailed test.
#                     If RightTail is less than the given significance level
#                     the null hypothesis is rejected.
# 
#   -- ALGLIB --
#      Copyright 18.09.2006 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: bothtails, lefttail, righttail = xalglib.unequalvariancettest(x, n, y, m)

</div></pre>
<a name=unit_svd></a><h2 class=pageheader><code>svd</code> module</h2>
<div class=pagecontent>
<h3 class=pageheader>Functions</h3>
<a href='#sub_rmatrixsvd' class=toc>rmatrixsvd</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='sub_rmatrixsvd'></a><h3 class=pageheader><code>rmatrixsvd</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Singular value decomposition of a rectangular matrix.
# 
# The algorithm calculates the singular value decomposition of a matrix of
# size MxN: A = U * S * V^T
# 
# The algorithm finds the singular values and, optionally, matrices U and V^T.
# The algorithm can find both first min(M,N) columns of matrix U and rows of
# matrix V^T (singular vectors), and matrices U and V^T wholly (of sizes MxM
# and NxN respectively).
# 
# Take into account that the subroutine does not return matrix V but V^T.
# 
# Input parameters:
#     A           -   matrix to be decomposed.
#                     Array whose indexes range within [0..M-1, 0..N-1].
#     M           -   number of rows in matrix A.
#     N           -   number of columns in matrix A.
#     UNeeded     -   0, 1 or 2. See the description of the parameter U.
#     VTNeeded    -   0, 1 or 2. See the description of the parameter VT.
#     AdditionalMemory -
#                     If the parameter:
#                      * equals 0, the algorithm doesnt use additional
#                        memory (lower requirements, lower performance).
#                      * equals 1, the algorithm uses additional
#                        memory of size min(M,N)*min(M,N) of real numbers.
#                        It often speeds up the algorithm.
#                      * equals 2, the algorithm uses additional
#                        memory of size M*min(M,N) of real numbers.
#                        It allows to get a maximum performance.
#                     The recommended value of the parameter is 2.
# 
# Output parameters:
#     W           -   contains singular values in descending order.
#     U           -   if UNeeded=0, U isn't changed, the left singular vectors
#                     are not calculated.
#                     if Uneeded=1, U contains left singular vectors (first
#                     min(M,N) columns of matrix U). Array whose indexes range
#                     within [0..M-1, 0..Min(M,N)-1].
#                     if UNeeded=2, U contains matrix U wholly. Array whose
#                     indexes range within [0..M-1, 0..M-1].
#     VT          -   if VTNeeded=0, VT isnt changed, the right singular vectors
#                     are not calculated.
#                     if VTNeeded=1, VT contains right singular vectors (first
#                     min(M,N) rows of matrix V^T). Array whose indexes range
#                     within [0..min(M,N)-1, 0..N-1].
#                     if VTNeeded=2, VT contains matrix V^T wholly. Array whose
#                     indexes range within [0..N-1, 0..N-1].
# 
#   -- ALGLIB --
#      Copyright 2005 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result, w, u, vt = xalglib.rmatrixsvd(a, m, n, uneeded, vtneeded, additionalmemory)

</div></pre>
<a name=unit_trfac></a><h2 class=pageheader><code>trfac</code> module</h2>
<div class=pagecontent>
<h3 class=pageheader>Functions</h3>
<a href='#sub_cmatrixlu' class=toc>cmatrixlu</a><br>
<a href='#sub_hpdmatrixcholesky' class=toc>hpdmatrixcholesky</a><br>
<a href='#sub_rmatrixlu' class=toc>rmatrixlu</a><br>
<a href='#sub_spdmatrixcholesky' class=toc>spdmatrixcholesky</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='sub_cmatrixlu'></a><h3 class=pageheader><code>cmatrixlu</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# LU decomposition of a general complex matrix with row pivoting
# 
# A is represented as A = P*L*U, where:
# * L is lower unitriangular matrix
# * U is upper triangular matrix
# * P = P0*P1*...*PK, K=min(M,N)-1,
#   Pi - permutation matrix for I and Pivots[I]
# 
# This is cache-oblivous implementation of LU decomposition. It is optimized
# for square matrices. As for rectangular matrices:
# * best case - M&gt;&gt;N
# * worst case - N&gt;&gt;M, small M, large N, matrix does not fit in CPU cache
# 
# INPUT PARAMETERS:
#     A       -   array[0..M-1, 0..N-1].
#     M       -   number of rows in matrix A.
#     N       -   number of columns in matrix A.
# 
# 
# OUTPUT PARAMETERS:
#     A       -   matrices L and U in compact form:
#                 * L is stored under main diagonal
#                 * U is stored on and above main diagonal
#     Pivots  -   permutation matrix in compact form.
#                 array[0..Min(M-1,N-1)].
# 
#   -- ALGLIB routine --
#      10.01.2010
#      Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: a, pivots = xalglib.cmatrixlu(a, m, n)

</div></pre>
<a name='sub_hpdmatrixcholesky'></a><h3 class=pageheader><code>hpdmatrixcholesky</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Cache-oblivious Cholesky decomposition
# 
# The algorithm computes Cholesky decomposition  of  a  Hermitian  positive-
# definite matrix. The result of an algorithm is a representation  of  A  as
# A=U'*U  or A=L*L' (here X' detones conj(X^T)).
# 
# INPUT PARAMETERS:
#     A       -   upper or lower triangle of a factorized matrix.
#                 array with elements [0..N-1, 0..N-1].
#     N       -   size of matrix A.
#     IsUpper -   if IsUpper=True, then A contains an upper triangle of
#                 a symmetric matrix, otherwise A contains a lower one.
# 
# OUTPUT PARAMETERS:
#     A       -   the result of factorization. If IsUpper=True, then
#                 the upper triangle contains matrix U, so that A = U'*U,
#                 and the elements below the main diagonal are not modified.
#                 Similarly, if IsUpper = False.
# 
# RESULT:
#     If  the  matrix  is  positive-definite,  the  function  returns  True.
#     Otherwise, the function returns False. Contents of A is not determined
#     in such case.
# 
#   -- ALGLIB routine --
#      15.12.2009
#      Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result, a = xalglib.hpdmatrixcholesky(a, n, isupper)

</div></pre>
<a name='sub_rmatrixlu'></a><h3 class=pageheader><code>rmatrixlu</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# LU decomposition of a general real matrix with row pivoting
# 
# A is represented as A = P*L*U, where:
# * L is lower unitriangular matrix
# * U is upper triangular matrix
# * P = P0*P1*...*PK, K=min(M,N)-1,
#   Pi - permutation matrix for I and Pivots[I]
# 
# This is cache-oblivous implementation of LU decomposition.
# It is optimized for square matrices. As for rectangular matrices:
# * best case - M&gt;&gt;N
# * worst case - N&gt;&gt;M, small M, large N, matrix does not fit in CPU cache
# 
# INPUT PARAMETERS:
#     A       -   array[0..M-1, 0..N-1].
#     M       -   number of rows in matrix A.
#     N       -   number of columns in matrix A.
# 
# 
# OUTPUT PARAMETERS:
#     A       -   matrices L and U in compact form:
#                 * L is stored under main diagonal
#                 * U is stored on and above main diagonal
#     Pivots  -   permutation matrix in compact form.
#                 array[0..Min(M-1,N-1)].
# 
#   -- ALGLIB routine --
#      10.01.2010
#      Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: a, pivots = xalglib.rmatrixlu(a, m, n)

</div></pre>
<a name='sub_spdmatrixcholesky'></a><h3 class=pageheader><code>spdmatrixcholesky</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Cache-oblivious Cholesky decomposition
# 
# The algorithm computes Cholesky decomposition  of  a  symmetric  positive-
# definite matrix. The result of an algorithm is a representation  of  A  as
# A=U^T*U  or A=L*L^T
# 
# INPUT PARAMETERS:
#     A       -   upper or lower triangle of a factorized matrix.
#                 array with elements [0..N-1, 0..N-1].
#     N       -   size of matrix A.
#     IsUpper -   if IsUpper=True, then A contains an upper triangle of
#                 a symmetric matrix, otherwise A contains a lower one.
# 
# OUTPUT PARAMETERS:
#     A       -   the result of factorization. If IsUpper=True, then
#                 the upper triangle contains matrix U, so that A = U^T*U,
#                 and the elements below the main diagonal are not modified.
#                 Similarly, if IsUpper = False.
# 
# RESULT:
#     If  the  matrix  is  positive-definite,  the  function  returns  True.
#     Otherwise, the function returns False. Contents of A is not determined
#     in such case.
# 
#   -- ALGLIB routine --
#      15.12.2009
#      Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: result, a = xalglib.spdmatrixcholesky(a, n, isupper)

</div></pre>
<a name=unit_trigintegrals></a><h2 class=pageheader><code>trigintegrals</code> module</h2>
<div class=pagecontent>
<h3 class=pageheader>Functions</h3>
<a href='#sub_hyperbolicsinecosineintegrals' class=toc>hyperbolicsinecosineintegrals</a><br>
<a href='#sub_sinecosineintegrals' class=toc>sinecosineintegrals</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='sub_hyperbolicsinecosineintegrals'></a><h3 class=pageheader><code>hyperbolicsinecosineintegrals</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Hyperbolic sine and cosine integrals
# 
# Approximates the integrals
# 
#                            x
#                            -
#                           | |   cosh t - 1
#   Chi(x) = eul + ln x +   |    -----------  dt,
#                         | |          t
#                          -
#                          0
# 
#               x
#               -
#              | |  sinh t
#   Shi(x) =   |    ------  dt
#            | |       t
#             -
#             0
# 
# where eul = 0.57721566490153286061 is Euler's constant.
# The integrals are evaluated by power series for x &lt; 8
# and by Chebyshev expansions for x between 8 and 88.
# For large x, both functions approach exp(x)/2x.
# Arguments greater than 88 in magnitude return MAXNUM.
# 
# 
# ACCURACY:
# 
# Test interval 0 to 88.
#                      Relative error:
# arithmetic   function  # trials      peak         rms
#    IEEE         Shi      30000       6.9e-16     1.6e-16
#        Absolute error, except relative when |Chi| &gt; 1:
#    IEEE         Chi      30000       8.4e-16     1.4e-16
# 
# Cephes Math Library Release 2.8:  June, 2000
# Copyright 1984, 1987, 2000 by Stephen L. Moshier
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: shi, chi = xalglib.hyperbolicsinecosineintegrals(x)

</div></pre>
<a name='sub_sinecosineintegrals'></a><h3 class=pageheader><code>sinecosineintegrals</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Sine and cosine integrals
# 
# Evaluates the integrals
# 
#                          x
#                          -
#                         |  cos t - 1
#   Ci(x) = eul + ln x +  |  --------- dt,
#                         |      t
#                        -
#                         0
#             x
#             -
#            |  sin t
#   Si(x) =  |  ----- dt
#            |    t
#           -
#            0
# 
# where eul = 0.57721566490153286061 is Euler's constant.
# The integrals are approximated by rational functions.
# For x &gt; 8 auxiliary functions f(x) and g(x) are employed
# such that
# 
# Ci(x) = f(x) sin(x) - g(x) cos(x)
# Si(x) = pi/2 - f(x) cos(x) - g(x) sin(x)
# 
# 
# ACCURACY:
#    Test interval = [0,50].
# Absolute error, except relative when &gt; 1:
# arithmetic   function   # trials      peak         rms
#    IEEE        Si        30000       4.4e-16     7.3e-17
#    IEEE        Ci        30000       6.9e-16     5.1e-17
# 
# Cephes Math Library Release 2.1:  January, 1989
# Copyright 1984, 1987, 1989 by Stephen L. Moshier
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: si, ci = xalglib.sinecosineintegrals(x)

</div></pre>
<a name=unit_variancetests></a><h2 class=pageheader><code>variancetests</code> module</h2>
<div class=pagecontent>
<h3 class=pageheader>Functions</h3>
<a href='#sub_ftest' class=toc>ftest</a><br>
<a href='#sub_onesamplevariancetest' class=toc>onesamplevariancetest</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='sub_ftest'></a><h3 class=pageheader><code>ftest</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Two-sample F-test
# 
# This test checks three hypotheses about dispersions of the given  samples.
# The following tests are performed:
#     * two-tailed test (null hypothesis - the dispersions are equal)
#     * left-tailed test (null hypothesis  -  the  dispersion  of  the first
#       sample is greater than or equal to  the  dispersion  of  the  second
#       sample).
#     * right-tailed test (null hypothesis - the  dispersion  of  the  first
#       sample is less than or equal to the dispersion of the second sample)
# 
# The test is based on the following assumptions:
#     * the given samples have normal distributions
#     * the samples are independent.
# 
# Input parameters:
#     X   -   sample 1. Array whose index goes from 0 to N-1.
#     N   -   sample size.
#     Y   -   sample 2. Array whose index goes from 0 to M-1.
#     M   -   sample size.
# 
# Output parameters:
#     BothTails   -   p-value for two-tailed test.
#                     If BothTails is less than the given significance level
#                     the null hypothesis is rejected.
#     LeftTail    -   p-value for left-tailed test.
#                     If LeftTail is less than the given significance level,
#                     the null hypothesis is rejected.
#     RightTail   -   p-value for right-tailed test.
#                     If RightTail is less than the given significance level
#                     the null hypothesis is rejected.
# 
#   -- ALGLIB --
#      Copyright 19.09.2006 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: bothtails, lefttail, righttail = xalglib.ftest(x, n, y, m)

</div></pre>
<a name='sub_onesamplevariancetest'></a><h3 class=pageheader><code>onesamplevariancetest</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# One-sample chi-square test
# 
# This test checks three hypotheses about the dispersion of the given sample
# The following tests are performed:
#     * two-tailed test (null hypothesis - the dispersion equals  the  given
#       number)
#     * left-tailed test (null hypothesis - the dispersion is  greater  than
#       or equal to the given number)
#     * right-tailed test (null hypothesis  -  dispersion is  less  than  or
#       equal to the given number).
# 
# Test is based on the following assumptions:
#     * the given sample has a normal distribution.
# 
# Input parameters:
#     X           -   sample 1. Array whose index goes from 0 to N-1.
#     N           -   size of the sample.
#     Variance    -   dispersion value to compare with.
# 
# Output parameters:
#     BothTails   -   p-value for two-tailed test.
#                     If BothTails is less than the given significance level
#                     the null hypothesis is rejected.
#     LeftTail    -   p-value for left-tailed test.
#                     If LeftTail is less than the given significance level,
#                     the null hypothesis is rejected.
#     RightTail   -   p-value for right-tailed test.
#                     If RightTail is less than the given significance level
#                     the null hypothesis is rejected.
# 
#   -- ALGLIB --
#      Copyright 19.09.2006 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: bothtails, lefttail, righttail = xalglib.onesamplevariancetest(x, n, variance)

</div></pre>
<a name=unit_wsr></a><h2 class=pageheader><code>wsr</code> module</h2>
<div class=pagecontent>
<h3 class=pageheader>Functions</h3>
<a href='#sub_wilcoxonsignedranktest' class=toc>wilcoxonsignedranktest</a><br>
<h3 class=pageheader>Examples</h3>
<table border=0 cellspacing=0 class='pagecontent'>
</table></div>
<a name='sub_wilcoxonsignedranktest'></a><h3 class=pageheader><code>wilcoxonsignedranktest</code> function</h3>
<pre class=source>
<div style='color: DarkCyan; margin-top: 0; margin-bottom: 0;'>
#
# Wilcoxon signed-rank test
# 
# This test checks three hypotheses about the median  of  the  given sample.
# The following tests are performed:
#     * two-tailed test (null hypothesis - the median is equal to the  given
#       value)
#     * left-tailed test (null hypothesis - the median is  greater  than  or
#       equal to the given value)
#     * right-tailed test (null hypothesis  -  the  median  is  less than or
#       equal to the given value)
# 
# Requirements:
#     * the scale of measurement should be ordinal, interval or  ratio (i.e.
#       the test could not be applied to nominal variables).
#     * the distribution should be continuous and symmetric relative to  its
#       median.
#     * number of distinct values in the X array should be greater than 4
# 
# The test is non-parametric and doesn't require distribution X to be normal
# 
# Input parameters:
#     X       -   sample. Array whose index goes from 0 to N-1.
#     N       -   size of the sample.
#     Median  -   assumed median value.
# 
# Output parameters:
#     BothTails   -   p-value for two-tailed test.
#                     If BothTails is less than the given significance level
#                     the null hypothesis is rejected.
#     LeftTail    -   p-value for left-tailed test.
#                     If LeftTail is less than the given significance level,
#                     the null hypothesis is rejected.
#     RightTail   -   p-value for right-tailed test.
#                     If RightTail is less than the given significance level
#                     the null hypothesis is rejected.
# 
# To calculate p-values, special approximation is used. This method lets  us
# calculate p-values with two decimal places in interval [0.0001, 1].
# 
# &quot;Two decimal places&quot; does not sound very impressive, but in  practice  the
# relative error of less than 1% is enough to make a decision.
# 
# There is no approximation outside the [0.0001, 1] interval. Therefore,  if
# the significance level outlies this interval, the test returns 0.0001.
# 
#   -- ALGLIB --
#      Copyright 08.09.2006 by Bochkanov Sergey
#

</div><div style='margin-top: 0; margin-bottom: 0;'>SYNTAX: bothtails, lefttail, righttail = xalglib.wilcoxonsignedranktest(x, n, e)

</div></pre>

</body>
</html>